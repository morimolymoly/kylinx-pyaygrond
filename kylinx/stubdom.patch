diff -ruN xen-4.2.1-origin/stubdom/c/main.c xen-4.2.1-merge/stubdom/c/main.c
--- xen-4.2.1-origin/stubdom/c/main.c	2012-12-17 23:00:06.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c/main.c	2016-12-04 21:39:57.000000000 +0800
@@ -1,8 +1,14 @@
 #include <stdio.h>
-#include <unistd.h>
+#include <so_test.h>
 
-int main(void) {
-        sleep(2);
-        printf("Hello, world!\n");
+int main(void)
+{
+    while(1)
+    {
+                sleep(2);
+                so_test();
+            
+    }
         return 0;
+
 }
diff -ruN xen-4.2.1-origin/stubdom/c/main_domU_fork.c xen-4.2.1-merge/stubdom/c/main_domU_fork.c
--- xen-4.2.1-origin/stubdom/c/main_domU_fork.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c/main_domU_fork.c	2016-12-04 10:05:18.000000000 +0800
@@ -0,0 +1,271 @@
+#include <stdio.h>
+#include <setjmp.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+#include <ctype.h>
+
+#include <sys/time.h>
+#include <mini-os/sched.h>
+#include <xenstore.h>
+#include <assert.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sched.h>
+#include <mini-os/lib.h>
+#include <mini-os/xmalloc.h>
+#include <mini-os/gntmap.h>
+#include <mini-os/events.h>
+#include <mini-os/hypervisor.h>
+unsigned int domid;
+// get domID
+unsigned int get_domid(struct xs_handle *xs)
+{
+	char *buf;
+	unsigned int len, domid;
+	buf = xs_read(xs, XBT_NULL, "domid", &len);
+	domid = atoi(buf);
+	printf("---> domid : %d\n", domid);
+	return domid;
+}
+// 查询xenstore判断自己是父DomU还是子DomU
+char *read_xenstore(char *key) //check_state()
+{
+	struct xs_handle *xs;
+	char *path;
+	char *rcv_data;
+	unsigned int len;
+/* Get a connection to the daemon */
+	xs = xs_daemon_open();
+	if ( xs == NULL )
+	{
+		perror("---> xs_deamon_open:");
+	}
+	//printf("---> xs_deamon_open OK!\n");
+	domid = get_domid(xs);
+/* Get the local domain path */
+	path = xs_get_domain_path(xs, domid);
+	if ( path == NULL )
+	{
+		perror("---> get_domain_path:");
+	}
+	//printf("---> get_domain_path OK! path = %s\n", path);
+/* Make space for our node on the path */
+	path = realloc(path, strlen(path) + strlen("/console/") + strlen(key) + 1);
+	if ( path == NULL )
+	{
+		perror("---> realloc_path:");
+	}
+	strcat(path, "/console/");
+	strcat(path, key);
+	//printf("---> realloc_path OK! path = %s\n", path);
+	rcv_data = xs_read(xs, XBT_NULL, path, &len);
+	//printf("---> reading OK! data = %s\n\n\n", *rcv_data);
+	if(!rcv_data){
+		return NULL;
+	}
+
+	free(path);
+	xs_daemon_close(xs);
+	return rcv_data;
+}
+// 将int转成char *
+char* itoa(int num) {
+	char str[10];
+	int base = 10000;
+	while (num / base == 0) {
+		base = base / 10;
+	}
+	int i = 0;
+	while (base > 0) {
+		str[i++] = '0' + num / base;
+		num = num % base;
+		base = base / 10;
+	}
+	str[i] = '\0';
+	return str;
+}
+// 将配置参数写到xenstore
+void write_xenstore(char *key, char *value) {
+	struct xs_handle *xs;
+	char *path;
+	bool err;
+/* Get a connection to the daemon */
+	xs = xs_daemon_open();
+	if ( xs == NULL )
+	{
+		perror("---> xs_deamon_open:");
+	}
+	//printf("---> xs_deamon_open OK!\n");
+/* Get the local domain path */
+	path = xs_get_domain_path(xs, domid);
+	if ( path == NULL )
+	{
+		perror("---> get_domain_path:");
+	}
+	//printf("---> get_domain_path OK! path = %s\n", path);
+/* Make space for our node on the path */
+	path = realloc(path, strlen(path) + strlen("/console/") + strlen(key) + 1);
+	if ( path == NULL )
+	{
+		perror("---> realloc_path:");
+	}
+	strcat(path, "/console/");
+	strcat(path, key);
+	//printf("---> realloc_path OK! path = %s\n", path);
+	//char str_value[10];
+	//itoa(str_value, value);
+	err =  xs_write(xs, XBT_NULL, path, value, strlen(value));  
+	if (!err) {
+		printf("\n Could'nt write var in xenstore" );  
+	}
+
+	free(path);
+	xs_daemon_close(xs);
+}
+
+void dofork(int function) {
+	write_xenstore("child_do_function", function);
+}
+void fun1() {
+	printf("child do function 1\n");
+}
+void fun2() {
+	printf("child do function 2\n");
+}
+void fun3() {
+	printf("child do function 3\n");
+}
+int main()
+{
+	sleep(1);
+	int is_parent = atoi(read_xenstore("is_parent"));
+	printf("is_parent: %d\n", is_parent);
+	char shared_page[1024];
+	void *receive_page;
+	unsigned long offset;
+	unsigned long offset_end;
+	if (is_parent == 1) {
+		goto parent;
+	} else {
+		goto child;
+	}
+parent:
+	strcpy(shared_page, "Hello child");
+	printf("---> I am parent DomU!\n");
+	printf("machine address : %p\n", virt_to_mfn(shared_page));
+	printf("virtual address : %p\n", (shared_page));
+	offset = ((unsigned long)shared_page & 0x0000000000000fff);
+	printf("%lu\n", offset);
+	offset_end = offset + strlen("zhangchengfei");
+// 开始授权
+	grant_ref_t grant = gnttab_grant_access(domid + 1, virt_to_mfn(shared_page), 0);
+// 更新xenstore配置
+	char str_value[10];
+	sprintf(str_value, "%d", offset);
+	write_xenstore("offset", str_value);
+
+	sprintf(str_value, "%d", offset_end);
+	write_xenstore("offset_end", str_value);
+
+	sprintf(str_value, "%d", 1);
+	write_xenstore("done_fork", str_value); // 1表示已经做了fork
+
+	sprintf(str_value, "%d", grant);
+	write_xenstore("refs", str_value);
+
+	sprintf(str_value, "%d", domid);
+	write_xenstore("pdomid", str_value);
+	//dofork(1);
+
+	jmp_buf buf;
+    setjmp(buf);
+    printf("in fork\n");
+	printf("RBX:%d RBP:%d R12:%d R13:%d R14:%d R15:%d RSP:%d RIP:%d\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+	sprintf(str_value, "%d", buf[0]);
+	write_xenstore("RBX", str_value)
+		;
+	sprintf(str_value, "%d", buf[1]);
+	write_xenstore("RBP", str_value);
+
+	sprintf(str_value, "%d", buf[2]);
+	write_xenstore("R12", str_value);
+
+	sprintf(str_value, "%d", buf[3]);
+	write_xenstore("R13", str_value);
+
+	sprintf(str_value, "%d", buf[4]);
+	write_xenstore("R14", str_value);
+
+	sprintf(str_value, "%d", buf[5]);
+	write_xenstore("R15", str_value);
+
+	sprintf(str_value, "%d", buf[6]);
+	write_xenstore("RSP", str_value);
+
+	sprintf(str_value, "%d", buf[7]);
+	write_xenstore("RIP", str_value);
+
+	int i = 0;
+	while (1){ 
+		sleep(1);
+		i++;
+		if (i < 2) 
+			printf("shared page on %d\n", grant);
+		
+	}
+	gnttab_end_access(grant);
+	return 0;
+	
+child:
+	printf("---> I am child DomU!\n");
+	struct gntmap *map = (struct gntmap *)malloc(sizeof(struct gntmap));
+	offset = atoi(read_xenstore("offset"));
+	offset_end = atoi(read_xenstore("offset_end"));
+	sleep(1);
+	uint32_t refs = atoi(read_xenstore("refs"));
+	uint32_t pdomid = atoi(read_xenstore("pdomid"));
+	//uint32_t child_do_function= atoi(read_xenstore("child_do_function"));
+	printf("-------------------------------> %d\n", pdomid);
+	gntmap_init(map);
+	char buffer[4096];
+	receive_page = gntmap_map_grant_refs(map, 1, &pdomid, 0, &refs, 0);
+	memcpy(buffer, receive_page , sizeof(char) * 4096);
+	printf("----> %p\n", virt_to_mfn(receive_page));
+	printf("rcv_data: ");
+	for (int i = offset; i < offset_end; i++) {
+		printf("%c", buffer[i]);
+	}
+	printf("\n");
+	//switch (child_do_function) {
+	//	case 1: fun1(); break;
+	//	case 2: fun2(); break;
+	//	case 3: fun3(); break;
+	//}
+
+	printf("RBX: %s\n", read_xenstore("RBX"));
+    printf("RBP: %s\n", read_xenstore("RBP"));
+    printf("R12: %s\n", read_xenstore("R12"));
+    printf("R13: %s\n", read_xenstore("R13"));
+    printf("R14: %s\n", read_xenstore("R14"));
+    printf("R15: %s\n", read_xenstore("R15"));
+    printf("RSP: %s\n", read_xenstore("RSP"));
+    printf("RIP: %s\n", read_xenstore("RIP"));
+
+	gntmap_fini(map);
+
+
+	//通知父domU要退出了	
+	//write_xenstore("exit_sig", exit_sig);
+
+	while(1){
+		sleep(5);
+		printf("hello world\n");
+	}
+	return 0;
+}
diff -ruN xen-4.2.1-origin/stubdom/c/main_origin.c xen-4.2.1-merge/stubdom/c/main_origin.c
--- xen-4.2.1-origin/stubdom/c/main_origin.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c/main_origin.c	2016-12-04 10:07:51.000000000 +0800
@@ -0,0 +1,8 @@
+#include <stdio.h>
+int main () {
+    while(1){
+        sleep(3);
+        printf("hello world\n");
+    }
+    return 0;
+}
diff -ruN xen-4.2.1-origin/stubdom/c/main_so_test.c xen-4.2.1-merge/stubdom/c/main_so_test.c
--- xen-4.2.1-origin/stubdom/c/main_so_test.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c/main_so_test.c	2016-12-04 21:00:50.000000000 +0800
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <so_test.h>
+
+int main(void)
+{
+        sleep(1);
+
+        while(1)
+    {
+                sleep(2);
+                so_test();
+            
+    }
+        return 0;
+
+}
diff -ruN xen-4.2.1-origin/stubdom/c/Makefile xen-4.2.1-merge/stubdom/c/Makefile
--- xen-4.2.1-origin/stubdom/c/Makefile	2012-12-17 23:00:06.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c/Makefile	2016-07-03 21:22:38.000000000 +0800
@@ -1,11 +1,11 @@
 XEN_ROOT = $(CURDIR)/../..
 
 include $(XEN_ROOT)/Config.mk
-
 all: main.a
 
 main.a: main.o 
 	$(AR) cr $@ $^
 
+main.o: main.c
 clean:
 	rm -f *.a *.o
diff -ruN xen-4.2.1-origin/stubdom/c/minios.cfg xen-4.2.1-merge/stubdom/c/minios.cfg
--- xen-4.2.1-origin/stubdom/c/minios.cfg	2012-12-17 23:00:06.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c/minios.cfg	2016-06-27 14:58:54.000000000 +0800
@@ -1 +1 @@
-CONFIG_TEST=y
+CONFIG_TEST=n
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/adlist.c xen-4.2.1-merge/stubdom/c_httpd_redis/adlist.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/adlist.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/adlist.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,296 @@
+/* adlist.c - A generic doubly linked list implementation
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include <stdlib.h>
+#include "adlist.h"
+#include "zmalloc.h"
+
+/* Create a new list. The created list can be freed with
+ * AlFreeList(), but private value of every node need to be freed
+ * by the user before to call AlFreeList().
+ *
+ * On error, NULL is returned. Otherwise the pointer to the new list. */
+list *listCreate(void)
+{
+    struct list *list;
+
+    if ((list = zmalloc(sizeof(*list))) == NULL)
+        return NULL;
+    list->head = list->tail = NULL;
+    list->len = 0;
+    list->dup = NULL;
+    list->free = NULL;
+    list->match = NULL;
+    return list;
+}
+
+/* Free the whole list.
+ *
+ * This function can't fail. */
+void listRelease(list *list)
+{
+    unsigned int len;
+    listNode *current, *next;
+
+    current = list->head;
+    len = list->len;
+    while(len--) {
+        next = current->next;
+        if (list->free) list->free(current->value);
+        zfree(current);
+        current = next;
+    }
+    zfree(list);
+}
+
+/* Add a new node to the list, to head, contaning the specified 'value'
+ * pointer as value.
+ *
+ * On error, NULL is returned and no operation is performed (i.e. the
+ * list remains unaltered).
+ * On success the 'list' pointer you pass to the function is returned. */
+list *listAddNodeHead(list *list, void *value)
+{
+    listNode *node;
+
+    if ((node = zmalloc(sizeof(*node))) == NULL)
+        return NULL;
+    node->value = value;
+    if (list->len == 0) {
+        list->head = list->tail = node;
+        node->prev = node->next = NULL;
+    } else {
+        node->prev = NULL;
+        node->next = list->head;
+        list->head->prev = node;
+        list->head = node;
+    }
+    list->len++;
+    return list;
+}
+
+/* Add a new node to the list, to tail, contaning the specified 'value'
+ * pointer as value.
+ *
+ * On error, NULL is returned and no operation is performed (i.e. the
+ * list remains unaltered).
+ * On success the 'list' pointer you pass to the function is returned. */
+list *listAddNodeTail(list *list, void *value)
+{
+    listNode *node;
+
+    if ((node = zmalloc(sizeof(*node))) == NULL)
+        return NULL;
+    node->value = value;
+    if (list->len == 0) {
+        list->head = list->tail = node;
+        node->prev = node->next = NULL;
+    } else {
+        node->prev = list->tail;
+        node->next = NULL;
+        list->tail->next = node;
+        list->tail = node;
+    }
+    list->len++;
+    return list;
+}
+
+/* Remove the specified node from the specified list.
+ * It's up to the caller to free the private value of the node.
+ *
+ * This function can't fail. */
+void listDelNode(list *list, listNode *node)
+{
+    if (node->prev)
+        node->prev->next = node->next;
+    else
+        list->head = node->next;
+    if (node->next)
+        node->next->prev = node->prev;
+    else
+        list->tail = node->prev;
+    if (list->free) list->free(node->value);
+    zfree(node);
+    list->len--;
+}
+
+/* Returns a list iterator 'iter'. After the initialization every
+ * call to listNext() will return the next element of the list.
+ *
+ * This function can't fail. */
+listIter *listGetIterator(list *list, int direction)
+{
+    listIter *iter;
+    
+    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;
+    if (direction == AL_START_HEAD)
+        iter->next = list->head;
+    else
+        iter->next = list->tail;
+    iter->direction = direction;
+    return iter;
+}
+
+/* Release the iterator memory */
+void listReleaseIterator(listIter *iter) {
+    zfree(iter);
+}
+
+/* Create an iterator in the list private iterator structure */
+void listRewind(list *list, listIter *li) {
+    li->next = list->head;
+    li->direction = AL_START_HEAD;
+}
+
+void listRewindTail(list *list, listIter *li) {
+    li->next = list->tail;
+    li->direction = AL_START_TAIL;
+}
+
+/* Return the next element of an iterator.
+ * It's valid to remove the currently returned element using
+ * listDelNode(), but not to remove other elements.
+ *
+ * The function returns a pointer to the next element of the list,
+ * or NULL if there are no more elements, so the classical usage patter
+ * is:
+ *
+ * iter = listGetItarotr(list,<direction>);
+ * while ((node = listNextIterator(iter)) != NULL) {
+ *     DoSomethingWith(listNodeValue(node));
+ * }
+ *
+ * */
+listNode *listNext(listIter *iter)
+{
+    listNode *current = iter->next;
+
+    if (current != NULL) {
+        if (iter->direction == AL_START_HEAD)
+            iter->next = current->next;
+        else
+            iter->next = current->prev;
+    }
+    return current;
+}
+
+/* Duplicate the whole list. On out of memory NULL is returned.
+ * On success a copy of the original list is returned.
+ *
+ * The 'Dup' method set with listSetDupMethod() function is used
+ * to copy the node value. Otherwise the same pointer value of
+ * the original node is used as value of the copied node.
+ *
+ * The original list both on success or error is never modified. */
+list *listDup(list *orig)
+{
+    list *copy;
+    listIter *iter;
+    listNode *node;
+
+    if ((copy = listCreate()) == NULL)
+        return NULL;
+    copy->dup = orig->dup;
+    copy->free = orig->free;
+    copy->match = orig->match;
+    iter = listGetIterator(orig, AL_START_HEAD);
+    while((node = listNext(iter)) != NULL) {
+        void *value;
+
+        if (copy->dup) {
+            value = copy->dup(node->value);
+            if (value == NULL) {
+                listRelease(copy);
+                listReleaseIterator(iter);
+                return NULL;
+            }
+        } else
+            value = node->value;
+        if (listAddNodeTail(copy, value) == NULL) {
+            listRelease(copy);
+            listReleaseIterator(iter);
+            return NULL;
+        }
+    }
+    listReleaseIterator(iter);
+    return copy;
+}
+
+/* Search the list for a node matching a given key.
+ * The match is performed using the 'match' method
+ * set with listSetMatchMethod(). If no 'match' method
+ * is set, the 'value' pointer of every node is directly
+ * compared with the 'key' pointer.
+ *
+ * On success the first matching node pointer is returned
+ * (search starts from head). If no matching node exists
+ * NULL is returned. */
+listNode *listSearchKey(list *list, void *key)
+{
+    listIter *iter;
+    listNode *node;
+
+    iter = listGetIterator(list, AL_START_HEAD);
+    while((node = listNext(iter)) != NULL) {
+        if (list->match) {
+            if (list->match(node->value, key)) {
+                listReleaseIterator(iter);
+                return node;
+            }
+        } else {
+            if (key == node->value) {
+                listReleaseIterator(iter);
+                return node;
+            }
+        }
+    }
+    listReleaseIterator(iter);
+    return NULL;
+}
+
+/* Return the element at the specified zero-based index
+ * where 0 is the head, 1 is the element next to head
+ * and so on. Negative integers are used in order to count
+ * from the tail, -1 is the last element, -2 the penultimante
+ * and so on. If the index is out of range NULL is returned. */
+listNode *listIndex(list *list, int index) {
+    listNode *n;
+
+    if (index < 0) {
+        index = (-index)-1;
+        n = list->tail;
+        while(index-- && n) n = n->prev;
+    } else {
+        n = list->head;
+        while(index-- && n) n = n->next;
+    }
+    return n;
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/adlist.h xen-4.2.1-merge/stubdom/c_httpd_redis/adlist.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/adlist.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/adlist.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,91 @@
+/* adlist.h - A generic doubly linked list implementation
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ADLIST_H__
+#define __ADLIST_H__
+
+/* Node, List, and Iterator are the only data structures used currently. */
+
+typedef struct listNode {
+    struct listNode *prev;
+    struct listNode *next;
+    void *value;
+} listNode;
+
+typedef struct listIter {
+    listNode *next;
+    int direction;
+} listIter;
+
+typedef struct list {
+    listNode *head;
+    listNode *tail;
+    void *(*dup)(void *ptr);
+    void (*free)(void *ptr);
+    int (*match)(void *ptr, void *key);
+    unsigned int len;
+} list;
+
+/* Functions implemented as macros */
+#define listLength(l) ((l)->len)
+#define listFirst(l) ((l)->head)
+#define listLast(l) ((l)->tail)
+#define listPrevNode(n) ((n)->prev)
+#define listNextNode(n) ((n)->next)
+#define listNodeValue(n) ((n)->value)
+
+#define listSetDupMethod(l,m) ((l)->dup = (m))
+#define listSetFreeMethod(l,m) ((l)->free = (m))
+#define listSetMatchMethod(l,m) ((l)->match = (m))
+
+#define listGetDupMethod(l) ((l)->dup)
+#define listGetFree(l) ((l)->free)
+#define listGetMatchMethod(l) ((l)->match)
+
+/* Prototypes */
+list *listCreate(void);
+void listRelease(list *list);
+list *listAddNodeHead(list *list, void *value);
+list *listAddNodeTail(list *list, void *value);
+void listDelNode(list *list, listNode *node);
+listIter *listGetIterator(list *list, int direction);
+listNode *listNext(listIter *iter);
+void listReleaseIterator(listIter *iter);
+list *listDup(list *orig);
+listNode *listSearchKey(list *list, void *key);
+listNode *listIndex(list *list, int index);
+void listRewind(list *list, listIter *li);
+void listRewindTail(list *list, listIter *li);
+
+/* Directions for iterators */
+#define AL_START_HEAD 0
+#define AL_START_TAIL 1
+
+#endif /* __ADLIST_H__ */
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/ae.c xen-4.2.1-merge/stubdom/c_httpd_redis/ae.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/ae.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/ae.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,390 @@
+/* A simple event-driven programming library. Originally I wrote this code
+ * for the Jim's event-loop (Jim is a Tcl interpreter) but later translated
+ * it in form of a library for easy reuse.
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#include "ae.h"
+#include "zmalloc.h"
+#include "config.h"
+
+/* Include the best multiplexing layer supported by this system.
+ * The following should be ordered by performances, descending. */
+#ifdef HAVE_EPOLL
+#include "ae_epoll.c"
+#else
+    #ifdef HAVE_KQUEUE
+    #include "ae_kqueue.c"
+    #else
+    #include "ae_select.c"
+    #endif
+#endif
+
+aeEventLoop *aeCreateEventLoop(void) {
+    aeEventLoop *eventLoop;
+    int i;
+
+    eventLoop = zmalloc(sizeof(*eventLoop));
+    if (!eventLoop) return NULL;
+    eventLoop->timeEventHead = NULL;
+    eventLoop->timeEventNextId = 0;
+    eventLoop->stop = 0;
+    eventLoop->maxfd = -1;
+    eventLoop->beforesleep = NULL;
+    if (aeApiCreate(eventLoop) == -1) {
+        zfree(eventLoop);
+        return NULL;
+    }
+    /* Events with mask == AE_NONE are not set. So let's initialize the
+     * vector with it. */
+    for (i = 0; i < AE_SETSIZE; i++)
+        eventLoop->events[i].mask = AE_NONE;
+    return eventLoop;
+}
+
+void aeDeleteEventLoop(aeEventLoop *eventLoop) {
+    aeApiFree(eventLoop);
+    zfree(eventLoop);
+}
+
+void aeStop(aeEventLoop *eventLoop) {
+    eventLoop->stop = 1;
+}
+
+int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
+        aeFileProc *proc, void *clientData)
+{
+    if (fd >= AE_SETSIZE) return AE_ERR;
+    aeFileEvent *fe = &eventLoop->events[fd];
+
+    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
+        return AE_ERR;
+    fe->mask |= mask;
+    if (mask & AE_READABLE) fe->rfileProc = proc;
+    if (mask & AE_WRITABLE) fe->wfileProc = proc;
+    fe->clientData = clientData;
+    if (fd > eventLoop->maxfd)
+        eventLoop->maxfd = fd;
+    return AE_OK;
+}
+
+void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
+{
+    if (fd >= AE_SETSIZE) return;
+    aeFileEvent *fe = &eventLoop->events[fd];
+
+    if (fe->mask == AE_NONE) return;
+    fe->mask = fe->mask & (~mask);
+    if (fd == eventLoop->maxfd && fe->mask == AE_NONE) {
+        /* Update the max fd */
+        int j;
+
+        for (j = eventLoop->maxfd-1; j >= 0; j--)
+            if (eventLoop->events[j].mask != AE_NONE) break;
+        eventLoop->maxfd = j;
+    }
+    aeApiDelEvent(eventLoop, fd, mask);
+}
+
+static void aeGetTime(long *seconds, long *milliseconds)
+{
+    struct timeval tv;
+
+    gettimeofday(&tv, NULL);
+    *seconds = tv.tv_sec;
+    *milliseconds = tv.tv_usec/1000;
+}
+
+static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {
+    long cur_sec, cur_ms, when_sec, when_ms;
+
+    aeGetTime(&cur_sec, &cur_ms);
+    when_sec = cur_sec + milliseconds/1000;
+    when_ms = cur_ms + milliseconds%1000;
+    if (when_ms >= 1000) {
+        when_sec ++;
+        when_ms -= 1000;
+    }
+    *sec = when_sec;
+    *ms = when_ms;
+}
+
+long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
+        aeTimeProc *proc, void *clientData,
+        aeEventFinalizerProc *finalizerProc)
+{
+    long long id = eventLoop->timeEventNextId++;
+    aeTimeEvent *te;
+
+    te = zmalloc(sizeof(*te));
+    if (te == NULL) return AE_ERR;
+    te->id = id;
+    aeAddMillisecondsToNow(milliseconds,&te->when_sec,&te->when_ms);
+    te->timeProc = proc;
+    te->finalizerProc = finalizerProc;
+    te->clientData = clientData;
+    te->next = eventLoop->timeEventHead;
+    eventLoop->timeEventHead = te;
+    return id;
+}
+
+int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
+{
+    aeTimeEvent *te, *prev = NULL;
+
+    te = eventLoop->timeEventHead;
+    while(te) {
+        if (te->id == id) {
+            if (prev == NULL)
+                eventLoop->timeEventHead = te->next;
+            else
+                prev->next = te->next;
+            if (te->finalizerProc)
+                te->finalizerProc(eventLoop, te->clientData);
+            zfree(te);
+            return AE_OK;
+        }
+        prev = te;
+        te = te->next;
+    }
+    return AE_ERR; /* NO event with the specified ID found */
+}
+
+/* Search the first timer to fire.
+ * This operation is useful to know how many time the select can be
+ * put in sleep without to delay any event.
+ * If there are no timers NULL is returned.
+ *
+ * Note that's O(N) since time events are unsorted.
+ * Possible optimizations (not needed by Redis so far, but...):
+ * 1) Insert the event in order, so that the nearest is just the head.
+ *    Much better but still insertion or deletion of timers is O(N).
+ * 2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)).
+ */
+static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)
+{
+    aeTimeEvent *te = eventLoop->timeEventHead;
+    aeTimeEvent *nearest = NULL;
+
+    while(te) {
+        if (!nearest || te->when_sec < nearest->when_sec ||
+                (te->when_sec == nearest->when_sec &&
+                 te->when_ms < nearest->when_ms))
+            nearest = te;
+        te = te->next;
+    }
+    return nearest;
+}
+
+/* Process time events */
+static int processTimeEvents(aeEventLoop *eventLoop) {
+    int processed = 0;
+    aeTimeEvent *te;
+    long long maxId;
+
+    te = eventLoop->timeEventHead;
+    maxId = eventLoop->timeEventNextId-1;
+    while(te) {
+        long now_sec, now_ms;
+        long long id;
+
+        if (te->id > maxId) {
+            te = te->next;
+            continue;
+        }
+        aeGetTime(&now_sec, &now_ms);
+        if (now_sec > te->when_sec ||
+            (now_sec == te->when_sec && now_ms >= te->when_ms))
+        {
+            int retval;
+
+            id = te->id;
+            retval = te->timeProc(eventLoop, id, te->clientData);
+            processed++;
+            /* After an event is processed our time event list may
+             * no longer be the same, so we restart from head.
+             * Still we make sure to don't process events registered
+             * by event handlers itself in order to don't loop forever.
+             * To do so we saved the max ID we want to handle.
+             *
+             * FUTURE OPTIMIZATIONS:
+             * Note that this is NOT great algorithmically. Redis uses
+             * a single time event so it's not a problem but the right
+             * way to do this is to add the new elements on head, and
+             * to flag deleted elements in a special way for later
+             * deletion (putting references to the nodes to delete into
+             * another linked list). */
+            if (retval != AE_NOMORE) {
+                aeAddMillisecondsToNow(retval,&te->when_sec,&te->when_ms);
+            } else {
+                aeDeleteTimeEvent(eventLoop, id);
+            }
+            te = eventLoop->timeEventHead;
+        } else {
+            te = te->next;
+        }
+    }
+    return processed;
+}
+
+/* Process every pending time event, then every pending file event
+ * (that may be registered by time event callbacks just processed).
+ * Without special flags the function sleeps until some file event
+ * fires, or when the next time event occurrs (if any).
+ *
+ * If flags is 0, the function does nothing and returns.
+ * if flags has AE_ALL_EVENTS set, all the kind of events are processed.
+ * if flags has AE_FILE_EVENTS set, file events are processed.
+ * if flags has AE_TIME_EVENTS set, time events are processed.
+ * if flags has AE_DONT_WAIT set the function returns ASAP until all
+ * the events that's possible to process without to wait are processed.
+ *
+ * The function returns the number of events processed. */
+int aeProcessEvents(aeEventLoop *eventLoop, int flags)
+{
+    int processed = 0, numevents;
+
+    /* Nothing to do? return ASAP */
+    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;
+
+    /* Note that we want call select() even if there are no
+     * file events to process as long as we want to process time
+     * events, in order to sleep until the next time event is ready
+     * to fire. */
+    if (eventLoop->maxfd != -1 ||
+        ((flags & AE_TIME_EVENTS) && !(flags & AE_DONT_WAIT))) {
+        int j;
+        aeTimeEvent *shortest = NULL;
+        struct timeval tv, *tvp;
+
+        if (flags & AE_TIME_EVENTS && !(flags & AE_DONT_WAIT))
+            shortest = aeSearchNearestTimer(eventLoop);
+        if (shortest) {
+            long now_sec, now_ms;
+
+            /* Calculate the time missing for the nearest
+             * timer to fire. */
+            aeGetTime(&now_sec, &now_ms);
+            tvp = &tv;
+            tvp->tv_sec = shortest->when_sec - now_sec;
+            if (shortest->when_ms < now_ms) {
+                tvp->tv_usec = ((shortest->when_ms+1000) - now_ms)*1000;
+                tvp->tv_sec --;
+            } else {
+                tvp->tv_usec = (shortest->when_ms - now_ms)*1000;
+            }
+            if (tvp->tv_sec < 0) tvp->tv_sec = 0;
+            if (tvp->tv_usec < 0) tvp->tv_usec = 0;
+        } else {
+            /* If we have to check for events but need to return
+             * ASAP because of AE_DONT_WAIT we need to se the timeout
+             * to zero */
+            if (flags & AE_DONT_WAIT) {
+                tv.tv_sec = tv.tv_usec = 0;
+                tvp = &tv;
+            } else {
+                /* Otherwise we can block */
+                tvp = NULL; /* wait forever */
+            }
+        }
+
+        numevents = aeApiPoll(eventLoop, tvp);
+        for (j = 0; j < numevents; j++) {
+            aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];
+            int mask = eventLoop->fired[j].mask;
+            int fd = eventLoop->fired[j].fd;
+            int rfired = 0;
+
+	    /* note the fe->mask & mask & ... code: maybe an already processed
+             * event removed an element that fired and we still didn't
+             * processed, so we check if the event is still valid. */
+            if (fe->mask & mask & AE_READABLE) {
+                rfired = 1;
+                fe->rfileProc(eventLoop,fd,fe->clientData,mask);
+            }
+            if (fe->mask & mask & AE_WRITABLE) {
+                if (!rfired || fe->wfileProc != fe->rfileProc)
+                    fe->wfileProc(eventLoop,fd,fe->clientData,mask);
+            }
+            processed++;
+        }
+    }
+    /* Check time events */
+    if (flags & AE_TIME_EVENTS)
+        processed += processTimeEvents(eventLoop);
+
+    return processed; /* return the number of processed file/time events */
+}
+
+/* Wait for millseconds until the given file descriptor becomes
+ * writable/readable/exception */
+int aeWait(int fd, int mask, long long milliseconds) {
+    struct timeval tv;
+    fd_set rfds, wfds, efds;
+    int retmask = 0, retval;
+
+    tv.tv_sec = milliseconds/1000;
+    tv.tv_usec = (milliseconds%1000)*1000;
+    FD_ZERO(&rfds);
+    FD_ZERO(&wfds);
+    FD_ZERO(&efds);
+
+    if (mask & AE_READABLE) FD_SET(fd,&rfds);
+    if (mask & AE_WRITABLE) FD_SET(fd,&wfds);
+    if ((retval = select(fd+1, &rfds, &wfds, &efds, &tv)) > 0) {
+        if (FD_ISSET(fd,&rfds)) retmask |= AE_READABLE;
+        if (FD_ISSET(fd,&wfds)) retmask |= AE_WRITABLE;
+        return retmask;
+    } else {
+        return retval;
+    }
+}
+
+void aeMain(aeEventLoop *eventLoop) {
+    eventLoop->stop = 0;
+    while (!eventLoop->stop) {
+        if (eventLoop->beforesleep != NULL)
+            eventLoop->beforesleep(eventLoop);
+        aeProcessEvents(eventLoop, AE_ALL_EVENTS);
+    }
+}
+
+char *aeGetApiName(void) {
+    return aeApiName();
+}
+
+void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {
+    eventLoop->beforesleep = beforesleep;
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/ae_epoll.c xen-4.2.1-merge/stubdom/c_httpd_redis/ae_epoll.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/ae_epoll.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/ae_epoll.c	2016-08-04 16:32:18.000000000 +0800
@@ -0,0 +1,91 @@
+/* Linux epoll(2) based ae.c module
+ * Copyright (C) 2009-2010 Salvatore Sanfilippo - antirez@gmail.com
+ * Released under the BSD license. See the COPYING file for more info. */
+
+#include <sys/epoll.h>
+
+typedef struct aeApiState {
+    int epfd;
+    struct epoll_event events[AE_SETSIZE];
+} aeApiState;
+
+static int aeApiCreate(aeEventLoop *eventLoop) {
+    aeApiState *state = zmalloc(sizeof(aeApiState));
+
+    if (!state) return -1;
+    state->epfd = epoll_create(1024); /* 1024 is just an hint for the kernel */
+    if (state->epfd == -1) return -1;
+    eventLoop->apidata = state;
+    return 0;
+}
+
+static void aeApiFree(aeEventLoop *eventLoop) {
+    aeApiState *state = eventLoop->apidata;
+
+    close(state->epfd);
+    zfree(state);
+}
+
+static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    aeApiState *state = eventLoop->apidata;
+    struct epoll_event ee;
+    /* If the fd was already monitored for some event, we need a MOD
+     * operation. Otherwise we need an ADD operation. */
+    int op = eventLoop->events[fd].mask == AE_NONE ?
+            EPOLL_CTL_ADD : EPOLL_CTL_MOD;
+
+    ee.events = 0;
+    mask |= eventLoop->events[fd].mask; /* Merge old events */
+    if (mask & AE_READABLE) ee.events |= EPOLLIN;
+    if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
+    ee.data.u64 = 0; /* avoid valgrind warning */
+    ee.data.fd = fd;
+    if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
+    return 0;
+}
+
+static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
+    aeApiState *state = eventLoop->apidata;
+    struct epoll_event ee;
+    int mask = eventLoop->events[fd].mask & (~delmask);
+
+    ee.events = 0;
+    if (mask & AE_READABLE) ee.events |= EPOLLIN;
+    if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
+    ee.data.u64 = 0; /* avoid valgrind warning */
+    ee.data.fd = fd;
+    if (mask != AE_NONE) {
+        epoll_ctl(state->epfd,EPOLL_CTL_MOD,fd,&ee);
+    } else {
+        /* Note, Kernel < 2.6.9 requires a non null event pointer even for
+         * EPOLL_CTL_DEL. */
+        epoll_ctl(state->epfd,EPOLL_CTL_DEL,fd,&ee);
+    }
+}
+
+static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
+    aeApiState *state = eventLoop->apidata;
+    int retval, numevents = 0;
+
+    retval = epoll_wait(state->epfd,state->events,AE_SETSIZE,
+            tvp ? (tvp->tv_sec*1000 + tvp->tv_usec/1000) : -1);
+    if (retval > 0) {
+        int j;
+
+        numevents = retval;
+        for (j = 0; j < numevents; j++) {
+            int mask = 0;
+            struct epoll_event *e = state->events+j;
+
+            if (e->events & EPOLLIN) mask |= AE_READABLE;
+            if (e->events & EPOLLOUT) mask |= AE_WRITABLE;
+            eventLoop->fired[j].fd = e->data.fd;
+            eventLoop->fired[j].mask = mask;
+        }
+    }
+    return numevents;
+}
+
+static char *aeApiName(void) {
+    return "epoll";
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/ae.h xen-4.2.1-merge/stubdom/c_httpd_redis/ae.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/ae.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/ae.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,117 @@
+/* A simple event-driven programming library. Originally I wrote this code
+ * for the Jim's event-loop (Jim is a Tcl interpreter) but later translated
+ * it in form of a library for easy reuse.
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __AE_H__
+#define __AE_H__
+
+#define AE_SETSIZE (1024*10)    /* Max number of fd supported */
+
+#define AE_OK 0
+#define AE_ERR -1
+
+#define AE_NONE 0
+#define AE_READABLE 1
+#define AE_WRITABLE 2
+
+#define AE_FILE_EVENTS 1
+#define AE_TIME_EVENTS 2
+#define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)
+#define AE_DONT_WAIT 4
+
+#define AE_NOMORE -1
+
+/* Macros */
+#define AE_NOTUSED(V) ((void) V)
+
+struct aeEventLoop;
+
+/* Types and data structures */
+typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);
+typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);
+typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);
+typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);
+
+/* File event structure */
+typedef struct aeFileEvent {
+    int mask; /* one of AE_(READABLE|WRITABLE) */
+    aeFileProc *rfileProc;
+    aeFileProc *wfileProc;
+    void *clientData;
+} aeFileEvent;
+
+/* Time event structure */
+typedef struct aeTimeEvent {
+    long long id; /* time event identifier. */
+    long when_sec; /* seconds */
+    long when_ms; /* milliseconds */
+    aeTimeProc *timeProc;
+    aeEventFinalizerProc *finalizerProc;
+    void *clientData;
+    struct aeTimeEvent *next;
+} aeTimeEvent;
+
+/* A fired event */
+typedef struct aeFiredEvent {
+    int fd;
+    int mask;
+} aeFiredEvent;
+
+/* State of an event based program */
+typedef struct aeEventLoop {
+    int maxfd;
+    long long timeEventNextId;
+    aeFileEvent events[AE_SETSIZE]; /* Registered events */
+    aeFiredEvent fired[AE_SETSIZE]; /* Fired events */
+    aeTimeEvent *timeEventHead;
+    int stop;
+    void *apidata; /* This is used for polling API specific data */
+    aeBeforeSleepProc *beforesleep;
+} aeEventLoop;
+
+/* Prototypes */
+aeEventLoop *aeCreateEventLoop(void);
+void aeDeleteEventLoop(aeEventLoop *eventLoop);
+void aeStop(aeEventLoop *eventLoop);
+int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
+        aeFileProc *proc, void *clientData);
+void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);
+long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
+        aeTimeProc *proc, void *clientData,
+        aeEventFinalizerProc *finalizerProc);
+int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);
+int aeProcessEvents(aeEventLoop *eventLoop, int flags);
+int aeWait(int fd, int mask, long long milliseconds);
+void aeMain(aeEventLoop *eventLoop);
+char *aeGetApiName(void);
+void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/ae_kqueue.c xen-4.2.1-merge/stubdom/c_httpd_redis/ae_kqueue.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/ae_kqueue.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/ae_kqueue.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,93 @@
+/* Kqueue(2)-based ae.c module
+ * Copyright (C) 2009 Harish Mallipeddi - harish.mallipeddi@gmail.com
+ * Released under the BSD license. See the COPYING file for more info. */
+
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+
+typedef struct aeApiState {
+    int kqfd;
+    struct kevent events[AE_SETSIZE];
+} aeApiState;
+
+static int aeApiCreate(aeEventLoop *eventLoop) {
+    aeApiState *state = zmalloc(sizeof(aeApiState));
+
+    if (!state) return -1;
+    state->kqfd = kqueue();
+    if (state->kqfd == -1) return -1;
+    eventLoop->apidata = state;
+    
+    return 0;    
+}
+
+static void aeApiFree(aeEventLoop *eventLoop) {
+    aeApiState *state = eventLoop->apidata;
+
+    close(state->kqfd);
+    zfree(state);
+}
+
+static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    aeApiState *state = eventLoop->apidata;
+    struct kevent ke;
+    
+    if (mask & AE_READABLE) {
+        EV_SET(&ke, fd, EVFILT_READ, EV_ADD, 0, 0, NULL);
+        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
+    }
+    if (mask & AE_WRITABLE) {
+        EV_SET(&ke, fd, EVFILT_WRITE, EV_ADD, 0, 0, NULL);
+        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
+    }
+    return 0;
+}
+
+static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    aeApiState *state = eventLoop->apidata;
+    struct kevent ke;
+
+    if (mask & AE_READABLE) {
+        EV_SET(&ke, fd, EVFILT_READ, EV_DELETE, 0, 0, NULL);
+        kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
+    }
+    if (mask & AE_WRITABLE) {
+        EV_SET(&ke, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
+        kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
+    }
+}
+
+static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
+    aeApiState *state = eventLoop->apidata;
+    int retval, numevents = 0;
+
+    if (tvp != NULL) {
+        struct timespec timeout;
+        timeout.tv_sec = tvp->tv_sec;
+        timeout.tv_nsec = tvp->tv_usec * 1000;
+        retval = kevent(state->kqfd, NULL, 0, state->events, AE_SETSIZE, &timeout);
+    } else {
+        retval = kevent(state->kqfd, NULL, 0, state->events, AE_SETSIZE, NULL);
+    }    
+
+    if (retval > 0) {
+        int j;
+        
+        numevents = retval;
+        for(j = 0; j < numevents; j++) {
+            int mask = 0;
+            struct kevent *e = state->events+j;
+            
+            if (e->filter == EVFILT_READ) mask |= AE_READABLE;
+            if (e->filter == EVFILT_WRITE) mask |= AE_WRITABLE;
+            eventLoop->fired[j].fd = e->ident; 
+            eventLoop->fired[j].mask = mask;           
+        }
+    }
+    return numevents;
+}
+
+static char *aeApiName(void) {
+    return "kqueue";
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/ae_select.c xen-4.2.1-merge/stubdom/c_httpd_redis/ae_select.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/ae_select.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/ae_select.c	2016-08-04 15:04:58.000000000 +0800
@@ -0,0 +1,71 @@
+/* Select()-based ae.c module
+ * Copyright (C) 2009-2010 Salvatore Sanfilippo - antirez@gmail.com
+ * Released under the BSD license. See the COPYING file for more info. */
+
+#include <string.h>
+
+typedef struct aeApiState {
+    fd_set rfds, wfds;
+    /* We need to have a copy of the fd sets as it's not safe to reuse
+     * FD sets after select(). */
+    fd_set _rfds, _wfds;
+} aeApiState;
+
+static int aeApiCreate(aeEventLoop *eventLoop) {
+    aeApiState *state = zmalloc(sizeof(aeApiState));
+
+    if (!state) return -1;
+    FD_ZERO(&state->rfds);
+    FD_ZERO(&state->wfds);
+    eventLoop->apidata = state;
+    return 0;
+}
+
+static void aeApiFree(aeEventLoop *eventLoop) {
+    zfree(eventLoop->apidata);
+}
+
+static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    aeApiState *state = eventLoop->apidata;
+    if (mask & AE_READABLE) FD_SET(fd,&state->rfds);
+    if (mask & AE_WRITABLE) FD_SET(fd,&state->wfds);
+    return 0;
+}
+
+static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    aeApiState *state = eventLoop->apidata;
+
+    if (mask & AE_READABLE) FD_CLR(fd,&state->rfds);
+    if (mask & AE_WRITABLE) FD_CLR(fd,&state->wfds);
+}
+
+static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
+    aeApiState *state = eventLoop->apidata;
+    int retval, j, numevents = 0;
+
+    memcpy(&state->_rfds,&state->rfds,sizeof(fd_set));
+    memcpy(&state->_wfds,&state->wfds,sizeof(fd_set));
+
+    retval = select(eventLoop->maxfd+1,
+                &state->_rfds,&state->_wfds,NULL,tvp);
+    if (retval > 0) {
+        for (j = 0; j <= eventLoop->maxfd; j++) {
+            int mask = 0;
+            aeFileEvent *fe = &eventLoop->events[j];
+
+            if (fe->mask == AE_NONE) continue;
+            if (fe->mask & AE_READABLE && FD_ISSET(j,&state->_rfds))
+                mask |= AE_READABLE;
+            if (fe->mask & AE_WRITABLE && FD_ISSET(j,&state->_wfds))
+                mask |= AE_WRITABLE;
+            eventLoop->fired[numevents].fd = j;
+            eventLoop->fired[numevents].mask = mask;
+            numevents++;
+        }
+    }
+    return numevents;
+}
+
+static char *aeApiName(void) {
+    return "select";
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/anet.c xen-4.2.1-merge/stubdom/c_httpd_redis/anet.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/anet.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/anet.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,274 @@
+/* anet.c -- Basic TCP socket stuff made a bit less boring
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fmacros.h"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <netdb.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+
+#include "anet.h"
+
+static void anetSetError(char *err, const char *fmt, ...)
+{
+    va_list ap;
+
+    if (!err) return;
+    va_start(ap, fmt);
+    vsnprintf(err, ANET_ERR_LEN, fmt, ap);
+    va_end(ap);
+}
+
+int anetNonBlock(char *err, int fd)
+{
+    int flags;
+
+    /* Set the socket nonblocking.
+     * Note that fcntl(2) for F_GETFL and F_SETFL can't be
+     * interrupted by a signal. */
+    if ((flags = fcntl(fd, F_GETFL)) == -1) {
+        anetSetError(err, "fcntl(F_GETFL): %s\n", strerror(errno));
+        return ANET_ERR;
+    }
+    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
+        anetSetError(err, "fcntl(F_SETFL,O_NONBLOCK): %s\n", strerror(errno));
+        return ANET_ERR;
+    }
+    return ANET_OK;
+}
+
+int anetTcpNoDelay(char *err, int fd)
+{
+    int yes = 1;
+    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes)) == -1)
+    {
+        anetSetError(err, "setsockopt TCP_NODELAY: %s\n", strerror(errno));
+        return ANET_ERR;
+    }
+    return ANET_OK;
+}
+
+int anetSetSendBuffer(char *err, int fd, int buffsize)
+{
+    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buffsize, sizeof(buffsize)) == -1)
+    {
+        anetSetError(err, "setsockopt SO_SNDBUF: %s\n", strerror(errno));
+        return ANET_ERR;
+    }
+    return ANET_OK;
+}
+
+int anetTcpKeepAlive(char *err, int fd)
+{
+    int yes = 1;
+    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes)) == -1) {
+        anetSetError(err, "setsockopt SO_KEEPALIVE: %s\n", strerror(errno));
+        return ANET_ERR;
+    }
+    return ANET_OK;
+}
+
+int anetResolve(char *err, char *host, char *ipbuf)
+{
+    struct sockaddr_in sa;
+
+    sa.sin_family = AF_INET;
+    if (inet_aton(host, &sa.sin_addr) == 0) {
+        struct hostent *he;
+
+        he = gethostbyname(host);
+        if (he == NULL) {
+            anetSetError(err, "can't resolve: %s\n", host);
+            return ANET_ERR;
+        }
+        memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));
+    }
+    strcpy(ipbuf,inet_ntoa(sa.sin_addr));
+    return ANET_OK;
+}
+
+#define ANET_CONNECT_NONE 0
+#define ANET_CONNECT_NONBLOCK 1
+static int anetTcpGenericConnect(char *err, char *addr, int port, int flags)
+{
+    int s, on = 1;
+    struct sockaddr_in sa;
+
+    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
+        anetSetError(err, "creating socket: %s\n", strerror(errno));
+        return ANET_ERR;
+    }
+    /* Make sure connection-intensive things like the redis benckmark
+     * will be able to close/open sockets a zillion of times */
+    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
+
+    sa.sin_family = AF_INET;
+    sa.sin_port = htons(port);
+    if (inet_aton(addr, &sa.sin_addr) == 0) {
+        struct hostent *he;
+
+        he = gethostbyname(addr);
+        if (he == NULL) {
+            anetSetError(err, "can't resolve: %s\n", addr);
+            close(s);
+            return ANET_ERR;
+        }
+        memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));
+    }
+    if (flags & ANET_CONNECT_NONBLOCK) {
+        if (anetNonBlock(err,s) != ANET_OK)
+            return ANET_ERR;
+    }
+    if (connect(s, (struct sockaddr*)&sa, sizeof(sa)) == -1) {
+        if (errno == EINPROGRESS &&
+            flags & ANET_CONNECT_NONBLOCK)
+            return s;
+
+        anetSetError(err, "connect: %s\n", strerror(errno));
+        close(s);
+        return ANET_ERR;
+    }
+    return s;
+}
+
+int anetTcpConnect(char *err, char *addr, int port)
+{
+    return anetTcpGenericConnect(err,addr,port,ANET_CONNECT_NONE);
+}
+
+int anetTcpNonBlockConnect(char *err, char *addr, int port)
+{
+    return anetTcpGenericConnect(err,addr,port,ANET_CONNECT_NONBLOCK);
+}
+
+/* Like read(2) but make sure 'count' is read before to return
+ * (unless error or EOF condition is encountered) */
+int anetRead(int fd, char *buf, int count)
+{
+    int nread, totlen = 0;
+    while(totlen != count) {
+        nread = read(fd,buf,count-totlen);
+        if (nread == 0) return totlen;
+        if (nread == -1) return -1;
+        totlen += nread;
+        buf += nread;
+    }
+    return totlen;
+}
+
+/* Like write(2) but make sure 'count' is read before to return
+ * (unless error is encountered) */
+int anetWrite(int fd, char *buf, int count)
+{
+    int nwritten, totlen = 0;
+    while(totlen != count) {
+        nwritten = write(fd,buf,count-totlen);
+        if (nwritten == 0) return totlen;
+        if (nwritten == -1) return -1;
+        totlen += nwritten;
+        buf += nwritten;
+    }
+    return totlen;
+}
+
+
+int anetTcpServer(char *err, int port, char *bindaddr)
+{
+    int s, on = 1;
+    struct sockaddr_in sa;
+    
+    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
+        anetSetError(err, "socket: %s\n", strerror(errno));
+        return ANET_ERR;
+    }
+    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
+        //anetSetError(err, "setsockopt SO_REUSEADDR: %s\n", strerror(errno));
+        //close(s);
+        //return ANET_ERR;
+    }
+    memset(&sa,0,sizeof(sa));
+    sa.sin_family = AF_INET;
+    sa.sin_port = htons(port);
+    sa.sin_addr.s_addr = htonl(INADDR_ANY);
+    if (bindaddr) {
+        if (inet_aton(bindaddr, &sa.sin_addr) == 0) {
+            anetSetError(err, "Invalid bind address\n");
+            close(s);
+            return ANET_ERR;
+        }
+    }
+    if (bind(s, (struct sockaddr*)&sa, sizeof(sa)) == -1) {
+        anetSetError(err, "bind: %s\n", strerror(errno));
+        close(s);
+        return ANET_ERR;
+    }
+	printf("before listen\n");
+    if (listen(s, 511) == -1) { /* the magic 511 constant is from nginx */
+        anetSetError(err, "listen: %s\n", strerror(errno));
+        close(s);
+        return ANET_ERR;
+    }
+	printf("back listen %d\n", s);
+    return s;
+}
+
+int anetAccept(char *err, int serversock, char *ip, int *port)
+{
+    int fd;
+    struct sockaddr_in sa;
+    unsigned int saLen;
+
+    while(1) {
+        saLen = sizeof(sa);
+        fd = accept(serversock, (struct sockaddr*)&sa, &saLen);
+	printf("fd -------------> %d\n", fd);
+        if (fd == -1) {
+            if (errno == EINTR)
+                continue;
+            else {
+                anetSetError(err, "accept: %s\n", strerror(errno));
+                return ANET_ERR;
+            }
+        }
+        break;
+    }
+    if (ip) strcpy(ip,inet_ntoa(sa.sin_addr));
+    if (port) *port = ntohs(sa.sin_port);
+    return fd;
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/anet.h xen-4.2.1-merge/stubdom/c_httpd_redis/anet.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/anet.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/anet.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,49 @@
+/* anet.c -- Basic TCP socket stuff made a bit less boring
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANET_H
+#define ANET_H
+
+#define ANET_OK 0
+#define ANET_ERR -1
+#define ANET_ERR_LEN 256
+
+int anetTcpConnect(char *err, char *addr, int port);
+int anetTcpNonBlockConnect(char *err, char *addr, int port);
+int anetRead(int fd, char *buf, int count);
+int anetResolve(char *err, char *host, char *ipbuf);
+int anetTcpServer(char *err, int port, char *bindaddr);
+int anetAccept(char *err, int serversock, char *ip, int *port);
+int anetWrite(int fd, char *buf, int count);
+int anetNonBlock(char *err, int fd);
+int anetTcpNoDelay(char *err, int fd);
+int anetTcpKeepAlive(char *err, int fd);
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/client.c xen-4.2.1-merge/stubdom/c_httpd_redis/client.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/client.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/client.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,97 @@
+#include <stdlib.h>
+#include <sys/types.h>
+#include <stdio.h>
+#include <sys/socket.h>
+//#include <linux/in.h>
+#include <string.h>
+
+int fs_open(char *ip, unsigned short port)
+{
+    int fd; 
+    int recbytes;
+    int sin_size;
+    struct sockaddr_in s_add, c_add; 
+
+    printf("Open file!\r\n");
+    fd = socket(AF_INET, SOCK_STREAM, 0);
+    if(fd == -1)
+    {
+        printf("open fail! \r\n");
+        return -1;
+    }
+
+    bzero(&s_add, sizeof(struct sockaddr_in)); // 清空结构体
+    s_add.sin_family = AF_INET; // 采用IPv4网络协议
+    s_add.sin_addr.s_addr= inet_addr(ip); 
+    s_add.sin_port = htons(port); 
+
+    if(-1 == connect(fd, (struct sockaddr *)(&s_add), sizeof(struct sockaddr)))
+    {
+        printf("open fail!\r\n");
+        return -1;
+    }
+
+    printf("open ok!\r\n");                    
+    return fd;
+}
+
+void fs_read(int fd, char *fname)
+{
+    char buffer[1024] = "get ";
+    char rcv[1024] = {0};
+    strcat(buffer, fname);
+    strcat(buffer, " \r\n");
+    printf("read : %s", buffer);
+    send(fd, buffer, sizeof(buffer), 0);
+
+    if (read(fd, rcv, 1024) == -1) 
+    {
+        printf("read error!\n");
+        return;
+    }
+    printf("read OK!\n");
+    printf("RCV : %s\n", rcv);
+    return;
+
+}
+
+void fs_write(int fd, char *fname, char *buf)
+{
+    char buffer[1024] = "set ";
+    char rcv[1024] = {0};
+    strcat(buffer, fname);
+    strcat(buffer, " \"");
+    strcat(buffer, buf);
+    strcat(buffer, "\"\n");
+    printf("write : %s", buffer);
+    send(fd, buffer, sizeof(buffer), 0);
+    if (read(fd, rcv, 1024) == -1) 
+    {
+        printf("write error!\n");
+        return;
+    }
+    printf("write OK!\n");
+    printf("RCV : %s\n", rcv);
+}
+
+void fs_close(int fd)
+{
+    close(fd);
+    printf("file close OK!\n");
+}
+
+
+int main()
+{
+    int fd = fs_open("127.0.0.1", 6379);
+    char filename[20] = "index.html";
+    char buf[1024] = "<html><head><title>my home</title></head><body>hello mini-os!</body></html>";    
+    fs_write(fd, filename, buf);
+    fs_close(fd);
+    
+    fd = fs_open("192.168.182.12", 6379);
+    fs_read(fd, filename);
+    fs_close(fd);
+    return 0;
+}
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/config.h xen-4.2.1-merge/stubdom/c_httpd_redis/config.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/config.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/config.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,45 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+#endif
+
+/* test for malloc_size() */
+#ifdef __APPLE__
+#include <malloc/malloc.h>
+#define HAVE_MALLOC_SIZE 1
+#define redis_malloc_size(p) malloc_size(p)
+#endif
+
+/* define redis_fstat to fstat or fstat64() */
+#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)
+#define redis_fstat fstat64
+#define redis_stat stat64
+#else
+#define redis_fstat fstat
+#define redis_stat stat
+#endif
+
+/* test for backtrace() */
+#if defined(__APPLE__) || defined(__linux__)
+#define HAVE_BACKTRACE 1
+#endif
+
+/* test for polling API */
+#ifdef __linux__
+#define HAVE_EPOLL 1
+#endif
+
+#if (defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)
+#define HAVE_KQUEUE 1
+#endif
+
+/* define aof_fsync to fdatasync() in Linux and fsync() for all the rest */
+#ifdef __linux__
+#define aof_fsync fdatasync
+#else
+#define aof_fsync fsync
+#endif
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/dict.c xen-4.2.1-merge/stubdom/c_httpd_redis/dict.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/dict.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/dict.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,741 @@
+/* Hash Tables Implementation.
+ *
+ * This file implements in memory hash tables with insert/del/replace/find/
+ * get-random-element operations. Hash tables will auto resize if needed
+ * tables of power of two in size are used, collisions are handled by
+ * chaining. See the source code for more information... :)
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fmacros.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <limits.h>
+#include <sys/time.h>
+
+#include "dict.h"
+#include "zmalloc.h"
+
+/* Using dictEnableResize() / dictDisableResize() we make possible to
+ * enable/disable resizing of the hash table as needed. This is very important
+ * for Redis, as we use copy-on-write and don't want to move too much memory
+ * around when there is a child performing saving operations.
+ *
+ * Note that even when dict_can_resize is set to 0, not all resizes are
+ * prevented: an hash table is still allowed to grow if the ratio between
+ * the number of elements and the buckets > dict_force_resize_ratio. */
+static int dict_can_resize = 1;
+static unsigned int dict_force_resize_ratio = 5;
+
+/* ---------------------------- Utility funcitons --------------------------- */
+
+static void _dictPanic(const char *fmt, ...)
+{
+    va_list ap;
+
+    va_start(ap, fmt);
+    fprintf(stderr, "\nDICT LIBRARY PANIC: ");
+    vfprintf(stderr, fmt, ap);
+    fprintf(stderr, "\n\n");
+    va_end(ap);
+}
+
+/* ------------------------- Heap Management Wrappers------------------------ */
+
+static void *_dictAlloc(size_t size)
+{
+    void *p = zmalloc(size);
+    if (p == NULL)
+        _dictPanic("Out of memory");
+    return p;
+}
+
+static void _dictFree(void *ptr) {
+    zfree(ptr);
+}
+
+/* -------------------------- private prototypes ---------------------------- */
+
+static int _dictExpandIfNeeded(dict *ht);
+static unsigned long _dictNextPower(unsigned long size);
+static int _dictKeyIndex(dict *ht, const void *key);
+static int _dictInit(dict *ht, dictType *type, void *privDataPtr);
+
+/* -------------------------- hash functions -------------------------------- */
+
+/* Thomas Wang's 32 bit Mix Function */
+unsigned int dictIntHashFunction(unsigned int key)
+{
+    key += ~(key << 15);
+    key ^=  (key >> 10);
+    key +=  (key << 3);
+    key ^=  (key >> 6);
+    key += ~(key << 11);
+    key ^=  (key >> 16);
+    return key;
+}
+
+/* Identity hash function for integer keys */
+unsigned int dictIdentityHashFunction(unsigned int key)
+{
+    return key;
+}
+
+/* Generic hash function (a popular one from Bernstein).
+ * I tested a few and this was the best. */
+unsigned int dictGenHashFunction(const unsigned char *buf, int len) {
+    unsigned int hash = 5381;
+
+    while (len--)
+        hash = ((hash << 5) + hash) + (*buf++); /* hash * 33 + c */
+    return hash;
+}
+
+/* ----------------------------- API implementation ------------------------- */
+
+/* Reset an hashtable already initialized with ht_init().
+ * NOTE: This function should only called by ht_destroy(). */
+static void _dictReset(dictht *ht)
+{
+    ht->table = NULL;
+    ht->size = 0;
+    ht->sizemask = 0;
+    ht->used = 0;
+}
+
+/* Create a new hash table */
+dict *dictCreate(dictType *type,
+        void *privDataPtr)
+{
+    dict *d = _dictAlloc(sizeof(*d));
+
+    _dictInit(d,type,privDataPtr);
+    return d;
+}
+
+/* Initialize the hash table */
+int _dictInit(dict *d, dictType *type,
+        void *privDataPtr)
+{
+    _dictReset(&d->ht[0]);
+    _dictReset(&d->ht[1]);
+    d->type = type;
+    d->privdata = privDataPtr;
+    d->rehashidx = -1;
+    d->iterators = 0;
+    return DICT_OK;
+}
+
+/* Resize the table to the minimal size that contains all the elements,
+ * but with the invariant of a USER/BUCKETS ration near to <= 1 */
+int dictResize(dict *d)
+{
+    int minimal;
+
+    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;
+    minimal = d->ht[0].used;
+    if (minimal < DICT_HT_INITIAL_SIZE)
+        minimal = DICT_HT_INITIAL_SIZE;
+    return dictExpand(d, minimal);
+}
+
+/* Expand or create the hashtable */
+int dictExpand(dict *d, unsigned long size)
+{
+    dictht n; /* the new hashtable */
+    unsigned long realsize = _dictNextPower(size);
+
+    /* the size is invalid if it is smaller than the number of
+     * elements already inside the hashtable */
+    if (dictIsRehashing(d) || d->ht[0].used > size)
+        return DICT_ERR;
+
+    n.size = realsize;
+    n.sizemask = realsize-1;
+    n.table = _dictAlloc(realsize*sizeof(dictEntry*));
+    n.used = 0;
+
+    /* Initialize all the pointers to NULL */
+    memset(n.table, 0, realsize*sizeof(dictEntry*));
+
+    /* Is this the first initialization? If so it's not really a rehashing
+     * we just set the first hash table so that it can accept keys. */
+    if (d->ht[0].table == NULL) {
+        d->ht[0] = n;
+        return DICT_OK;
+    }
+
+    /* Prepare a second hash table for incremental rehashing */
+    d->ht[1] = n;
+    d->rehashidx = 0;
+    return DICT_OK;
+}
+
+/* Performs N steps of incremental rehashing. Returns 1 if there are still
+ * keys to move from the old to the new hash table, otherwise 0 is returned.
+ * Note that a rehashing step consists in moving a bucket (that may have more
+ * thank one key as we use chaining) from the old to the new hash table. */
+int dictRehash(dict *d, int n) {
+    if (!dictIsRehashing(d)) return 0;
+
+    while(n--) {
+        dictEntry *de, *nextde;
+
+        /* Check if we already rehashed the whole table... */
+        if (d->ht[0].used == 0) {
+            _dictFree(d->ht[0].table);
+            d->ht[0] = d->ht[1];
+            _dictReset(&d->ht[1]);
+            d->rehashidx = -1;
+            return 0;
+        }
+
+        /* Note that rehashidx can't overflow as we are sure there are more
+         * elements because ht[0].used != 0 */
+        while(d->ht[0].table[d->rehashidx] == NULL) d->rehashidx++;
+        de = d->ht[0].table[d->rehashidx];
+        /* Move all the keys in this bucket from the old to the new hash HT */
+        while(de) {
+            unsigned int h;
+
+            nextde = de->next;
+            /* Get the index in the new hash table */
+            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
+            de->next = d->ht[1].table[h];
+            d->ht[1].table[h] = de;
+            d->ht[0].used--;
+            d->ht[1].used++;
+            de = nextde;
+        }
+        d->ht[0].table[d->rehashidx] = NULL;
+        d->rehashidx++;
+    }
+    return 1;
+}
+
+long long timeInMilliseconds(void) {
+    struct timeval tv;
+
+    gettimeofday(&tv,NULL);
+    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
+}
+
+/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */
+int dictRehashMilliseconds(dict *d, int ms) {
+    long long start = timeInMilliseconds();
+    int rehashes = 0;
+
+    while(dictRehash(d,100)) {
+        rehashes += 100;
+        if (timeInMilliseconds()-start > ms) break;
+    }
+    return rehashes;
+}
+
+/* This function performs just a step of rehashing, and only if there are
+ * not iterators bound to our hash table. When we have iterators in the middle
+ * of a rehashing we can't mess with the two hash tables otherwise some element
+ * can be missed or duplicated.
+ *
+ * This function is called by common lookup or update operations in the
+ * dictionary so that the hash table automatically migrates from H1 to H2
+ * while it is actively used. */
+static void _dictRehashStep(dict *d) {
+    if (d->iterators == 0) dictRehash(d,1);
+}
+
+/* Add an element to the target hash table */
+int dictAdd(dict *d, void *key, void *val)
+{
+    int index;
+    dictEntry *entry;
+    dictht *ht;
+
+    if (dictIsRehashing(d)) _dictRehashStep(d);
+
+    /* Get the index of the new element, or -1 if
+     * the element already exists. */
+    if ((index = _dictKeyIndex(d, key)) == -1)
+        return DICT_ERR;
+
+    /* Allocates the memory and stores key */
+    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
+    entry = _dictAlloc(sizeof(*entry));
+    entry->next = ht->table[index];
+    ht->table[index] = entry;
+    ht->used++;
+
+    /* Set the hash entry fields. */
+    dictSetHashKey(d, entry, key);
+    dictSetHashVal(d, entry, val);
+    return DICT_OK;
+}
+
+/* Add an element, discarding the old if the key already exists.
+ * Return 1 if the key was added from scratch, 0 if there was already an
+ * element with such key and dictReplace() just performed a value update
+ * operation. */
+int dictReplace(dict *d, void *key, void *val)
+{
+    dictEntry *entry, auxentry;
+
+    /* Try to add the element. If the key
+     * does not exists dictAdd will suceed. */
+    if (dictAdd(d, key, val) == DICT_OK)
+        return 1;
+    /* It already exists, get the entry */
+    entry = dictFind(d, key);
+    /* Free the old value and set the new one */
+    /* Set the new value and free the old one. Note that it is important
+     * to do that in this order, as the value may just be exactly the same
+     * as the previous one. In this context, think to reference counting,
+     * you want to increment (set), and then decrement (free), and not the
+     * reverse. */
+    auxentry = *entry;
+    dictSetHashVal(d, entry, val);
+    dictFreeEntryVal(d, &auxentry);
+    return 0;
+}
+
+/* Search and remove an element */
+static int dictGenericDelete(dict *d, const void *key, int nofree)
+{
+    unsigned int h, idx;
+    dictEntry *he, *prevHe;
+    int table;
+
+    if (d->ht[0].size == 0) return DICT_ERR; /* d->ht[0].table is NULL */
+    if (dictIsRehashing(d)) _dictRehashStep(d);
+    h = dictHashKey(d, key);
+
+    for (table = 0; table <= 1; table++) {
+        idx = h & d->ht[table].sizemask;
+        he = d->ht[table].table[idx];
+        prevHe = NULL;
+        while(he) {
+            if (dictCompareHashKeys(d, key, he->key)) {
+                /* Unlink the element from the list */
+                if (prevHe)
+                    prevHe->next = he->next;
+                else
+                    d->ht[table].table[idx] = he->next;
+                if (!nofree) {
+                    dictFreeEntryKey(d, he);
+                    dictFreeEntryVal(d, he);
+                }
+                _dictFree(he);
+                d->ht[table].used--;
+                return DICT_OK;
+            }
+            prevHe = he;
+            he = he->next;
+        }
+        if (!dictIsRehashing(d)) break;
+    }
+    return DICT_ERR; /* not found */
+}
+
+int dictDelete(dict *ht, const void *key) {
+    return dictGenericDelete(ht,key,0);
+}
+
+int dictDeleteNoFree(dict *ht, const void *key) {
+    return dictGenericDelete(ht,key,1);
+}
+
+/* Destroy an entire dictionary */
+int _dictClear(dict *d, dictht *ht)
+{
+    unsigned long i;
+
+    /* Free all the elements */
+    for (i = 0; i < ht->size && ht->used > 0; i++) {
+        dictEntry *he, *nextHe;
+
+        if ((he = ht->table[i]) == NULL) continue;
+        while(he) {
+            nextHe = he->next;
+            dictFreeEntryKey(d, he);
+            dictFreeEntryVal(d, he);
+            _dictFree(he);
+            ht->used--;
+            he = nextHe;
+        }
+    }
+    /* Free the table and the allocated cache structure */
+    _dictFree(ht->table);
+    /* Re-initialize the table */
+    _dictReset(ht);
+    return DICT_OK; /* never fails */
+}
+
+/* Clear & Release the hash table */
+void dictRelease(dict *d)
+{
+    _dictClear(d,&d->ht[0]);
+    _dictClear(d,&d->ht[1]);
+    _dictFree(d);
+}
+
+dictEntry *dictFind(dict *d, const void *key)
+{
+    dictEntry *he;
+    unsigned int h, idx, table;
+
+    if (d->ht[0].size == 0) return NULL; /* We don't have a table at all */
+    if (dictIsRehashing(d)) _dictRehashStep(d);
+    h = dictHashKey(d, key);
+    for (table = 0; table <= 1; table++) {
+        idx = h & d->ht[table].sizemask;
+        he = d->ht[table].table[idx];
+        while(he) {
+            if (dictCompareHashKeys(d, key, he->key))
+                return he;
+            he = he->next;
+        }
+        if (!dictIsRehashing(d)) return NULL;
+    }
+    return NULL;
+}
+
+void *dictFetchValue(dict *d, const void *key) {
+    dictEntry *he;
+
+    he = dictFind(d,key);
+    return he ? dictGetEntryVal(he) : NULL;
+}
+
+dictIterator *dictGetIterator(dict *d)
+{
+    dictIterator *iter = _dictAlloc(sizeof(*iter));
+
+    iter->d = d;
+    iter->table = 0;
+    iter->index = -1;
+    iter->entry = NULL;
+    iter->nextEntry = NULL;
+    return iter;
+}
+
+dictEntry *dictNext(dictIterator *iter)
+{
+    while (1) {
+        if (iter->entry == NULL) {
+            dictht *ht = &iter->d->ht[iter->table];
+            if (iter->index == -1 && iter->table == 0) iter->d->iterators++;
+            iter->index++;
+            if (iter->index >= (signed) ht->size) {
+                if (dictIsRehashing(iter->d) && iter->table == 0) {
+                    iter->table++;
+                    iter->index = 0;
+                    ht = &iter->d->ht[1];
+                } else {
+                    break;
+                }
+            }
+            iter->entry = ht->table[iter->index];
+        } else {
+            iter->entry = iter->nextEntry;
+        }
+        if (iter->entry) {
+            /* We need to save the 'next' here, the iterator user
+             * may delete the entry we are returning. */
+            iter->nextEntry = iter->entry->next;
+            return iter->entry;
+        }
+    }
+    return NULL;
+}
+
+void dictReleaseIterator(dictIterator *iter)
+{
+    if (!(iter->index == -1 && iter->table == 0)) iter->d->iterators--;
+    _dictFree(iter);
+}
+
+/* Return a random entry from the hash table. Useful to
+ * implement randomized algorithms */
+dictEntry *dictGetRandomKey(dict *d)
+{
+    dictEntry *he, *orighe;
+    unsigned int h;
+    int listlen, listele;
+
+    if (dictSize(d) == 0) return NULL;
+    if (dictIsRehashing(d)) _dictRehashStep(d);
+    if (dictIsRehashing(d)) {
+        do {
+            h = rand() % (d->ht[0].size+d->ht[1].size);
+            he = (h >= d->ht[0].size) ? d->ht[1].table[h - d->ht[0].size] :
+                                      d->ht[0].table[h];
+        } while(he == NULL);
+    } else {
+        do {
+            h = rand() & d->ht[0].sizemask;
+            he = d->ht[0].table[h];
+        } while(he == NULL);
+    }
+
+    /* Now we found a non empty bucket, but it is a linked
+     * list and we need to get a random element from the list.
+     * The only sane way to do so is counting the elements and
+     * select a random index. */
+    listlen = 0;
+    orighe = he;
+    while(he) {
+        he = he->next;
+        listlen++;
+    }
+    listele = rand() % listlen;
+    he = orighe;
+    while(listele--) he = he->next;
+    return he;
+}
+
+/* ------------------------- private functions ------------------------------ */
+
+/* Expand the hash table if needed */
+static int _dictExpandIfNeeded(dict *d)
+{
+    /* Incremental rehashing already in progress. Return. */
+    if (dictIsRehashing(d)) return DICT_OK;
+
+    /* If the hash table is empty expand it to the intial size. */
+    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);
+
+    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
+     * table (global setting) or we should avoid it but the ratio between
+     * elements/buckets is over the "safe" threshold, we resize doubling
+     * the number of buckets. */
+    if (d->ht[0].used >= d->ht[0].size &&
+        (dict_can_resize ||
+         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))
+    {
+        return dictExpand(d, ((d->ht[0].size > d->ht[0].used) ?
+                                    d->ht[0].size : d->ht[0].used)*2);
+    }
+    return DICT_OK;
+}
+
+/* Our hash table capability is a power of two */
+static unsigned long _dictNextPower(unsigned long size)
+{
+    unsigned long i = DICT_HT_INITIAL_SIZE;
+
+    if (size >= LONG_MAX) return LONG_MAX;
+    while(1) {
+        if (i >= size)
+            return i;
+        i *= 2;
+    }
+}
+
+/* Returns the index of a free slot that can be populated with
+ * an hash entry for the given 'key'.
+ * If the key already exists, -1 is returned.
+ *
+ * Note that if we are in the process of rehashing the hash table, the
+ * index is always returned in the context of the second (new) hash table. */
+static int _dictKeyIndex(dict *d, const void *key)
+{
+    unsigned int h, idx, table;
+    dictEntry *he;
+
+    /* Expand the hashtable if needed */
+    if (_dictExpandIfNeeded(d) == DICT_ERR)
+        return -1;
+    /* Compute the key hash value */
+    h = dictHashKey(d, key);
+    for (table = 0; table <= 1; table++) {
+        idx = h & d->ht[table].sizemask;
+        /* Search if this slot does not already contain the given key */
+        he = d->ht[table].table[idx];
+        while(he) {
+            if (dictCompareHashKeys(d, key, he->key))
+                return -1;
+            he = he->next;
+        }
+        if (!dictIsRehashing(d)) break;
+    }
+    return idx;
+}
+
+void dictEmpty(dict *d) {
+    _dictClear(d,&d->ht[0]);
+    _dictClear(d,&d->ht[1]);
+    d->rehashidx = -1;
+    d->iterators = 0;
+}
+
+#define DICT_STATS_VECTLEN 50
+static void _dictPrintStatsHt(dictht *ht) {
+    unsigned long i, slots = 0, chainlen, maxchainlen = 0;
+    unsigned long totchainlen = 0;
+    unsigned long clvector[DICT_STATS_VECTLEN];
+
+    if (ht->used == 0) {
+        printf("No stats available for empty dictionaries\n");
+        return;
+    }
+
+    for (i = 0; i < DICT_STATS_VECTLEN; i++) clvector[i] = 0;
+    for (i = 0; i < ht->size; i++) {
+        dictEntry *he;
+
+        if (ht->table[i] == NULL) {
+            clvector[0]++;
+            continue;
+        }
+        slots++;
+        /* For each hash entry on this slot... */
+        chainlen = 0;
+        he = ht->table[i];
+        while(he) {
+            chainlen++;
+            he = he->next;
+        }
+        clvector[(chainlen < DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN-1)]++;
+        if (chainlen > maxchainlen) maxchainlen = chainlen;
+        totchainlen += chainlen;
+    }
+    printf("Hash table stats:\n");
+    printf(" table size: %ld\n", ht->size);
+    printf(" number of elements: %ld\n", ht->used);
+    printf(" different slots: %ld\n", slots);
+    printf(" max chain length: %ld\n", maxchainlen);
+    printf(" avg chain length (counted): %.02f\n", (float)totchainlen/slots);
+    printf(" avg chain length (computed): %.02f\n", (float)ht->used/slots);
+    printf(" Chain length distribution:\n");
+    for (i = 0; i < DICT_STATS_VECTLEN-1; i++) {
+        if (clvector[i] == 0) continue;
+        printf("   %s%ld: %ld (%.02f%%)\n",(i == DICT_STATS_VECTLEN-1)?">= ":"", i, clvector[i], ((float)clvector[i]/ht->size)*100);
+    }
+}
+
+void dictPrintStats(dict *d) {
+    _dictPrintStatsHt(&d->ht[0]);
+    if (dictIsRehashing(d)) {
+        printf("-- Rehashing into ht[1]:\n");
+        _dictPrintStatsHt(&d->ht[1]);
+    }
+}
+
+void dictEnableResize(void) {
+    dict_can_resize = 1;
+}
+
+void dictDisableResize(void) {
+    dict_can_resize = 0;
+}
+
+/* ----------------------- StringCopy Hash Table Type ------------------------*/
+
+static unsigned int _dictStringCopyHTHashFunction(const void *key)
+{
+    return dictGenHashFunction(key, strlen(key));
+}
+
+static void *_dictStringCopyHTKeyDup(void *privdata, const void *key)
+{
+    int len = strlen(key);
+    char *copy = _dictAlloc(len+1);
+    DICT_NOTUSED(privdata);
+
+    memcpy(copy, key, len);
+    copy[len] = '\0';
+    return copy;
+}
+
+static void *_dictStringKeyValCopyHTValDup(void *privdata, const void *val)
+{
+    int len = strlen(val);
+    char *copy = _dictAlloc(len+1);
+    DICT_NOTUSED(privdata);
+
+    memcpy(copy, val, len);
+    copy[len] = '\0';
+    return copy;
+}
+
+static int _dictStringCopyHTKeyCompare(void *privdata, const void *key1,
+        const void *key2)
+{
+    DICT_NOTUSED(privdata);
+
+    return strcmp(key1, key2) == 0;
+}
+
+static void _dictStringCopyHTKeyDestructor(void *privdata, void *key)
+{
+    DICT_NOTUSED(privdata);
+
+    _dictFree((void*)key); /* ATTENTION: const cast */
+}
+
+static void _dictStringKeyValCopyHTValDestructor(void *privdata, void *val)
+{
+    DICT_NOTUSED(privdata);
+
+    _dictFree((void*)val); /* ATTENTION: const cast */
+}
+
+dictType dictTypeHeapStringCopyKey = {
+    _dictStringCopyHTHashFunction,        /* hash function */
+    _dictStringCopyHTKeyDup,              /* key dup */
+    NULL,                               /* val dup */
+    _dictStringCopyHTKeyCompare,          /* key compare */
+    _dictStringCopyHTKeyDestructor,       /* key destructor */
+    NULL                                /* val destructor */
+};
+
+/* This is like StringCopy but does not auto-duplicate the key.
+ * It's used for intepreter's shared strings. */
+dictType dictTypeHeapStrings = {
+    _dictStringCopyHTHashFunction,        /* hash function */
+    NULL,                               /* key dup */
+    NULL,                               /* val dup */
+    _dictStringCopyHTKeyCompare,          /* key compare */
+    _dictStringCopyHTKeyDestructor,       /* key destructor */
+    NULL                                /* val destructor */
+};
+
+/* This is like StringCopy but also automatically handle dynamic
+ * allocated C strings as values. */
+dictType dictTypeHeapStringCopyKeyValue = {
+    _dictStringCopyHTHashFunction,        /* hash function */
+    _dictStringCopyHTKeyDup,              /* key dup */
+    _dictStringKeyValCopyHTValDup,        /* val dup */
+    _dictStringCopyHTKeyCompare,          /* key compare */
+    _dictStringCopyHTKeyDestructor,       /* key destructor */
+    _dictStringKeyValCopyHTValDestructor, /* val destructor */
+};
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/dict.h xen-4.2.1-merge/stubdom/c_httpd_redis/dict.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/dict.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/dict.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,151 @@
+/* Hash Tables Implementation.
+ *
+ * This file implements in memory hash tables with insert/del/replace/find/
+ * get-random-element operations. Hash tables will auto resize if needed
+ * tables of power of two in size are used, collisions are handled by
+ * chaining. See the source code for more information... :)
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DICT_H
+#define __DICT_H
+
+#define DICT_OK 0
+#define DICT_ERR 1
+
+/* Unused arguments generate annoying warnings... */
+#define DICT_NOTUSED(V) ((void) V)
+
+typedef struct dictEntry {
+    void *key;
+    void *val;
+    struct dictEntry *next;
+} dictEntry;
+
+typedef struct dictType {
+    unsigned int (*hashFunction)(const void *key);
+    void *(*keyDup)(void *privdata, const void *key);
+    void *(*valDup)(void *privdata, const void *obj);
+    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
+    void (*keyDestructor)(void *privdata, void *key);
+    void (*valDestructor)(void *privdata, void *obj);
+} dictType;
+
+/* This is our hash table structure. Every dictionary has two of this as we
+ * implement incremental rehashing, for the old to the new table. */
+typedef struct dictht {
+    dictEntry **table;
+    unsigned long size;
+    unsigned long sizemask;
+    unsigned long used;
+} dictht;
+
+typedef struct dict {
+    dictType *type;
+    void *privdata;
+    dictht ht[2];
+    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
+    int iterators; /* number of iterators currently running */
+} dict;
+
+typedef struct dictIterator {
+    dict *d;
+    int table;
+    int index;
+    dictEntry *entry, *nextEntry;
+} dictIterator;
+
+/* This is the initial size of every hash table */
+#define DICT_HT_INITIAL_SIZE     4
+
+/* ------------------------------- Macros ------------------------------------*/
+#define dictFreeEntryVal(d, entry) \
+    if ((d)->type->valDestructor) \
+        (d)->type->valDestructor((d)->privdata, (entry)->val)
+
+#define dictSetHashVal(d, entry, _val_) do { \
+    if ((d)->type->valDup) \
+        entry->val = (d)->type->valDup((d)->privdata, _val_); \
+    else \
+        entry->val = (_val_); \
+} while(0)
+
+#define dictFreeEntryKey(d, entry) \
+    if ((d)->type->keyDestructor) \
+        (d)->type->keyDestructor((d)->privdata, (entry)->key)
+
+#define dictSetHashKey(d, entry, _key_) do { \
+    if ((d)->type->keyDup) \
+        entry->key = (d)->type->keyDup((d)->privdata, _key_); \
+    else \
+        entry->key = (_key_); \
+} while(0)
+
+#define dictCompareHashKeys(d, key1, key2) \
+    (((d)->type->keyCompare) ? \
+        (d)->type->keyCompare((d)->privdata, key1, key2) : \
+        (key1) == (key2))
+
+#define dictHashKey(d, key) (d)->type->hashFunction(key)
+
+#define dictGetEntryKey(he) ((he)->key)
+#define dictGetEntryVal(he) ((he)->val)
+#define dictSlots(d) ((d)->ht[0].size+(d)->ht[1].size)
+#define dictSize(d) ((d)->ht[0].used+(d)->ht[1].used)
+#define dictIsRehashing(ht) ((ht)->rehashidx != -1)
+
+/* API */
+dict *dictCreate(dictType *type, void *privDataPtr);
+int dictExpand(dict *d, unsigned long size);
+int dictAdd(dict *d, void *key, void *val);
+int dictReplace(dict *d, void *key, void *val);
+int dictDelete(dict *d, const void *key);
+int dictDeleteNoFree(dict *d, const void *key);
+void dictRelease(dict *d);
+dictEntry * dictFind(dict *d, const void *key);
+void *dictFetchValue(dict *d, const void *key);
+int dictResize(dict *d);
+dictIterator *dictGetIterator(dict *d);
+dictEntry *dictNext(dictIterator *iter);
+void dictReleaseIterator(dictIterator *iter);
+dictEntry *dictGetRandomKey(dict *d);
+void dictPrintStats(dict *d);
+unsigned int dictGenHashFunction(const unsigned char *buf, int len);
+void dictEmpty(dict *d);
+void dictEnableResize(void);
+void dictDisableResize(void);
+int dictRehash(dict *d, int n);
+int dictRehashMilliseconds(dict *d, int ms);
+
+/* Hash table types */
+extern dictType dictTypeHeapStringCopyKey;
+extern dictType dictTypeHeapStrings;
+extern dictType dictTypeHeapStringCopyKeyValue;
+
+#endif /* __DICT_H */
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/endian.h xen-4.2.1-merge/stubdom/c_httpd_redis/endian.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/endian.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/endian.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,20 @@
+#ifndef __MACHINE_ENDIAN_H__
+
+#include <sys/config.h>
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BYTE_ORDER
+#ifdef __IEEE_LITTLE_ENDIAN
+#define BYTE_ORDER LITTLE_ENDIAN
+#else
+#define BYTE_ORDER BIG_ENDIAN
+#endif
+#endif
+
+#endif /* __MACHINE_ENDIAN_H__ */
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/fmacros.h xen-4.2.1-merge/stubdom/c_httpd_redis/fmacros.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/fmacros.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/fmacros.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,15 @@
+#ifndef _REDIS_FMACRO_H
+#define _REDIS_FMACRO_H
+
+#define _BSD_SOURCE
+
+#ifdef __linux__
+#define _XOPEN_SOURCE 700
+#else
+#define _XOPEN_SOURCE
+#endif
+
+#define _LARGEFILE_SOURCE
+#define _FILE_OFFSET_BITS 64
+
+#endif
Binary files xen-4.2.1-origin/stubdom/c_httpd_redis/httpd.a and xen-4.2.1-merge/stubdom/c_httpd_redis/httpd.a differ
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/httpd.c xen-4.2.1-merge/stubdom/c_httpd_redis/httpd.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/httpd.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/httpd.c	2016-08-05 15:52:56.000000000 +0800
@@ -0,0 +1,380 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "ae.h"
+#include "zmalloc.h"
+#include "config.h"
+
+#define PORT 80
+#define VERSION "0.1"
+#define HTTP_VERSION "1.1"
+#define E_BAD_REQ	1000
+
+#define BUFFSIZE 512
+#define MAXPENDING 50
+
+/* Anti-warning macro... */
+#define NOTUSED(V) ((void) V)
+
+struct WebServer
+{
+	int port;
+	int fd;
+	aeEventLoop *el;
+	int cronloops;              /* number of times the cron function run */
+	long long stat_numconnections; /* number of connections received */
+	unsigned int maxclients;
+	char *bindaddr;
+
+};
+
+struct http_request {
+	int sock;
+};
+
+struct responce_header {
+	int code;
+	char *header;
+};
+
+struct responce_header headers[] = {
+	{ 200, 	"HTTP/" HTTP_VERSION " 200 OK\r\n"
+		"Server: jhttpd/" VERSION "\r\n"},
+	{0, 0},
+};
+
+struct error_messages {
+	int code;
+	char *msg;
+};
+
+struct error_messages errors[] = {
+	{400, "Bad Request"},
+	{404, "Not Found"},
+};
+
+static struct WebServer server;
+
+
+static void
+die(char *m)
+{
+	printf("%s\n", m);
+	exit(1);
+}
+
+
+static int
+send_header(struct http_request *req, int code)
+{
+	struct responce_header *h = headers;
+	while (h->code != 0 && h->header!= 0) {
+		if (h->code == code)
+			break;
+		h++;
+	}
+
+	if (h->code == 0)
+		return -1;
+
+	int len = strlen(h->header);
+	if (write(req->sock, h->header, len) != len) {
+		die("Failed to send bytes to client");
+	}
+
+	return 0;
+}
+
+static int
+send_size(struct http_request *req, off_t size)
+{
+	char buf[64];
+	int r;
+
+	r = snprintf(buf, 64, "Content-Length: %ld\r\n", (long)size);
+	if (r > 63)
+		die("buffer too small!");
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static const char*
+mime_type()
+{
+	return "text/html";
+}
+
+static int
+send_content_type(struct http_request *req)
+{
+	char buf[128];
+	int r;
+	const char *type;
+
+	type = mime_type();
+	if (!type)
+		return -1;
+
+	r = snprintf(buf, 128, "Content-Type: %s\r\n", type);
+	if (r > 127)
+		die("buffer too small!");
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static int
+send_header_fin(struct http_request *req)
+{
+	const char *fin = "\r\n";
+	int fin_len = strlen(fin);
+
+	if (write(req->sock, fin, fin_len) != fin_len)
+		return -1;
+
+	return 0;
+}
+
+static int
+send_error(struct http_request *req, int code)
+{
+	char buf[512];
+	int r;
+
+	struct error_messages *e = errors;
+	while (e->code != 0 && e->msg != 0) {
+		if (e->code == code)
+			break;
+		e++;
+	}
+
+	if (e->code == 0)
+		return -1;
+
+	r = snprintf(buf, 512, "HTTP/" HTTP_VERSION" %d %s\r\n"
+			       "Server: jhttpd/" VERSION "\r\n"
+			       "Connection: close"
+			       "Content-type: text/html\r\n"
+			       "\r\n"
+			       "<html><body><p>%d - %s</p></body></html>\r\n",
+			       e->code, e->msg, e->code, e->msg);
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static int send_info(struct http_request *req)
+{
+	char buf[1024] = "<html><head><title>Index of </title></head><body>Hello World</body></html>";
+	int n = sizeof(buf);
+	write(req->sock, buf, n);
+	return 0;
+}
+
+static int
+send_data(struct http_request *req)
+{
+	int r;
+
+	if ((r = send_header(req, 200)) < 0)
+		goto end;
+
+	if ((r = send_size(req, 1024)) < 0)
+		goto end;
+
+	if ((r = send_content_type(req)) < 0)
+		goto end;
+
+	if ((r = send_header_fin(req)) < 0)
+		goto end;
+
+
+	r = send_info(req);
+
+end:
+	return r;
+}
+
+static void
+handle_client(int sock)
+{
+	struct http_request con_d;
+	int r;
+	char buffer[BUFFSIZE];
+	int received = -1;
+	struct http_request *req = &con_d;
+
+	while (1)
+	{
+		if ((received = read(sock, buffer, BUFFSIZE)) < 0)
+			die("failed to read");
+
+		memset(req, 0, sizeof(req));
+		req->sock = sock;
+		send_data(req);
+		break;
+	}
+	close(sock);
+}
+
+static int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
+
+	int loops = server.cronloops ++;
+	NOTUSED(eventLoop);
+	NOTUSED(id);
+	NOTUSED(clientData);
+
+	/* Show information about connected clients */
+    if (!(loops % 50)) {
+        printf("%d clients connected\n", server.stat_numconnections);
+    }
+
+    return 100;
+}
+
+static void readFromClient(aeEventLoop *el, int fd, void *privdata, int mask){
+	struct http_request con_d;
+	char buffer[BUFFSIZE];
+	int received = -1;
+	struct http_request *req = &con_d;
+
+	NOTUSED(el);
+	NOTUSED(mask);
+	NOTUSED(privdata);
+
+	if ((received = read(fd, buffer, BUFFSIZE)) <= 0){
+		aeDeleteFileEvent(server.el,fd,AE_READABLE);
+    	aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
+		close(fd);
+		server.stat_numconnections --;
+
+		return;
+	}							
+	else{
+		printf("handle client[%d]\n", fd);
+		memset(req, 0, sizeof(req));
+		req->sock = fd;
+		send_data(req);
+		return;
+	}
+}
+
+static void acceptHandler(aeEventLoop *el, int sfd, void *privdata, int mask){
+	int cfd;
+	struct sockaddr_in sa;
+    unsigned int saLen;
+
+    NOTUSED(el);
+	NOTUSED(mask);
+	NOTUSED(privdata);
+
+    
+    saLen = sizeof(sa);
+    cfd = accept(sfd, (struct sockaddr*)&sa, &saLen);
+    	
+    if (cfd <= 0) 
+    {
+    	die("Failed to accept client connection");
+    	return;  	
+    }
+
+
+    if (server.stat_numconnections < server.maxclients) 
+    {
+
+    	server.stat_numconnections ++;
+    	printf("------> new connection client %d %s:%d\n", cfd,
+    			inet_ntoa(sa.sin_addr), ntohs(sa.sin_port));
+    	printf("-----> client amount: %d\n", server.stat_numconnections);
+    			
+	}else{
+		close(cfd);
+		die("max connections arrive, exit\n");
+	}
+
+	if (aeCreateFileEvent(server.el, cfd,AE_READABLE, readFromClient, NULL) == AE_ERR)
+    {
+        close(cfd);
+        return;
+    }
+}
+
+
+static void beforeSleep(struct aeEventLoop *eventLoop) {
+    NOTUSED(eventLoop);
+}
+
+int newServerSocket(char *bindaddr){
+	int sfd;
+	struct sockaddr_in sa;
+
+	//建立监听socket，并监听
+	if ((sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
+		die("Failed to create socket");
+
+	memset(&sa, 0, sizeof(sa));	
+	sa.sin_family = AF_INET;
+	sa.sin_addr.s_addr = htonl(INADDR_ANY);
+	sa.sin_port = htons(PORT);
+
+	if (bindaddr) {
+        if (inet_aton(bindaddr, &sa.sin_addr) == 0) {
+        	close(sfd);
+            die("Invalid bind address\n");  
+            return -1;
+        }
+    }
+
+	if (bind(sfd, (struct sockaddr *) &sa,
+		 sizeof(sa)) < 0)
+	{
+		die("Failed to bind the server socket");
+	}
+
+	if (listen(sfd, MAXPENDING) < 0)
+		die("Failed to listen on server socket");
+
+	printf("Waiting for http connections...\n");
+	return sfd;
+}
+
+int main(int argc, char **argv){
+	sleep(1);
+
+	//init server
+	server.port = PORT;
+	server.bindaddr = NULL;
+	server.maxclients = MAXPENDING;
+
+	server.el = aeCreateEventLoop();
+	server.fd = newServerSocket(server.bindaddr);
+
+	server.cronloops = 0;
+	server.stat_numconnections = 0;
+
+	aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);
+    if (aeCreateFileEvent(server.el, server.fd, AE_READABLE, acceptHandler, NULL) == AE_ERR) 
+        die("creating file event");
+
+    aeSetBeforeSleepProc(server.el,beforeSleep);
+    aeMain(server.el);
+    aeDeleteEventLoop(server.el);
+    return 0;
+
+}
+
+
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/httpd_iomultiplexing.c xen-4.2.1-merge/stubdom/c_httpd_redis/httpd_iomultiplexing.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/httpd_iomultiplexing.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/httpd_iomultiplexing.c	2016-08-05 15:02:42.000000000 +0800
@@ -0,0 +1,339 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <mini-os/sched.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#define PORT 80
+#define VERSION "0.1"
+#define HTTP_VERSION "1.1"
+
+#define E_BAD_REQ	1000
+
+#define BUFFSIZE 512
+#define MAXPENDING 50
+
+int fd_A[MAXPENDING];    // accepted connection fd
+int conn_amount;      // current connection amount
+
+struct http_request {
+	int sock;
+};
+
+struct responce_header {
+	int code;
+	char *header;
+};
+
+struct responce_header headers[] = {
+	{ 200, 	"HTTP/" HTTP_VERSION " 200 OK\r\n"
+		"Server: jhttpd/" VERSION "\r\n"},
+	{0, 0},
+};
+
+struct error_messages {
+	int code;
+	char *msg;
+};
+
+struct error_messages errors[] = {
+	{400, "Bad Request"},
+	{404, "Not Found"},
+};
+
+static void
+die(char *m)
+{
+	printf("%s\n", m);
+	exit(1);
+}
+
+
+static int
+send_header(struct http_request *req, int code)
+{
+	struct responce_header *h = headers;
+	while (h->code != 0 && h->header!= 0) {
+		if (h->code == code)
+			break;
+		h++;
+	}
+
+	if (h->code == 0)
+		return -1;
+
+	int len = strlen(h->header);
+	if (write(req->sock, h->header, len) != len) {
+		die("Failed to send bytes to client");
+	}
+
+	return 0;
+}
+
+static int
+send_size(struct http_request *req, off_t size)
+{
+	char buf[64];
+	int r;
+
+	r = snprintf(buf, 64, "Content-Length: %ld\r\n", (long)size);
+	if (r > 63)
+		die("buffer too small!");
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static const char*
+mime_type()
+{
+	return "text/html";
+}
+
+static int
+send_content_type(struct http_request *req)
+{
+	char buf[128];
+	int r;
+	const char *type;
+
+	type = mime_type();
+	if (!type)
+		return -1;
+
+	r = snprintf(buf, 128, "Content-Type: %s\r\n", type);
+	if (r > 127)
+		die("buffer too small!");
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static int
+send_header_fin(struct http_request *req)
+{
+	const char *fin = "\r\n";
+	int fin_len = strlen(fin);
+
+	if (write(req->sock, fin, fin_len) != fin_len)
+		return -1;
+
+	return 0;
+}
+
+static int
+send_error(struct http_request *req, int code)
+{
+	char buf[512];
+	int r;
+
+	struct error_messages *e = errors;
+	while (e->code != 0 && e->msg != 0) {
+		if (e->code == code)
+			break;
+		e++;
+	}
+
+	if (e->code == 0)
+		return -1;
+
+	r = snprintf(buf, 512, "HTTP/" HTTP_VERSION" %d %s\r\n"
+			       "Server: jhttpd/" VERSION "\r\n"
+			       "Connection: close"
+			       "Content-type: text/html\r\n"
+			       "\r\n"
+			       "<html><body><p>%d - %s</p></body></html>\r\n",
+			       e->code, e->msg, e->code, e->msg);
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static int send_info(struct http_request *req)
+{
+	char buf[1024] = "<html><head><title>Index of </title></head><body>Hello World</body></html>";
+	int n = sizeof(buf);
+	write(req->sock, buf, n);
+	return 0;
+}
+
+static int
+send_data(struct http_request *req)
+{
+	int r;
+	printf("send data\n");
+	if ((r = send_header(req, 200)) < 0)
+		goto end;
+
+	if ((r = send_size(req, 1024)) < 0)
+		goto end;
+
+	if ((r = send_content_type(req)) < 0)
+		goto end;
+
+	if ((r = send_header_fin(req)) < 0)
+		goto end;
+
+
+	r = send_info(req);
+
+end:
+	return r;
+}
+
+
+int main(int argc, char **argv)
+{
+	int serversock, clientsock;
+	struct sockaddr_in server, client;
+	struct timeval start, end;
+    int timeuse;
+	int i;
+	
+	if ((serversock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
+		die("Failed to create socket");
+
+	memset(&server, 0, sizeof(server));	
+	server.sin_family = AF_INET;
+	server.sin_addr.s_addr = htonl(INADDR_ANY);
+	server.sin_port = htons(PORT);
+
+	if (bind(serversock, (struct sockaddr *) &server,
+		 sizeof(server)) < 0)
+	{
+		die("Failed to bind the server socket");
+	}
+
+	if (listen(serversock, MAXPENDING) < 0)
+		die("Failed to listen on server socket");
+
+	printf("Waiting for http connections...\n");
+	gettimeofday( &start, NULL );
+
+	fd_set rfds, wfds, efds;
+	int maxsock;
+	struct timeval tv;
+	conn_amount = 0;
+	maxsock = serversock;
+	unsigned int clientlen = sizeof(client);
+
+	while (1) {
+		sleep(0);
+
+		// initialize file descriptor set
+		FD_ZERO(&rfds);
+        FD_ZERO(&wfds);
+		FD_SET(serversock, &rfds);  // add fd
+		FD_SET(serversock, &wfds);  // add fd
+		// timeout setting
+		tv.tv_sec = 30;
+		tv.tv_usec = 0;
+		// add active connection to fd set
+		for (i = 0; i < MAXPENDING; i++) {
+			if (fd_A[i] != 0) {
+				FD_SET(fd_A[i], &rfds);
+				//printf("fd_A[%d]: %d\n", i, fd_A[i]);
+			}
+		}
+
+		//printf("before select!!!!!!!!!!!! ret = %d\n", ret);
+        if ((select(maxsock + 1, &rfds, &wfds, (fd_set*) 0, &tv) < 0)){
+			die("select");
+			break;
+		} 
+
+		// check whether a new connection comes
+		if (FD_ISSET(serversock, &rfds))  // accept new connection 
+		{
+			gettimeofday( &end, NULL );
+        	timeuse = 1000000 * (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec);
+        	printf("pass time : %d us\n", timeuse);
+
+			clientsock = accept(serversock, (struct sockaddr *)&client, &clientlen);
+
+			gettimeofday( &start, NULL );
+
+			if (clientsock <= 0) 
+			{
+				die("Failed to accept client connection");
+				continue;
+			}
+			// add to fd queue
+			if (conn_amount < MAXPENDING) 
+			{
+				
+				for (i = 0; i < MAXPENDING; i++) {
+					if (fd_A[i] == 0) {
+
+						fd_A[i] = clientsock;
+						conn_amount++;
+						printf("------> new connection client %d %s:%d\n", clientsock,
+							inet_ntoa(client.sin_addr), ntohs(client.sin_port));
+						if (clientsock > maxsock)  // update the maxsock fd for select function
+							maxsock = clientsock;
+						printf("-----> client amount: %d\n", conn_amount);
+
+						break;
+					}
+				}
+				
+			}else 
+			{
+				printf("max connections arrive, exit\n");
+				//send(clientsock, "bye", 4, 0);
+				close(clientsock);
+				//break;   
+			}
+		}
+        else{
+			// check every fd in the set
+			for (i = 0; i < MAXPENDING; i++) 
+			{
+				//printf("%d\n", i);
+				if (FD_ISSET(fd_A[i], &rfds)) // check which fd is ready
+				{				
+					
+					struct http_request con_d;
+					int r;
+					char buffer[BUFFSIZE];
+					int received = -1;
+					struct http_request *req = &con_d;
+
+					if ((received = read(fd_A[i], buffer, BUFFSIZE)) <= 0){
+						close(fd_A[i]);
+						FD_CLR(fd_A[i], &rfds);  // delete fd 
+						fd_A[i] = 0;
+						conn_amount--;
+					}							
+					else{
+						printf("handle client[%d]\n", fd_A[i]);
+						memset(req, 0, sizeof(req));
+						req->sock = fd_A[i];
+						send_data(req);
+					}			
+				}
+			}
+		}
+		
+	}
+	// close other connections
+	for (i = 0; i < MAXPENDING; i++) 
+	{
+		if (fd_A[i] != 0) 
+		{
+			close(fd_A[i]);
+		}
+	}
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/httpd_redisEventDriven.c xen-4.2.1-merge/stubdom/c_httpd_redis/httpd_redisEventDriven.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/httpd_redisEventDriven.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/httpd_redisEventDriven.c	2016-08-05 14:32:43.000000000 +0800
@@ -0,0 +1,381 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "ae.h"
+#include "zmalloc.h"
+#include "config.h"
+
+#define PORT 80
+#define VERSION "0.1"
+#define HTTP_VERSION "1.1"
+
+#define E_BAD_REQ	1000
+
+#define BUFFSIZE 512
+#define MAXPENDING 50
+
+/* Anti-warning macro... */
+#define NOTUSED(V) ((void) V)
+
+struct WebServer
+{
+	int port;
+	int fd;
+	aeEventLoop *el;
+	int cronloops;              /* number of times the cron function run */
+	long long stat_numconnections; /* number of connections received */
+	unsigned int maxclients;
+	char *bindaddr;
+
+};
+
+struct http_request {
+	int sock;
+};
+
+struct responce_header {
+	int code;
+	char *header;
+};
+
+struct responce_header headers[] = {
+	{ 200, 	"HTTP/" HTTP_VERSION " 200 OK\r\n"
+		"Server: jhttpd/" VERSION "\r\n"},
+	{0, 0},
+};
+
+struct error_messages {
+	int code;
+	char *msg;
+};
+
+struct error_messages errors[] = {
+	{400, "Bad Request"},
+	{404, "Not Found"},
+};
+
+static struct WebServer server;
+
+
+static void
+die(char *m)
+{
+	printf("%s\n", m);
+	exit(1);
+}
+
+
+static int
+send_header(struct http_request *req, int code)
+{
+	struct responce_header *h = headers;
+	while (h->code != 0 && h->header!= 0) {
+		if (h->code == code)
+			break;
+		h++;
+	}
+
+	if (h->code == 0)
+		return -1;
+
+	int len = strlen(h->header);
+	if (write(req->sock, h->header, len) != len) {
+		die("Failed to send bytes to client");
+	}
+
+	return 0;
+}
+
+static int
+send_size(struct http_request *req, off_t size)
+{
+	char buf[64];
+	int r;
+
+	r = snprintf(buf, 64, "Content-Length: %ld\r\n", (long)size);
+	if (r > 63)
+		die("buffer too small!");
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static const char*
+mime_type()
+{
+	return "text/html";
+}
+
+static int
+send_content_type(struct http_request *req)
+{
+	char buf[128];
+	int r;
+	const char *type;
+
+	type = mime_type();
+	if (!type)
+		return -1;
+
+	r = snprintf(buf, 128, "Content-Type: %s\r\n", type);
+	if (r > 127)
+		die("buffer too small!");
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static int
+send_header_fin(struct http_request *req)
+{
+	const char *fin = "\r\n";
+	int fin_len = strlen(fin);
+
+	if (write(req->sock, fin, fin_len) != fin_len)
+		return -1;
+
+	return 0;
+}
+
+static int
+send_error(struct http_request *req, int code)
+{
+	char buf[512];
+	int r;
+
+	struct error_messages *e = errors;
+	while (e->code != 0 && e->msg != 0) {
+		if (e->code == code)
+			break;
+		e++;
+	}
+
+	if (e->code == 0)
+		return -1;
+
+	r = snprintf(buf, 512, "HTTP/" HTTP_VERSION" %d %s\r\n"
+			       "Server: jhttpd/" VERSION "\r\n"
+			       "Connection: close"
+			       "Content-type: text/html\r\n"
+			       "\r\n"
+			       "<html><body><p>%d - %s</p></body></html>\r\n",
+			       e->code, e->msg, e->code, e->msg);
+
+	if (write(req->sock, buf, r) != r)
+		return -1;
+
+	return 0;
+}
+
+static int send_info(struct http_request *req)
+{
+	char buf[1024] = "<html><head><title>Index of </title></head><body>Hello World</body></html>";
+	int n = sizeof(buf);
+	write(req->sock, buf, n);
+	return 0;
+}
+
+static int
+send_data(struct http_request *req)
+{
+	int r;
+
+	if ((r = send_header(req, 200)) < 0)
+		goto end;
+
+	if ((r = send_size(req, 1024)) < 0)
+		goto end;
+
+	if ((r = send_content_type(req)) < 0)
+		goto end;
+
+	if ((r = send_header_fin(req)) < 0)
+		goto end;
+
+
+	r = send_info(req);
+
+end:
+	return r;
+}
+
+static void
+handle_client(int sock)
+{
+	struct http_request con_d;
+	int r;
+	char buffer[BUFFSIZE];
+	int received = -1;
+	struct http_request *req = &con_d;
+
+	while (1)
+	{
+		if ((received = read(sock, buffer, BUFFSIZE)) < 0)
+			die("failed to read");
+
+		memset(req, 0, sizeof(req));
+		req->sock = sock;
+		send_data(req);
+		break;
+	}
+	close(sock);
+}
+
+static int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
+
+	int loops = server.cronloops ++;
+	NOTUSED(eventLoop);
+	NOTUSED(id);
+	NOTUSED(clientData);
+
+	/* Show information about connected clients */
+    if (!(loops % 50)) {
+        printf("%d clients connected\n", server.stat_numconnections);
+    }
+
+    return 100;
+}
+
+static void readFromClient(aeEventLoop *el, int fd, void *privdata, int mask){
+	struct http_request con_d;
+	char buffer[BUFFSIZE];
+	int received = -1;
+	struct http_request *req = &con_d;
+
+	NOTUSED(el);
+	NOTUSED(mask);
+	NOTUSED(privdata);
+
+	if ((received = read(fd, buffer, BUFFSIZE)) <= 0){
+		aeDeleteFileEvent(server.el,fd,AE_READABLE);
+    	aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
+		close(fd);
+		server.stat_numconnections --;
+
+		return;
+	}							
+	else{
+		printf("handle client[%d]\n", fd);
+		memset(req, 0, sizeof(req));
+		req->sock = fd;
+		send_data(req);
+		return;
+	}
+}
+
+static void acceptHandler(aeEventLoop *el, int sfd, void *privdata, int mask){
+	int cfd;
+	struct sockaddr_in sa;
+    unsigned int saLen;
+
+    NOTUSED(el);
+	NOTUSED(mask);
+	NOTUSED(privdata);
+
+    
+    saLen = sizeof(sa);
+    cfd = accept(sfd, (struct sockaddr*)&sa, &saLen);
+    	
+    if (cfd <= 0) 
+    {
+    	die("Failed to accept client connection");
+    	return;  	
+    }
+
+
+    if (server.stat_numconnections < server.maxclients) 
+    {
+
+    	server.stat_numconnections ++;
+    	printf("------> new connection client %d %s:%d\n", cfd,
+    			inet_ntoa(sa.sin_addr), ntohs(sa.sin_port));
+    	printf("-----> client amount: %d\n", server.stat_numconnections);
+    			
+	}else{
+		close(cfd);
+		die("max connections arrive, exit\n");
+	}
+
+	if (aeCreateFileEvent(server.el, cfd,AE_READABLE, readFromClient, NULL) == AE_ERR)
+    {
+        close(cfd);
+        return;
+    }
+}
+
+
+static void beforeSleep(struct aeEventLoop *eventLoop) {
+    NOTUSED(eventLoop);
+}
+
+int newServerSocket(char *bindaddr){
+	int sfd;
+	struct sockaddr_in sa;
+
+	//建立监听socket，并监听
+	if ((sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
+		die("Failed to create socket");
+
+	memset(&sa, 0, sizeof(sa));	
+	sa.sin_family = AF_INET;
+	sa.sin_addr.s_addr = htonl(INADDR_ANY);
+	sa.sin_port = htons(PORT);
+
+	if (bindaddr) {
+        if (inet_aton(bindaddr, &sa.sin_addr) == 0) {
+        	close(sfd);
+            die("Invalid bind address\n");  
+            return -1;
+        }
+    }
+
+	if (bind(sfd, (struct sockaddr *) &sa,
+		 sizeof(sa)) < 0)
+	{
+		die("Failed to bind the server socket");
+	}
+
+	if (listen(sfd, MAXPENDING) < 0)
+		die("Failed to listen on server socket");
+
+	printf("Waiting for http connections...\n");
+	return sfd;
+}
+
+int main(int argc, char **argv){
+	sleep(1);
+
+	//init server
+	server.port = PORT;
+	server.bindaddr = NULL;
+	server.maxclients = MAXPENDING;
+
+	server.el = aeCreateEventLoop();
+	server.fd = newServerSocket(server.bindaddr);
+
+	server.cronloops = 0;
+	server.stat_numconnections = 0;
+
+	aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);
+    if (aeCreateFileEvent(server.el, server.fd, AE_READABLE, acceptHandler, NULL) == AE_ERR) 
+        die("creating file event");
+
+    aeSetBeforeSleepProc(server.el,beforeSleep);
+    aeMain(server.el);
+    aeDeleteEventLoop(server.el);
+    return 0;
+
+}
+
+
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/lzf_c.c xen-4.2.1-merge/stubdom/c_httpd_redis/lzf_c.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/lzf_c.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/lzf_c.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,295 @@
+/*
+ * Copyright (c) 2000-2008 Marc Alexander Lehmann <schmorp@schmorp.de>
+ * 
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ * 
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ * 
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#include "lzfP.h"
+
+#define HSIZE (1 << (HLOG))
+
+/*
+ * don't play with this unless you benchmark!
+ * decompression is not dependent on the hash function
+ * the hashing function might seem strange, just believe me
+ * it works ;)
+ */
+#ifndef FRST
+# define FRST(p) (((p[0]) << 8) | p[1])
+# define NEXT(v,p) (((v) << 8) | p[2])
+# if ULTRA_FAST
+#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h  ) & (HSIZE - 1))
+# elif VERY_FAST
+#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
+# else
+#  define IDX(h) ((((h ^ (h << 5)) >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))
+# endif
+#endif
+/*
+ * IDX works because it is very similar to a multiplicative hash, e.g.
+ * ((h * 57321 >> (3*8 - HLOG)) & (HSIZE - 1))
+ * the latter is also quite fast on newer CPUs, and compresses similarly.
+ *
+ * the next one is also quite good, albeit slow ;)
+ * (int)(cos(h & 0xffffff) * 1e6)
+ */
+
+#if 0
+/* original lzv-like hash function, much worse and thus slower */
+# define FRST(p) (p[0] << 5) ^ p[1]
+# define NEXT(v,p) ((v) << 5) ^ p[2]
+# define IDX(h) ((h) & (HSIZE - 1))
+#endif
+
+#define        MAX_LIT        (1 <<  5)
+#define        MAX_OFF        (1 << 13)
+#define        MAX_REF        ((1 << 8) + (1 << 3))
+
+#if __GNUC__ >= 3
+# define expect(expr,value)         __builtin_expect ((expr),(value))
+# define inline                     inline
+#else
+# define expect(expr,value)         (expr)
+# define inline                     static
+#endif
+
+#define expect_false(expr) expect ((expr) != 0, 0)
+#define expect_true(expr)  expect ((expr) != 0, 1)
+
+/*
+ * compressed format
+ *
+ * 000LLLLL <L+1>    ; literal
+ * LLLooooo oooooooo ; backref L
+ * 111ooooo LLLLLLLL oooooooo ; backref L+7
+ *
+ */
+
+unsigned int
+lzf_compress (const void *const in_data, unsigned int in_len,
+	      void *out_data, unsigned int out_len
+#if LZF_STATE_ARG
+              , LZF_STATE htab
+#endif
+              )
+{
+#if !LZF_STATE_ARG
+  LZF_STATE htab;
+#endif
+  const u8 **hslot;
+  const u8 *ip = (const u8 *)in_data;
+        u8 *op = (u8 *)out_data;
+  const u8 *in_end  = ip + in_len;
+        u8 *out_end = op + out_len;
+  const u8 *ref;
+
+  /* off requires a type wide enough to hold a general pointer difference.
+   * ISO C doesn't have that (size_t might not be enough and ptrdiff_t only
+   * works for differences within a single object). We also assume that no
+   * no bit pattern traps. Since the only platform that is both non-POSIX
+   * and fails to support both assumptions is windows 64 bit, we make a
+   * special workaround for it.
+   */
+#if defined (WIN32) && defined (_M_X64)
+  unsigned _int64 off; /* workaround for missing POSIX compliance */
+#else
+  unsigned long off;
+#endif
+  unsigned int hval;
+  int lit;
+
+  if (!in_len || !out_len)
+    return 0;
+
+#if INIT_HTAB
+  memset (htab, 0, sizeof (htab));
+# if 0
+  for (hslot = htab; hslot < htab + HSIZE; hslot++)
+    *hslot++ = ip;
+# endif
+#endif
+
+  lit = 0; op++; /* start run */
+
+  hval = FRST (ip);
+  while (ip < in_end - 2)
+    {
+      hval = NEXT (hval, ip);
+      hslot = htab + IDX (hval);
+      ref = *hslot; *hslot = ip;
+
+      if (1
+#if INIT_HTAB
+          && ref < ip /* the next test will actually take care of this, but this is faster */
+#endif
+          && (off = ip - ref - 1) < MAX_OFF
+          && ip + 4 < in_end
+          && ref > (u8 *)in_data
+#if STRICT_ALIGN
+          && ref[0] == ip[0]
+          && ref[1] == ip[1]
+          && ref[2] == ip[2]
+#else
+          && *(u16 *)ref == *(u16 *)ip
+          && ref[2] == ip[2]
+#endif
+        )
+        {
+          /* match found at *ref++ */
+          unsigned int len = 2;
+          unsigned int maxlen = in_end - ip - len;
+          maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;
+
+          op [- lit - 1] = lit - 1; /* stop run */
+          op -= !lit; /* undo run if length is zero */
+
+          if (expect_false (op + 3 + 1 >= out_end))
+            return 0;
+
+          for (;;)
+            {
+              if (expect_true (maxlen > 16))
+                {
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                  len++; if (ref [len] != ip [len]) break;
+                }
+
+              do
+                len++;
+              while (len < maxlen && ref[len] == ip[len]);
+
+              break;
+            }
+
+          len -= 2; /* len is now #octets - 1 */
+          ip++;
+
+          if (len < 7)
+            {
+              *op++ = (off >> 8) + (len << 5);
+            }
+          else
+            {
+              *op++ = (off >> 8) + (  7 << 5);
+              *op++ = len - 7;
+            }
+
+          *op++ = off;
+          lit = 0; op++; /* start run */
+
+          ip += len + 1;
+
+          if (expect_false (ip >= in_end - 2))
+            break;
+
+#if ULTRA_FAST || VERY_FAST
+          --ip;
+# if VERY_FAST && !ULTRA_FAST
+          --ip;
+# endif
+          hval = FRST (ip);
+
+          hval = NEXT (hval, ip);
+          htab[IDX (hval)] = ip;
+          ip++;
+
+# if VERY_FAST && !ULTRA_FAST
+          hval = NEXT (hval, ip);
+          htab[IDX (hval)] = ip;
+          ip++;
+# endif
+#else
+          ip -= len + 1;
+
+          do
+            {
+              hval = NEXT (hval, ip);
+              htab[IDX (hval)] = ip;
+              ip++;
+            }
+          while (len--);
+#endif
+        }
+      else
+        {
+          /* one more literal byte we must copy */
+          if (expect_false (op >= out_end))
+            return 0;
+
+          lit++; *op++ = *ip++;
+
+          if (expect_false (lit == MAX_LIT))
+            {
+              op [- lit - 1] = lit - 1; /* stop run */
+              lit = 0; op++; /* start run */
+            }
+        }
+    }
+
+  if (op + 3 > out_end) /* at most 3 bytes can be missing here */
+    return 0;
+
+  while (ip < in_end)
+    {
+      lit++; *op++ = *ip++;
+
+      if (expect_false (lit == MAX_LIT))
+        {
+          op [- lit - 1] = lit - 1; /* stop run */
+          lit = 0; op++; /* start run */
+        }
+    }
+
+  op [- lit - 1] = lit - 1; /* end run */
+  op -= !lit; /* undo run if length is zero */
+
+  return op - (u8 *)out_data;
+}
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/lzf_d.c xen-4.2.1-merge/stubdom/c_httpd_redis/lzf_d.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/lzf_d.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/lzf_d.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2000-2007 Marc Alexander Lehmann <schmorp@schmorp.de>
+ * 
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ * 
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ * 
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#include "lzfP.h"
+
+#if AVOID_ERRNO
+# define SET_ERRNO(n)
+#else
+# include <errno.h>
+# define SET_ERRNO(n) errno = (n)
+#endif
+
+/*
+#if (__i386 || __amd64) && __GNUC__ >= 3
+# define lzf_movsb(dst, src, len)                \
+   asm ("rep movsb"                              \
+        : "=D" (dst), "=S" (src), "=c" (len)     \
+        :  "0" (dst),  "1" (src),  "2" (len));
+#endif
+*/
+
+unsigned int 
+lzf_decompress (const void *const in_data,  unsigned int in_len,
+                void             *out_data, unsigned int out_len)
+{
+  u8 const *ip = (const u8 *)in_data;
+  u8       *op = (u8 *)out_data;
+  u8 const *const in_end  = ip + in_len;
+  u8       *const out_end = op + out_len;
+
+  do
+    {
+      unsigned int ctrl = *ip++;
+
+      if (ctrl < (1 << 5)) /* literal run */
+        {
+          ctrl++;
+
+          if (op + ctrl > out_end)
+            {
+              SET_ERRNO (E2BIG);
+              return 0;
+            }
+
+#if CHECK_INPUT
+          if (ip + ctrl > in_end)
+            {
+              SET_ERRNO (EINVAL);
+              return 0;
+            }
+#endif
+
+#ifdef lzf_movsb
+          lzf_movsb (op, ip, ctrl);
+#else
+          do
+            *op++ = *ip++;
+          while (--ctrl);
+#endif
+        }
+      else /* back reference */
+        {
+          unsigned int len = ctrl >> 5;
+
+          u8 *ref = op - ((ctrl & 0x1f) << 8) - 1;
+
+#if CHECK_INPUT
+          if (ip >= in_end)
+            {
+              SET_ERRNO (EINVAL);
+              return 0;
+            }
+#endif
+          if (len == 7)
+            {
+              len += *ip++;
+#if CHECK_INPUT
+              if (ip >= in_end)
+                {
+                  SET_ERRNO (EINVAL);
+                  return 0;
+                }
+#endif
+            }
+
+          ref -= *ip++;
+
+          if (op + len + 2 > out_end)
+            {
+              SET_ERRNO (E2BIG);
+              return 0;
+            }
+
+          if (ref < (u8 *)out_data)
+            {
+              SET_ERRNO (EINVAL);
+              return 0;
+            }
+
+#ifdef lzf_movsb
+          len += 2;
+          lzf_movsb (op, ref, len);
+#else
+          *op++ = *ref++;
+          *op++ = *ref++;
+
+          do
+            *op++ = *ref++;
+          while (--len);
+#endif
+        }
+    }
+  while (ip < in_end);
+
+  return op - (u8 *)out_data;
+}
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/lzf.h xen-4.2.1-merge/stubdom/c_httpd_redis/lzf.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/lzf.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/lzf.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2000-2008 Marc Alexander Lehmann <schmorp@schmorp.de>
+ * 
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ * 
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ * 
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef LZF_H
+#define LZF_H
+
+/***********************************************************************
+**
+**	lzf -- an extremely fast/free compression/decompression-method
+**	http://liblzf.plan9.de/
+**
+**	This algorithm is believed to be patent-free.
+**
+***********************************************************************/
+
+#define LZF_VERSION 0x0105 /* 1.5, API version */
+
+/*
+ * Compress in_len bytes stored at the memory block starting at
+ * in_data and write the result to out_data, up to a maximum length
+ * of out_len bytes.
+ *
+ * If the output buffer is not large enough or any error occurs return 0,
+ * otherwise return the number of bytes used, which might be considerably
+ * more than in_len (but less than 104% of the original size), so it
+ * makes sense to always use out_len == in_len - 1), to ensure _some_
+ * compression, and store the data uncompressed otherwise (with a flag, of
+ * course.
+ *
+ * lzf_compress might use different algorithms on different systems and
+ * even different runs, thus might result in different compressed strings
+ * depending on the phase of the moon or similar factors. However, all
+ * these strings are architecture-independent and will result in the
+ * original data when decompressed using lzf_decompress.
+ *
+ * The buffers must not be overlapping.
+ *
+ * If the option LZF_STATE_ARG is enabled, an extra argument must be
+ * supplied which is not reflected in this header file. Refer to lzfP.h
+ * and lzf_c.c.
+ *
+ */
+unsigned int 
+lzf_compress (const void *const in_data,  unsigned int in_len,
+              void             *out_data, unsigned int out_len);
+
+/*
+ * Decompress data compressed with some version of the lzf_compress
+ * function and stored at location in_data and length in_len. The result
+ * will be stored at out_data up to a maximum of out_len characters.
+ *
+ * If the output buffer is not large enough to hold the decompressed
+ * data, a 0 is returned and errno is set to E2BIG. Otherwise the number
+ * of decompressed bytes (i.e. the original length of the data) is
+ * returned.
+ *
+ * If an error in the compressed data is detected, a zero is returned and
+ * errno is set to EINVAL.
+ *
+ * This function is very fast, about as fast as a copying loop.
+ */
+unsigned int 
+lzf_decompress (const void *const in_data,  unsigned int in_len,
+                void             *out_data, unsigned int out_len);
+
+#endif
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/lzfP.h xen-4.2.1-merge/stubdom/c_httpd_redis/lzfP.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/lzfP.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/lzfP.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2000-2007 Marc Alexander Lehmann <schmorp@schmorp.de>
+ * 
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ * 
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ * 
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef LZFP_h
+#define LZFP_h
+
+#define STANDALONE 1 /* at the moment, this is ok. */
+
+#ifndef STANDALONE
+# include "lzf.h"
+#endif
+
+/*
+ * Size of hashtable is (1 << HLOG) * sizeof (char *)
+ * decompression is independent of the hash table size
+ * the difference between 15 and 14 is very small
+ * for small blocks (and 14 is usually a bit faster).
+ * For a low-memory/faster configuration, use HLOG == 13;
+ * For best compression, use 15 or 16 (or more, up to 23).
+ */
+#ifndef HLOG
+# define HLOG 16
+#endif
+
+/*
+ * Sacrifice very little compression quality in favour of compression speed.
+ * This gives almost the same compression as the default code, and is
+ * (very roughly) 15% faster. This is the preferred mode of operation.
+ */
+#ifndef VERY_FAST
+# define VERY_FAST 1
+#endif
+
+/*
+ * Sacrifice some more compression quality in favour of compression speed.
+ * (roughly 1-2% worse compression for large blocks and
+ * 9-10% for small, redundant, blocks and >>20% better speed in both cases)
+ * In short: when in need for speed, enable this for binary data,
+ * possibly disable this for text data.
+ */
+#ifndef ULTRA_FAST
+# define ULTRA_FAST 0
+#endif
+
+/*
+ * Unconditionally aligning does not cost very much, so do it if unsure
+ */
+#ifndef STRICT_ALIGN
+# define STRICT_ALIGN !(defined(__i386) || defined (__amd64))
+#endif
+
+/*
+ * You may choose to pre-set the hash table (might be faster on some
+ * modern cpus and large (>>64k) blocks, and also makes compression
+ * deterministic/repeatable when the configuration otherwise is the same).
+ */
+#ifndef INIT_HTAB
+# define INIT_HTAB 0
+#endif
+
+/*
+ * Avoid assigning values to errno variable? for some embedding purposes
+ * (linux kernel for example), this is neccessary. NOTE: this breaks
+ * the documentation in lzf.h.
+ */
+#ifndef AVOID_ERRNO
+# define AVOID_ERRNO 0
+#endif
+
+/*
+ * Wether to pass the LZF_STATE variable as argument, or allocate it
+ * on the stack. For small-stack environments, define this to 1.
+ * NOTE: this breaks the prototype in lzf.h.
+ */
+#ifndef LZF_STATE_ARG
+# define LZF_STATE_ARG 0
+#endif
+
+/*
+ * Wether to add extra checks for input validity in lzf_decompress
+ * and return EINVAL if the input stream has been corrupted. This
+ * only shields against overflowing the input buffer and will not
+ * detect most corrupted streams.
+ * This check is not normally noticable on modern hardware
+ * (<1% slowdown), but might slow down older cpus considerably.
+ */
+#ifndef CHECK_INPUT
+# define CHECK_INPUT 1
+#endif
+
+/*****************************************************************************/
+/* nothing should be changed below */
+
+typedef unsigned char u8;
+
+typedef const u8 *LZF_STATE[1 << (HLOG)];
+
+#if !STRICT_ALIGN
+/* for unaligned accesses we need a 16 bit datatype. */
+# include <limits.h>
+# if USHRT_MAX == 65535
+    typedef unsigned short u16;
+# elif UINT_MAX == 65535
+    typedef unsigned int u16;
+# else
+#  undef STRICT_ALIGN
+#  define STRICT_ALIGN 1
+# endif
+#endif
+
+#if ULTRA_FAST
+# if defined(VERY_FAST)
+#  undef VERY_FAST
+# endif
+#endif
+
+#if INIT_HTAB
+# ifdef __cplusplus
+#  include <cstring>
+# else
+#  include <string.h>
+# endif
+#endif
+
+#endif
+
Binary files xen-4.2.1-origin/stubdom/c_httpd_redis/main.a and xen-4.2.1-merge/stubdom/c_httpd_redis/main.a differ
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/main.c xen-4.2.1-merge/stubdom/c_httpd_redis/main.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/main.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/main.c	2016-07-05 15:35:04.000000000 +0800
@@ -0,0 +1,7 @@
+#include <stdio.h>
+int main () {
+    sleep(1);
+
+    printf("hello world\n");
+    return 0;
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/main_fs.c xen-4.2.1-merge/stubdom/c_httpd_redis/main_fs.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/main_fs.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/main_fs.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,140 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <xenstore.h>
+#include <sched.h>
+#include <xenstore.h>
+#include <mini-os/lib.h>
+#include <mini-os/xmalloc.h>
+#include <xen/grant_table.h>
+#include <mini-os/gntmap.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+
+// 将int转成char *
+void itoa(char *str, int num) {
+    int base = 1000000000;
+    while (num / base == 0) {
+        base = base / 10;
+    }
+    
+    int i = 0;
+    while (base > 0) {
+        str[i++] = '0' + num / base;
+        num = num % base;    
+        base = base / 10;
+    }
+    str[i] = '\0'; 
+}
+
+
+void do_save();
+
+int main(int argc, char **argv) {
+    sleep(1);
+    do_save(); 
+    return 0;
+}
+
+
+// ============================ file system 
+int fs_open(char *ip, unsigned short port)
+{
+    int fd; 
+    int recbytes;
+    int sin_size;
+    struct sockaddr_in s_add, c_add; 
+
+    printf("Open file!\r\n");
+    fd = socket(AF_INET, SOCK_STREAM, 0);
+    if(fd == -1)
+    {
+        printf("open fail! \r\n");
+        return -1;
+    }
+
+    bzero(&s_add, sizeof(struct sockaddr_in)); // 清空结构体
+    s_add.sin_family = AF_INET; // 采用IPv4网络协议
+    s_add.sin_addr.s_addr= inet_addr(ip); 
+    s_add.sin_port = htons(port); 
+
+    if(-1 == connect(fd, (struct sockaddr *)(&s_add), sizeof(struct sockaddr)))
+    {
+        printf("open fail!\r\n");
+        return -1;
+    }
+
+    printf("open ok!\r\n");                    
+    return fd;
+}
+
+
+void fs_write(int fd, char *fname, char *buf)
+{
+    char *buffer = (char *)malloc(sizeof(char) * 5000);
+    char rcv[32];
+    int i;
+    char *send_buffer = (char *)malloc(sizeof(char) * 4097);
+    memset(send_buffer, 'a', 4097);
+    send_buffer[4096] = '\0';
+    
+    struct timeval start, end;
+    gettimeofday( &start, NULL );
+
+    int count = 1;
+    int index = 0;
+    while (start.tv_sec < 1445606648) {
+        printf("sec = %ld\n", start.tv_sec);
+        gettimeofday(&start, NULL);
+    }
+
+    for (i = 0; i < 128000; i++) {
+        memset(buffer, 0, sizeof(buffer));  // 清空str
+        memset(rcv, 0, sizeof(rcv));
+        sprintf(buffer, "set f_%05d 0 0 4096\r\n", i);  // 格式化发送数据
+        strcat(buffer, send_buffer);
+        strcat(buffer, "\r\n");
+
+        //printf("write : %s len = %d\n", buffer, strlen(buffer));
+        write(fd, buffer, strlen(buffer));
+        if (read(fd, rcv, 32) == -1) 
+        {
+            printf("write error!\n");
+            return;
+        } else {
+            //printf("write OK!\n");
+            //printf("RCV : %s\n", rcv);
+        }
+        if (count / 12800 == 1) {
+            index ++;
+            gettimeofday( &end, NULL );
+            int timeuse = 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec -start.tv_usec;
+            printf("**********************  Finish:  %d*50MB, time: %d us\n", index, timeuse);
+            count = 1;
+        }
+        count++;
+    }
+}
+
+void fs_close(int fd)
+{
+    close(fd);
+    printf("file close OK!\n");
+}
+
+
+void do_save()
+{
+    // 服务器还是不能以本机的redis-server为服务器
+    int fd = fs_open("10.107.15.110", 11211);
+    char filename[20] = "rdb";
+    char buf[1024] = "";
+    fs_write(fd, filename, buf);
+    fs_close(fd);
+    return 0;
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/main_gnttab.c xen-4.2.1-merge/stubdom/c_httpd_redis/main_gnttab.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/main_gnttab.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/main_gnttab.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,83 @@
+#include <stdio.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sched.h>
+#include <stdlib.h>
+#include <string.h>
+#include <xenstore.h>
+#include <mini-os/lib.h>
+#include <mini-os/xmalloc.h>
+#include <xen/grant_table.h>
+#include <mini-os/gntmap.h>
+#include <sys/time.h>
+
+char  shared_page_offer[1024] = "zhangchengfei";
+void * shared_page_receive;
+grant_entry_t *grant_table;
+
+unsigned int get_domid()
+{
+    struct xs_handle *xs;
+    char *buf;
+    unsigned int len, domid;
+    xs = xs_daemon_open();
+    if (xs == NULL) {
+        return -1;
+    } else {
+        buf = xs_read(xs, XBT_NULL, "domid", &len);
+        domid = atoi(buf);
+        printf("---> domid : %d\n", domid);
+        return domid;
+    }
+}
+
+int main() {
+    sleep(1);
+    uint32_t domid = get_domid();
+    struct timeval start, end;
+    printf("/-------------------------------------------------/\n");
+
+    // receive shared memory
+    if (domid % 2 == 0) {
+        //printf("%p:%d\n", shared_page_receive, (int)shared_page_receive);
+        struct gntmap *map = (struct gntmap *)malloc(sizeof(struct gntmap));
+        gntmap_init(map);
+        uint32_t refs = 1790;
+        uint32_t friend = domid - 1;
+        char buf[4096];
+        shared_page_receive = gntmap_map_grant_refs(map, 1, &friend, 0, &refs, 1);
+        
+        gettimeofday(&end, NULL);
+        printf("child end time: %ld\n", end.tv_sec * 1000000 + end.tv_usec);
+        //printf("---->  %p\n", virt_to_mfn(shared_page_receive));
+        *((char *)shared_page_receive + 64) = 'f';
+        gettimeofday(&start, NULL); 
+        printf("start time: %ld\n", start.tv_sec * 1000000 + start.tv_usec);
+        memcpy(buf, shared_page_receive, sizeof(char) * 4096);
+        int start = 0;
+        for (int i = 64; i < 10; i++) {
+                printf("%c", buf[i]);
+        }
+        gntmap_fini(map);
+    } else {
+        // offer shared memory
+        printf("machine address : %p\n", virt_to_mfn(shared_page_offer));
+       
+        gettimeofday(&start, NULL); 
+        grant_ref_t grant = gnttab_grant_access(domid + 1, virt_to_mfn(shared_page_offer), 0);
+        unsigned long offset = ((unsigned long)shared_page_offer & 0x0000000000000fff);
+        printf("offset = %lu  grant = %d\n", offset, grant);
+        printf("start time: %ld\n", start.tv_sec * 1000000 + start.tv_usec);
+        while (1) {
+            if (shared_page_offer[0] == 'f') {
+                gettimeofday(&end, NULL);
+                printf("end time: %ld\n", end.tv_sec * 1000000 + end.tv_usec);
+            }
+            printf("%s\n", shared_page_offer);
+        }
+        gnttab_end_access(grant);
+    }
+    printf("\n/-------------------------------------------------/\n");
+    return 0;
+}
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/Makefile xen-4.2.1-merge/stubdom/c_httpd_redis/Makefile
--- xen-4.2.1-origin/stubdom/c_httpd_redis/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/Makefile	2016-08-22 09:50:39.000000000 +0800
@@ -0,0 +1,37 @@
+PRGNAME=redis-server.a
+CCOPT= -std=c99 -pedantic -O2 -Wall -W
+DEBUG=-g -rdynamic -ggdb
+OBJ= adlist.o ae.o anet.o dict.o redis.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o
+WEBOBJ= httpd.o ae.o zmalloc.o 
+CCLINK= -lall:redis-server.a
+all:main.a
+# Deps (use make dep to generate this)
+
+adlist.o: adlist.c adlist.h zmalloc.h
+ae.o: ae.c ae.h zmalloc.h config.h ae_select.c
+ae_kqueue.o: ae_kqueue.c
+anet.o: anet.c fmacros.h anet.h
+dict.o: dict.c fmacros.h dict.h zmalloc.h
+redis.o: redis.c fmacros.h config.h redis.h ae.h sds.h anet.h dict.h \
+  adlist.h zmalloc.h lzf.h pqsort.h zipmap.h staticsymbols.h sha1.h release.h
+sds.o: sds.c sds.h zmalloc.h
+zmalloc.o: zmalloc.c config.h
+lzf_c.o: lzf_c.c lzfP.h
+lzf_d.o: lzf_d.c lzfP.h
+pqsort.o: pqsort.c
+zipmap.o: zipmap.c zmalloc.h
+sha1.o:sha1.c sha1.h
+
+httpd.o:httpd.c
+main.a:main.c
+
+redis-server.a: $(OBJ)
+	$(AR) cr $@ $^	
+main.a:main.o
+	$(AR) cr $@ $^	
+httpd.a:httpd.o 
+	$(AR) cr $@ $^	
+web-server.a: $(WEBOBJ) 
+	$(AR) cr $@ $^	
+clean:
+	rm -rf $(PRGNAME) *.o *.gcda *.gcno *.gcov
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/minios.cfg xen-4.2.1-merge/stubdom/c_httpd_redis/minios.cfg
--- xen-4.2.1-origin/stubdom/c_httpd_redis/minios.cfg	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/minios.cfg	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1 @@
+CONFIG_TEST=n
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/output.txt xen-4.2.1-merge/stubdom/c_httpd_redis/output.txt
--- xen-4.2.1-origin/stubdom/c_httpd_redis/output.txt	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/output.txt	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,1174 @@
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:410:14: error: invalid storage class for function ‘createStringObject’
+redis.c:411:14: error: invalid storage class for function ‘dupStringObject’
+redis.c:412:13: error: invalid storage class for function ‘replicationFeedSlaves’
+redis.c:413:13: error: invalid storage class for function ‘replicationFeedMonitors’
+redis.c:414:14: error: invalid storage class for function ‘tryObjectEncoding’
+redis.c:415:14: error: invalid storage class for function ‘getDecodedObject’
+redis.c:416:12: error: invalid storage class for function ‘removeExpire’
+redis.c:417:12: error: invalid storage class for function ‘expireIfNeeded’
+redis.c:418:12: error: invalid storage class for function ‘deleteIfVolatile’
+redis.c:419:12: error: invalid storage class for function ‘deleteKey’
+redis.c:420:15: error: invalid storage class for function ‘getExpire’
+redis.c:421:12: error: invalid storage class for function ‘setExpire’
+redis.c:422:13: error: invalid storage class for function ‘freeMemoryIfNeeded’
+redis.c:423:12: error: invalid storage class for function ‘processCommand’
+redis.c:424:13: error: invalid storage class for function ‘setupSigSegvAction’
+redis.c:425:15: error: invalid storage class for function ‘stringObjectLen’
+redis.c:426:13: error: invalid storage class for function ‘processInputBuffer’
+redis.c:427:19: error: invalid storage class for function ‘zslCreate’
+redis.c:428:13: error: invalid storage class for function ‘zslFree’
+redis.c:429:13: error: invalid storage class for function ‘zslInsert’
+redis.c:430:13: error: invalid storage class for function ‘initClientMultiState’
+redis.c:431:13: error: invalid storage class for function ‘freeClientMultiState’
+redis.c:432:13: error: invalid storage class for function ‘queueMultiCommand’
+redis.c:433:13: error: invalid storage class for function ‘unblockClientWaitingData’
+redis.c:434:12: error: invalid storage class for function ‘handleClientsWaitingListPush’
+redis.c:436:12: error: invalid storage class for function ‘tryFreeOneObjectFromFreelist’
+redis.c:437:13: error: invalid storage class for function ‘acceptHandler’
+redis.c:438:13: error: invalid storage class for function ‘readQueryFromClient’
+redis.c:439:29: error: invalid storage class for function ‘lookupCommand’
+redis.c:440:13: error: invalid storage class for function ‘call’
+redis.c:441:13: error: invalid storage class for function ‘resetClient’
+redis.c:442:13: error: invalid storage class for function ‘convertToRealHash’
+redis.c:443:12: error: invalid storage class for function ‘pubsubUnsubscribeAllChannels’
+redis.c:444:12: error: invalid storage class for function ‘pubsubUnsubscribeAllPatterns’
+redis.c:445:13: error: invalid storage class for function ‘freePubsubPattern’
+redis.c:446:12: error: invalid storage class for function ‘listMatchPubsubPattern’
+redis.c:447:12: error: invalid storage class for function ‘compareStringObjects’
+redis.c:448:12: error: invalid storage class for function ‘equalStringObjects’
+redis.c:449:13: error: invalid storage class for function ‘usage’
+redis.c:450:12: error: invalid storage class for function ‘prepareForShutdown’
+redis.c:452:13: error: invalid storage class for function ‘authCommand’
+redis.c:453:13: error: invalid storage class for function ‘pingCommand’
+redis.c:454:13: error: invalid storage class for function ‘echoCommand’
+redis.c:455:13: error: invalid storage class for function ‘setCommand’
+redis.c:456:13: error: invalid storage class for function ‘setnxCommand’
+redis.c:457:13: error: invalid storage class for function ‘setexCommand’
+redis.c:458:13: error: invalid storage class for function ‘getCommand’
+redis.c:459:13: error: invalid storage class for function ‘delCommand’
+redis.c:460:13: error: invalid storage class for function ‘existsCommand’
+redis.c:461:13: error: invalid storage class for function ‘incrCommand’
+redis.c:462:13: error: invalid storage class for function ‘decrCommand’
+redis.c:463:13: error: invalid storage class for function ‘incrbyCommand’
+redis.c:464:13: error: invalid storage class for function ‘decrbyCommand’
+redis.c:465:13: error: invalid storage class for function ‘selectCommand’
+redis.c:466:13: error: invalid storage class for function ‘randomkeyCommand’
+redis.c:467:13: error: invalid storage class for function ‘keysCommand’
+redis.c:468:13: error: invalid storage class for function ‘dbsizeCommand’
+redis.c:469:13: error: invalid storage class for function ‘lastsaveCommand’
+redis.c:470:13: error: invalid storage class for function ‘bgsaveCommand’
+redis.c:471:13: error: invalid storage class for function ‘shutdownCommand’
+redis.c:472:13: error: invalid storage class for function ‘moveCommand’
+redis.c:473:13: error: invalid storage class for function ‘renameCommand’
+redis.c:474:13: error: invalid storage class for function ‘renamenxCommand’
+redis.c:475:13: error: invalid storage class for function ‘lpushCommand’
+redis.c:476:13: error: invalid storage class for function ‘rpushCommand’
+redis.c:477:13: error: invalid storage class for function ‘lpopCommand’
+redis.c:478:13: error: invalid storage class for function ‘rpopCommand’
+redis.c:479:13: error: invalid storage class for function ‘llenCommand’
+redis.c:480:13: error: invalid storage class for function ‘lindexCommand’
+redis.c:481:13: error: invalid storage class for function ‘lrangeCommand’
+redis.c:482:13: error: invalid storage class for function ‘ltrimCommand’
+redis.c:483:13: error: invalid storage class for function ‘typeCommand’
+redis.c:484:13: error: invalid storage class for function ‘lsetCommand’
+redis.c:485:13: error: invalid storage class for function ‘saddCommand’
+redis.c:486:13: error: invalid storage class for function ‘sremCommand’
+redis.c:487:13: error: invalid storage class for function ‘smoveCommand’
+redis.c:488:13: error: invalid storage class for function ‘sismemberCommand’
+redis.c:489:13: error: invalid storage class for function ‘scardCommand’
+redis.c:490:13: error: invalid storage class for function ‘spopCommand’
+redis.c:491:13: error: invalid storage class for function ‘srandmemberCommand’
+redis.c:492:13: error: invalid storage class for function ‘sinterCommand’
+redis.c:493:13: error: invalid storage class for function ‘sinterstoreCommand’
+redis.c:494:13: error: invalid storage class for function ‘sunionCommand’
+redis.c:495:13: error: invalid storage class for function ‘sunionstoreCommand’
+redis.c:496:13: error: invalid storage class for function ‘sdiffCommand’
+redis.c:497:13: error: invalid storage class for function ‘sdiffstoreCommand’
+redis.c:498:13: error: invalid storage class for function ‘flushdbCommand’
+redis.c:499:13: error: invalid storage class for function ‘sortCommand’
+redis.c:500:13: error: invalid storage class for function ‘lremCommand’
+redis.c:501:13: error: invalid storage class for function ‘rpoplpushcommand’
+redis.c:502:13: error: invalid storage class for function ‘infoCommand’
+redis.c:503:13: error: invalid storage class for function ‘mgetCommand’
+redis.c:504:13: error: invalid storage class for function ‘monitorCommand’
+redis.c:505:13: error: invalid storage class for function ‘expireCommand’
+redis.c:506:13: error: invalid storage class for function ‘expireatCommand’
+redis.c:507:13: error: invalid storage class for function ‘getsetCommand’
+redis.c:508:13: error: invalid storage class for function ‘ttlCommand’
+redis.c:509:13: error: invalid storage class for function ‘slaveofCommand’
+redis.c:510:13: error: invalid storage class for function ‘msetCommand’
+redis.c:511:13: error: invalid storage class for function ‘msetnxCommand’
+redis.c:512:13: error: invalid storage class for function ‘zaddCommand’
+redis.c:513:13: error: invalid storage class for function ‘zincrbyCommand’
+redis.c:514:13: error: invalid storage class for function ‘zrangeCommand’
+redis.c:515:13: error: invalid storage class for function ‘zrangebyscoreCommand’
+redis.c:516:13: error: invalid storage class for function ‘zcountCommand’
+redis.c:517:13: error: invalid storage class for function ‘zrevrangeCommand’
+redis.c:518:13: error: invalid storage class for function ‘zcardCommand’
+redis.c:519:13: error: invalid storage class for function ‘zremCommand’
+redis.c:520:13: error: invalid storage class for function ‘zscoreCommand’
+redis.c:521:13: error: invalid storage class for function ‘zremrangebyscoreCommand’
+redis.c:522:13: error: invalid storage class for function ‘multiCommand’
+redis.c:523:13: error: invalid storage class for function ‘execCommand’
+redis.c:524:13: error: invalid storage class for function ‘discardCommand’
+redis.c:525:13: error: invalid storage class for function ‘blpopCommand’
+redis.c:526:13: error: invalid storage class for function ‘brpopCommand’
+redis.c:527:13: error: invalid storage class for function ‘substrCommand’
+redis.c:528:13: error: invalid storage class for function ‘zrankCommand’
+redis.c:529:13: error: invalid storage class for function ‘zrevrankCommand’
+redis.c:530:13: error: invalid storage class for function ‘hsetCommand’
+redis.c:531:13: error: invalid storage class for function ‘hsetnxCommand’
+redis.c:532:13: error: invalid storage class for function ‘hgetCommand’
+redis.c:533:13: error: invalid storage class for function ‘hmsetCommand’
+redis.c:534:13: error: invalid storage class for function ‘hmgetCommand’
+redis.c:535:13: error: invalid storage class for function ‘hdelCommand’
+redis.c:536:13: error: invalid storage class for function ‘hlenCommand’
+redis.c:537:13: error: invalid storage class for function ‘zremrangebyrankCommand’
+redis.c:538:13: error: invalid storage class for function ‘zunionstoreCommand’
+redis.c:539:13: error: invalid storage class for function ‘zinterstoreCommand’
+redis.c:540:13: error: invalid storage class for function ‘hkeysCommand’
+redis.c:541:13: error: invalid storage class for function ‘hvalsCommand’
+redis.c:542:13: error: invalid storage class for function ‘hgetallCommand’
+redis.c:543:13: error: invalid storage class for function ‘hexistsCommand’
+redis.c:544:13: error: invalid storage class for function ‘configCommand’
+redis.c:545:13: error: invalid storage class for function ‘hincrbyCommand’
+redis.c:546:13: error: invalid storage class for function ‘subscribeCommand’
+redis.c:547:13: error: invalid storage class for function ‘unsubscribeCommand’
+redis.c:548:13: error: invalid storage class for function ‘psubscribeCommand’
+redis.c:549:13: error: invalid storage class for function ‘punsubscribeCommand’
+redis.c:550:13: error: invalid storage class for function ‘publishCommand’
+redis.c:557:12: error: ‘getCommand’ undeclared (first use in this function)
+redis.c:557:12: note: each undeclared identifier is reported only once for each function it appears in
+redis.c:558:12: error: ‘setCommand’ undeclared (first use in this function)
+redis.c:559:14: error: ‘setnxCommand’ undeclared (first use in this function)
+redis.c:560:14: error: ‘setexCommand’ undeclared (first use in this function)
+redis.c:561:15: error: ‘substrCommand’ undeclared (first use in this function)
+redis.c:562:12: error: ‘delCommand’ undeclared (first use in this function)
+redis.c:563:15: error: ‘existsCommand’ undeclared (first use in this function)
+redis.c:564:13: error: ‘incrCommand’ undeclared (first use in this function)
+redis.c:565:13: error: ‘decrCommand’ undeclared (first use in this function)
+redis.c:566:13: error: ‘mgetCommand’ undeclared (first use in this function)
+redis.c:567:14: error: ‘rpushCommand’ undeclared (first use in this function)
+redis.c:568:14: error: ‘lpushCommand’ undeclared (first use in this function)
+redis.c:569:13: error: ‘rpopCommand’ undeclared (first use in this function)
+redis.c:570:13: error: ‘lpopCommand’ undeclared (first use in this function)
+redis.c:571:14: error: ‘brpopCommand’ undeclared (first use in this function)
+redis.c:572:14: error: ‘blpopCommand’ undeclared (first use in this function)
+redis.c:573:13: error: ‘llenCommand’ undeclared (first use in this function)
+redis.c:574:15: error: ‘lindexCommand’ undeclared (first use in this function)
+redis.c:575:13: error: ‘lsetCommand’ undeclared (first use in this function)
+redis.c:576:15: error: ‘lrangeCommand’ undeclared (first use in this function)
+redis.c:577:14: error: ‘ltrimCommand’ undeclared (first use in this function)
+redis.c:578:13: error: ‘lremCommand’ undeclared (first use in this function)
+redis.c:579:18: error: ‘rpoplpushcommand’ undeclared (first use in this function)
+redis.c:580:13: error: ‘saddCommand’ undeclared (first use in this function)
+redis.c:581:13: error: ‘sremCommand’ undeclared (first use in this function)
+redis.c:582:14: error: ‘smoveCommand’ undeclared (first use in this function)
+redis.c:583:18: error: ‘sismemberCommand’ undeclared (first use in this function)
+redis.c:584:14: error: ‘scardCommand’ undeclared (first use in this function)
+redis.c:585:13: error: ‘spopCommand’ undeclared (first use in this function)
+redis.c:586:20: error: ‘srandmemberCommand’ undeclared (first use in this function)
+redis.c:587:15: error: ‘sinterCommand’ undeclared (first use in this function)
+redis.c:588:20: error: ‘sinterstoreCommand’ undeclared (first use in this function)
+redis.c:589:15: error: ‘sunionCommand’ undeclared (first use in this function)
+redis.c:590:20: error: ‘sunionstoreCommand’ undeclared (first use in this function)
+redis.c:591:14: error: ‘sdiffCommand’ undeclared (first use in this function)
+redis.c:592:19: error: ‘sdiffstoreCommand’ undeclared (first use in this function)
+redis.c:594:13: error: ‘zaddCommand’ undeclared (first use in this function)
+redis.c:595:16: error: ‘zincrbyCommand’ undeclared (first use in this function)
+redis.c:596:13: error: ‘zremCommand’ undeclared (first use in this function)
+redis.c:597:25: error: ‘zremrangebyscoreCommand’ undeclared (first use in this function)
+redis.c:598:24: error: ‘zremrangebyrankCommand’ undeclared (first use in this function)
+redis.c:599:20: error: ‘zunionstoreCommand’ undeclared (first use in this function)
+redis.c:600:20: error: ‘zinterstoreCommand’ undeclared (first use in this function)
+redis.c:601:15: error: ‘zrangeCommand’ undeclared (first use in this function)
+redis.c:602:22: error: ‘zrangebyscoreCommand’ undeclared (first use in this function)
+redis.c:603:15: error: ‘zcountCommand’ undeclared (first use in this function)
+redis.c:604:18: error: ‘zrevrangeCommand’ undeclared (first use in this function)
+redis.c:605:14: error: ‘zcardCommand’ undeclared (first use in this function)
+redis.c:606:15: error: ‘zscoreCommand’ undeclared (first use in this function)
+redis.c:607:14: error: ‘zrankCommand’ undeclared (first use in this function)
+redis.c:608:17: error: ‘zrevrankCommand’ undeclared (first use in this function)
+redis.c:609:13: error: ‘hsetCommand’ undeclared (first use in this function)
+redis.c:610:15: error: ‘hsetnxCommand’ undeclared (first use in this function)
+redis.c:611:13: error: ‘hgetCommand’ undeclared (first use in this function)
+redis.c:612:14: error: ‘hmsetCommand’ undeclared (first use in this function)
+redis.c:613:14: error: ‘hmgetCommand’ undeclared (first use in this function)
+redis.c:614:16: error: ‘hincrbyCommand’ undeclared (first use in this function)
+redis.c:615:13: error: ‘hdelCommand’ undeclared (first use in this function)
+redis.c:616:13: error: ‘hlenCommand’ undeclared (first use in this function)
+redis.c:617:14: error: ‘hkeysCommand’ undeclared (first use in this function)
+redis.c:618:14: error: ‘hvalsCommand’ undeclared (first use in this function)
+redis.c:619:16: error: ‘hgetallCommand’ undeclared (first use in this function)
+redis.c:620:16: error: ‘hexistsCommand’ undeclared (first use in this function)
+redis.c:621:15: error: ‘incrbyCommand’ undeclared (first use in this function)
+redis.c:622:15: error: ‘decrbyCommand’ undeclared (first use in this function)
+redis.c:623:15: error: ‘getsetCommand’ undeclared (first use in this function)
+redis.c:624:13: error: ‘msetCommand’ undeclared (first use in this function)
+redis.c:625:15: error: ‘msetnxCommand’ undeclared (first use in this function)
+redis.c:626:18: error: ‘randomkeyCommand’ undeclared (first use in this function)
+redis.c:627:15: error: ‘selectCommand’ undeclared (first use in this function)
+redis.c:628:13: error: ‘moveCommand’ undeclared (first use in this function)
+redis.c:629:15: error: ‘renameCommand’ undeclared (first use in this function)
+redis.c:630:17: error: ‘renamenxCommand’ undeclared (first use in this function)
+redis.c:631:15: error: ‘expireCommand’ undeclared (first use in this function)
+redis.c:632:17: error: ‘expireatCommand’ undeclared (first use in this function)
+redis.c:633:13: error: ‘keysCommand’ undeclared (first use in this function)
+redis.c:634:15: error: ‘dbsizeCommand’ undeclared (first use in this function)
+redis.c:635:13: error: ‘authCommand’ undeclared (first use in this function)
+redis.c:636:13: error: ‘pingCommand’ undeclared (first use in this function)
+redis.c:637:13: error: ‘echoCommand’ undeclared (first use in this function)
+redis.c:638:17: error: ‘shutdownCommand’ undeclared (first use in this function)
+redis.c:639:17: error: ‘lastsaveCommand’ undeclared (first use in this function)
+redis.c:640:15: error: ‘gbsaveCommand’ undeclared (first use in this function)
+redis.c:641:13: error: ‘typeCommand’ undeclared (first use in this function)
+redis.c:642:14: error: ‘multiCommand’ undeclared (first use in this function)
+redis.c:643:16: error: ‘discardCommand’ undeclared (first use in this function)
+redis.c:644:16: error: ‘flushdbCommand’ undeclared (first use in this function)
+redis.c:645:13: error: ‘sortCommand’ undeclared (first use in this function)
+redis.c:646:13: error: ‘infoCommand’ undeclared (first use in this function)
+redis.c:647:16: error: ‘monitorCommand’ undeclared (first use in this function)
+redis.c:648:12: error: ‘ttlCommand’ undeclared (first use in this function)
+redis.c:649:16: error: ‘slaveofCommand’ undeclared (first use in this function)
+redis.c:650:15: error: ‘configCommand’ undeclared (first use in this function)
+redis.c:651:18: error: ‘subscribeCommand’ undeclared (first use in this function)
+redis.c:652:20: error: ‘unsubscribeCommand’ undeclared (first use in this function)
+redis.c:653:19: error: ‘psubscribeCommand’ undeclared (first use in this function)
+redis.c:654:21: error: ‘punsubscribeCommand’ undeclared (first use in this function)
+redis.c:655:16: error: ‘publishCommand’ undeclared (first use in this function)
+redis.c:662:12: error: invalid storage class for function ‘stringmatchlen’
+redis.c:784:12: error: invalid storage class for function ‘stringmatch’
+redis.c:794:18: error: invalid storage class for function ‘memtoll’
+redis.c:838:12: error: invalid storage class for function ‘ll2string’
+redis.c:859:13: error: invalid storage class for function ‘redisLog’
+redis.c:889:13: error: invalid storage class for function ‘dictVanillaFree’
+redis.c:895:13: error: invalid storage class for function ‘dictListDestructor’
+redis.c:901:12: error: invalid storage class for function ‘sdsDictKeyCompare’
+redis.c:913:13: error: invalid storage class for function ‘dictRedisObjectDestructor’
+redis.c:921:12: error: invalid storage class for function ‘dictObjKeyCompare’
+redis.c:928:21: error: invalid storage class for function ‘dictObjHash’
+redis.c:933:12: error: invalid storage class for function ‘dictEncObjKeyCompare’
+redis.c: In function ‘dictEncObjKeyCompare’:
+redis.c:943:8: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:944:8: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:951:21: error: invalid storage class for function ‘dictEncObjHash’
+redis.c: In function ‘dictEncObjHash’:
+redis.c:966:15: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:976:5: error: initializer element is not constant
+redis.c:976:5: error: (near initialization for ‘setDictType.hashFunction’)
+redis.c:979:5: error: initializer element is not constant
+redis.c:979:5: error: (near initialization for ‘setDictType.keyCompare’)
+redis.c:980:5: error: initializer element is not constant
+redis.c:980:5: error: (near initialization for ‘setDictType.keyDestructor’)
+redis.c:986:5: error: initializer element is not constant
+redis.c:986:5: error: (near initialization for ‘zsetDictType.hashFunction’)
+redis.c:989:5: error: initializer element is not constant
+redis.c:989:5: error: (near initialization for ‘zsetDictType.keyCompare’)
+redis.c:990:5: error: initializer element is not constant
+redis.c:990:5: error: (near initialization for ‘zsetDictType.keyDestructor’)
+redis.c:992:1: error: initializer element is not constant
+redis.c:992:1: error: (near initialization for ‘zsetDictType.valDestructor’)
+redis.c:996:5: error: initializer element is not constant
+redis.c:996:5: error: (near initialization for ‘dbDictType.hashFunction’)
+redis.c:999:5: error: initializer element is not constant
+redis.c:999:5: error: (near initialization for ‘dbDictType.keyCompare’)
+redis.c:1000:5: error: initializer element is not constant
+redis.c:1000:5: error: (near initialization for ‘dbDictType.keyDestructor’)
+redis.c:1002:1: error: initializer element is not constant
+redis.c:1002:1: error: (near initialization for ‘dbDictType.valDestructor’)
+redis.c:1006:5: error: initializer element is not constant
+redis.c:1006:5: error: (near initialization for ‘keyptrDictType.hashFunction’)
+redis.c:1009:5: error: initializer element is not constant
+redis.c:1009:5: error: (near initialization for ‘keyptrDictType.keyCompare’)
+redis.c:1010:5: error: initializer element is not constant
+redis.c:1010:5: error: (near initialization for ‘keyptrDictType.keyDestructor’)
+redis.c:1016:5: error: initializer element is not constant
+redis.c:1016:5: error: (near initialization for ‘hashDictType.hashFunction’)
+redis.c:1019:5: error: initializer element is not constant
+redis.c:1019:5: error: (near initialization for ‘hashDictType.keyCompare’)
+redis.c:1020:5: error: initializer element is not constant
+redis.c:1020:5: error: (near initialization for ‘hashDictType.keyDestructor’)
+redis.c:1022:1: error: initializer element is not constant
+redis.c:1022:1: error: (near initialization for ‘hashDictType.valDestructor’)
+redis.c:1028:5: error: initializer element is not constant
+redis.c:1028:5: error: (near initialization for ‘keylistDictType.hashFunction’)
+redis.c:1031:5: error: initializer element is not constant
+redis.c:1031:5: error: (near initialization for ‘keylistDictType.keyCompare’)
+redis.c:1032:5: error: initializer element is not constant
+redis.c:1032:5: error: (near initialization for ‘keylistDictType.keyDestructor’)
+redis.c:1034:1: error: initializer element is not constant
+redis.c:1034:1: error: (near initialization for ‘keylistDictType.valDestructor’)
+redis.c:1036:13: error: invalid storage class for function ‘version’
+redis.c:1045:13: error: invalid storage class for function ‘oom’
+redis.c:1052:13: error: invalid storage class for function ‘closeTimedoutClients’
+redis.c:1079:12: error: invalid storage class for function ‘htNeedsResize’
+redis.c:1090:13: error: invalid storage class for function ‘tryResizeHashTables’
+redis.c:1105:13: error: invalid storage class for function ‘incrementallyRehash’
+redis.c:1122:13: error: invalid storage class for function ‘updateDictResizePolicy’
+redis.c:1126:12: error: invalid storage class for function ‘serverCron’
+redis.c:1221:13: error: invalid storage class for function ‘beforeSleep’
+redis.c:1225:13: error: invalid storage class for function ‘createSharedObjects’
+redis.c: In function ‘createSharedObjects’:
+redis.c:1252:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1253:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1254:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1255:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1256:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1257:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1258:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1259:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1260:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1261:20: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1262:24: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1263:25: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1264:26: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1265:28: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1266:27: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1267:29: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1268:19: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1269:19: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:1276:13: error: invalid storage class for function ‘initServerConfig’
+redis.c:1310:13: error: invalid storage class for function ‘initServer’
+redis.c: In function ‘initServer’:
+redis.c:1342:5: error: ‘freePubsubPattern’ undeclared (first use in this function)
+redis.c:1342:5: warning: assignment from incompatible pointer type [enabled by default]
+redis.c:1343:5: error: ‘listMatchPubsubPattern’ undeclared (first use in this function)
+redis.c:1343:5: warning: assignment from incompatible pointer type [enabled by default]
+redis.c:1345:11: error: ‘struct redisServer’ has no member named ‘bgsavechildpid’
+redis.c:1354:9: error: ‘acceptHandler’ undeclared (first use in this function)
+redis.c:1354:9: warning: passing argument 4 of ‘aeCreateFileEvent’ from incompatible pointer type [enabled by default]
+ae.h:104:5: note: expected ‘void (*)(struct aeEventLoop *, int,  void *, int)’ but argument is of type ‘struct redisCommand *’
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:1359:18: error: invalid storage class for function ‘emptyDb’
+redis.c:1371:12: error: invalid storage class for function ‘yesnotoi’
+redis.c:1379:13: error: invalid storage class for function ‘loadServerConfig’
+redis.c:1513:13: error: invalid storage class for function ‘freeClientArgv’
+redis.c:1524:13: error: invalid storage class for function ‘freeClient’
+redis.c:1573:13: error: invalid storage class for function ‘glueReplyBuffersIfNeeded’
+redis.c:1600:13: error: invalid storage class for function ‘sendReplyToClient’
+redis.c:1666:29: error: invalid storage class for function ‘lookupCommand’
+redis.c:1676:13: error: invalid storage class for function ‘resetClient’
+redis.c:1683:13: error: invalid storage class for function ‘call’
+redis.c:1705:12: error: invalid storage class for function ‘processCommand’
+redis.c: In function ‘processCommand’:
+redis.c:1819:30: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1830:28: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c:1833:62: warning: comparison of distinct pointer types lacks a cast [enabled by default]
+redis.c:1856:19: warning: comparison of distinct pointer types lacks a cast [enabled by default]
+redis.c:1856:52: warning: comparison of distinct pointer types lacks a cast [enabled by default]
+redis.c:1857:19: warning: comparison of distinct pointer types lacks a cast [enabled by default]
+redis.c:1857:53: warning: comparison of distinct pointer types lacks a cast [enabled by default]
+redis.c:1864:48: error: ‘execCommand’ undeclared (first use in this function)
+redis.c:1864:45: warning: comparison of distinct pointer types lacks a cast [enabled by default]
+redis.c:1864:73: warning: comparison of distinct pointer types lacks a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:1876:13: error: invalid storage class for function ‘replicationFeedSlaves’
+redis.c:1948:12: error: invalid storage class for function ‘sdscatrepr’
+redis.c:1973:13: error: invalid storage class for function ‘replicationFeedMonitors’
+redis.c:2006:13: error: invalid storage class for function ‘processInputBuffer’
+redis.c: In function ‘processInputBuffer’:
+redis.c:2076:30: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:2088:13: error: invalid storage class for function ‘readQueryFromClient’
+redis.c:2118:12: error: invalid storage class for function ‘selectDb’
+redis.c:2125:14: error: invalid storage class for function ‘dupClientReplyValue’
+redis.c:2130:12: error: invalid storage class for function ‘listMatchObjects’
+redis.c:2134:21: error: invalid storage class for function ‘createClient’
+redis.c:2176:13: error: invalid storage class for function ‘addReply’
+redis.c: In function ‘addReply’:
+redis.c:2182:5: warning: passing argument 2 of ‘listAddNodeTail’ makes pointer from integer without a cast [enabled by default]
+adlist.h:76:7: note: expected ‘void *’ but argument is of type ‘int’
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:2185:13: error: invalid storage class for function ‘addReplySds’
+redis.c:2191:13: error: invalid storage class for function ‘addReplyDouble’
+redis.c:2199:13: error: invalid storage class for function ‘addReplyLongLong’
+redis.c:2217:13: error: invalid storage class for function ‘addReplyUlong’
+redis.c:2232:13: error: invalid storage class for function ‘addReplyBulkLen’
+redis.c:2258:13: error: invalid storage class for function ‘addReplyBulk’
+redis.c:2265:13: error: invalid storage class for function ‘addReplyBulkCString’
+redis.c: In function ‘addReplyBulkCString’:
+redis.c:2269:19: warning: initialization makes pointer from integer without a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:2275:13: error: invalid storage class for function ‘acceptHandler’
+redis.c:2314:14: error: invalid storage class for function ‘createObject’
+redis.c:2331:14: error: invalid storage class for function ‘createStringObject’
+redis.c:2335:14: error: invalid storage class for function ‘createStringObjectFromLongLong’
+redis.c:2352:14: error: invalid storage class for function ‘dupStringObject’
+redis.c:2357:14: error: invalid storage class for function ‘createListObject’
+redis.c:2364:14: error: invalid storage class for function ‘createSetObject’
+redis.c:2369:14: error: invalid storage class for function ‘createHashObject’
+redis.c:2379:14: error: invalid storage class for function ‘createZsetObject’
+redis.c: In function ‘createZsetObject’:
+redis.c:2383:13: warning: assignment makes pointer from integer without a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:2387:13: error: invalid storage class for function ‘freeStringObject’
+redis.c:2393:13: error: invalid storage class for function ‘freeListObject’
+redis.c:2397:13: error: invalid storage class for function ‘freeSetObject’
+redis.c:2401:13: error: invalid storage class for function ‘freeZsetObject’
+redis.c:2409:13: error: invalid storage class for function ‘freeHashObject’
+redis.c:2423:13: error: invalid storage class for function ‘incrRefCount’
+redis.c:2427:13: error: invalid storage class for function ‘decrRefCount’
+redis.c:2447:14: error: invalid storage class for function ‘lookupKey’
+redis.c:2458:14: error: invalid storage class for function ‘lookupKeyRead’
+redis.c:2463:14: error: invalid storage class for function ‘lookupKeyWrite’
+redis.c:2468:14: error: invalid storage class for function ‘lookupKeyReadOrReply’
+redis.c:2474:14: error: invalid storage class for function ‘lookupKeyWriteOrReply’
+redis.c:2480:12: error: invalid storage class for function ‘checkType’
+redis.c:2488:12: error: invalid storage class for function ‘deleteKey’
+redis.c:2510:12: error: invalid storage class for function ‘isStringRepresentableAsLong’
+redis.c:2527:14: error: invalid storage class for function ‘tryObjectEncoding’
+redis.c:2566:14: error: invalid storage class for function ‘getDecodedObject’
+redis.c:2592:12: error: invalid storage class for function ‘compareStringObjects’
+redis.c:2619:12: error: invalid storage class for function ‘equalStringObjects’
+redis.c:2627:15: error: invalid storage class for function ‘stringObjectLen’
+redis.c:2638:12: error: invalid storage class for function ‘getDoubleFromObject’
+redis.c:2660:12: error: invalid storage class for function ‘getDoubleFromObjectOrReply’
+redis.c:2675:12: error: invalid storage class for function ‘getLongLongFromObject’
+redis.c:2697:12: error: invalid storage class for function ‘getLongLongFromObjectOrReply’
+redis.c:2712:12: error: invalid storage class for function ‘getLongFromObjectOrReply’
+redis.c:2731:12: error: invalid storage class for function ‘prepareForShutdown’
+redis.c:2744:13: error: invalid storage class for function ‘authCommand’
+redis.c:2754:13: error: invalid storage class for function ‘pingCommand’
+redis.c:2758:13: error: invalid storage class for function ‘echoCommand’
+redis.c:2764:13: error: invalid storage class for function ‘setGenericCommand’
+redis.c:2801:13: error: invalid storage class for function ‘setCommand’
+redis.c:2805:13: error: invalid storage class for function ‘setnxCommand’
+redis.c:2809:13: error: invalid storage class for function ‘setexCommand’
+redis.c:2813:12: error: invalid storage class for function ‘getGenericCommand’
+redis.c:2828:13: error: invalid storage class for function ‘getCommand’
+redis.c:2834:13: error: invalid storage class for function ‘getsetCommand’
+redis.c:2846:13: error: invalid storage class for function ‘mgetCommand’
+redis.c:2864:13: error: invalid storage class for function ‘msetGenericCommand’
+redis.c:2903:13: error: invalid storage class for function ‘msetCommand’
+redis.c:2907:13: error: invalid storage class for function ‘msetnxCommand’
+redis.c:2911:13: error: invalid storage class for function ‘incrDecrCommand’
+redis.c:2935:13: error: invalid storage class for function ‘incrCommand’
+redis.c:2939:13: error: invalid storage class for function ‘decrCommand’
+redis.c:2943:13: error: invalid storage class for function ‘incrbyCommand’
+redis.c:2950:13: error: invalid storage class for function ‘decrbyCommand’
+redis.c:2957:13: error: invalid storage class for function ‘substrCommand’
+redis.c:2996:13: error: invalid storage class for function ‘delCommand’
+redis.c:3008:13: error: invalid storage class for function ‘existsCommand’
+redis.c:3017:13: error: invalid storage class for function ‘selectCommand’
+redis.c:3027:13: error: invalid storage class for function ‘randomkeyCommand’
+redis.c:3045:13: error: invalid storage class for function ‘keysCommand’
+redis.c:3072:13: error: invalid storage class for function ‘dbsizeCommand’
+redis.c:3077:13: error: invalid storage class for function ‘lastsaveCommand’
+redis.c:3082:13: error: invalid storage class for function ‘typeCommand’
+redis.c:3104:13: error: invalid storage class for function ‘shutdownCommand’
+redis.c:3110:13: error: invalid storage class for function ‘renameGenericCommand’
+redis.c:3139:13: error: invalid storage class for function ‘renameCommand’
+redis.c:3143:13: error: invalid storage class for function ‘renamenxCommand’
+redis.c:3147:13: error: invalid storage class for function ‘moveCommand’
+redis.c:3192:13: error: invalid storage class for function ‘pushGenericCommand’
+redis.c:3233:13: error: invalid storage class for function ‘lpushCommand’
+redis.c:3237:13: error: invalid storage class for function ‘rpushCommand’
+redis.c:3241:13: error: invalid storage class for function ‘llenCommand’
+redis.c:3252:13: error: invalid storage class for function ‘lindexCommand’
+redis.c:3271:13: error: invalid storage class for function ‘lsetCommand’
+redis.c:3295:13: error: invalid storage class for function ‘popGenericCommand’
+redis.c:3320:13: error: invalid storage class for function ‘lpopCommand’
+redis.c:3324:13: error: invalid storage class for function ‘rpopCommand’
+redis.c:3328:13: error: invalid storage class for function ‘lrangeCommand’
+redis.c:3368:13: error: invalid storage class for function ‘ltrimCommand’
+redis.c:3413:13: error: invalid storage class for function ‘lremCommand’
+redis.c:3461:13: error: invalid storage class for function ‘rpoplpushcommand’
+redis.c:3509:13: error: invalid storage class for function ‘saddCommand’
+redis.c:3532:13: error: invalid storage class for function ‘sremCommand’
+redis.c:3548:13: error: invalid storage class for function ‘smoveCommand’
+redis.c:3585:13: error: invalid storage class for function ‘sismemberCommand’
+redis.c:3597:13: error: invalid storage class for function ‘scardCommand’
+redis.c:3608:13: error: invalid storage class for function ‘spopCommand’
+redis.c:3629:13: error: invalid storage class for function ‘srandmemberCommand’
+redis.c:3646:12: error: invalid storage class for function ‘qsortCompareSetsByCardinality’
+redis.c:3652:13: error: invalid storage class for function ‘sinterGenericCommand’
+redis.c:3744:13: error: invalid storage class for function ‘sinterCommand’
+redis.c:3748:13: error: invalid storage class for function ‘sinterstoreCommand’
+redis.c:3756:13: error: invalid storage class for function ‘sunionDiffGenericCommand’
+redis.c:3845:13: error: invalid storage class for function ‘sunionCommand’
+redis.c:3849:13: error: invalid storage class for function ‘sunionstoreCommand’
+redis.c:3853:13: error: invalid storage class for function ‘sdiffCommand’
+redis.c:3857:13: error: invalid storage class for function ‘sdiffstoreCommand’
+redis.c:3880:23: error: invalid storage class for function ‘zslCreateNode’
+redis.c:3893:19: error: invalid storage class for function ‘zslCreate’
+redis.c:3913:13: error: invalid storage class for function ‘zslFreeNode’
+redis.c:3920:13: error: invalid storage class for function ‘zslFree’
+redis.c:3934:12: error: invalid storage class for function ‘zslRandomLevel’
+redis.c:3941:13: error: invalid storage class for function ‘zslInsert’
+redis.c:4024:12: error: invalid storage class for function ‘zslDelete’
+redis.c:4054:22: error: invalid storage class for function ‘zslDeleteRangeByScore’
+redis.c:4081:22: error: invalid storage class for function ‘zslDeleteRangeByRank’
+redis.c:4111:23: error: invalid storage class for function ‘zslFirstWithScore’
+redis.c:4129:22: error: invalid storage class for function ‘zslGetRank’
+redis.c:4177:13: error: invalid storage class for function ‘zaddGenericCommand’
+redis.c:4264:13: error: invalid storage class for function ‘zaddCommand’
+redis.c:4270:13: error: invalid storage class for function ‘zincrbyCommand’
+redis.c:4276:13: error: invalid storage class for function ‘zremCommand’
+redis.c:4305:13: error: invalid storage class for function ‘zremrangebyscoreCommand’
+redis.c:4326:13: error: invalid storage class for function ‘zremrangebyrankCommand’
+redis.c:4369:12: error: invalid storage class for function ‘qsortCompareZsetopsrcByCardinality’
+redis.c:4381:20: error: invalid storage class for function ‘zunionInterAggregate’
+redis.c:4398:13: error: invalid storage class for function ‘zunionInterGenericCommand’
+redis.c:4564:13: error: invalid storage class for function ‘zunionstoreCommand’
+redis.c:4568:13: error: invalid storage class for function ‘zinterstoreCommand’
+redis.c:4572:13: error: invalid storage class for function ‘zrangeGenericCommand’
+redis.c:4635:13: error: invalid storage class for function ‘zrangeCommand’
+redis.c:4639:13: error: invalid storage class for function ‘zrevrangeCommand’
+redis.c:4645:13: error: invalid storage class for function ‘genericZrangebyscoreCommand’
+redis.c:4759:13: error: invalid storage class for function ‘zrangebyscoreCommand’
+redis.c:4763:13: error: invalid storage class for function ‘zcountCommand’
+redis.c:4767:13: error: invalid storage class for function ‘zcardCommand’
+redis.c:4778:13: error: invalid storage class for function ‘zscoreCommand’
+redis.c:4797:13: error: invalid storage class for function ‘zrankGenericCommand’
+redis.c:4829:13: error: invalid storage class for function ‘zrankCommand’
+redis.c:4833:13: error: invalid storage class for function ‘zrevrankCommand’
+redis.c:4844:13: error: invalid storage class for function ‘hashTryConversion’
+redis.c:4859:13: error: invalid storage class for function ‘hashTryObjectEncoding’
+redis.c:4869:14: error: invalid storage class for function ‘hashGet’
+redis.c:4891:12: error: invalid storage class for function ‘hashExists’
+redis.c:4909:12: error: invalid storage class for function ‘hashSet’
+redis.c:4938:12: error: invalid storage class for function ‘hashDelete’
+redis.c:4953:22: error: invalid storage class for function ‘hashLength’
+redis.c:4972:22: error: invalid storage class for function ‘hashInitIterator’
+redis.c:4985:13: error: invalid storage class for function ‘hashReleaseIterator’
+redis.c:4994:12: error: invalid storage class for function ‘hashNext’
+redis.c:5006:14: error: invalid storage class for function ‘hashCurrent’
+redis.c:5025:14: error: invalid storage class for function ‘hashLookupWriteOrCreate’
+redis.c:5041:13: error: invalid storage class for function ‘hsetCommand’
+redis.c:5053:13: error: invalid storage class for function ‘hsetnxCommand’
+redis.c:5068:13: error: invalid storage class for function ‘hmsetCommand’
+redis.c:5087:13: error: invalid storage class for function ‘hincrbyCommand’
+redis.c:5113:13: error: invalid storage class for function ‘hgetCommand’
+redis.c:5126:13: error: invalid storage class for function ‘hmgetCommand’
+redis.c:5149:13: error: invalid storage class for function ‘hdelCommand’
+redis.c:5163:13: error: invalid storage class for function ‘hlenCommand’
+redis.c:5171:13: error: invalid storage class for function ‘genericHgetallCommand’
+redis.c:5203:13: error: invalid storage class for function ‘hkeysCommand’
+redis.c:5207:13: error: invalid storage class for function ‘hvalsCommand’
+redis.c:5211:13: error: invalid storage class for function ‘hgetallCommand’
+redis.c:5215:13: error: invalid storage class for function ‘hexistsCommand’
+redis.c:5223:13: error: invalid storage class for function ‘convertToRealHash’
+redis.c:5246:13: error: invalid storage class for function ‘flushdbCommand’
+redis.c:5253:28: error: invalid storage class for function ‘createSortOperation’
+redis.c:5264:14: error: invalid storage class for function ‘lookupKeyByPattern’
+redis.c:5343:12: error: invalid storage class for function ‘sortCompare’
+redis.c:5381:13: error: invalid storage class for function ‘sortCommand’
+redis.c:5638:13: error: invalid storage class for function ‘bytesToHuman’
+redis.c:5660:12: error: invalid storage class for function ‘genRedisInfoString’
+redis.c:5741:13: error: invalid storage class for function ‘infoCommand’
+redis.c:5749:13: error: invalid storage class for function ‘monitorCommand’
+redis.c:5760:12: error: invalid storage class for function ‘removeExpire’
+redis.c:5768:12: error: invalid storage class for function ‘setExpire’
+redis.c:5779:15: error: invalid storage class for function ‘getExpire’
+redis.c:5789:12: error: invalid storage class for function ‘expireIfNeeded’
+redis.c:5807:12: error: invalid storage class for function ‘deleteIfVolatile’
+redis.c:5821:13: error: invalid storage class for function ‘expireGenericCommand’
+redis.c:5850:13: error: invalid storage class for function ‘expireCommand’
+redis.c:5854:13: error: invalid storage class for function ‘expireatCommand’
+redis.c:5858:13: error: invalid storage class for function ‘ttlCommand’
+redis.c:5873:13: error: invalid storage class for function ‘initClientMultiState’
+redis.c:5879:13: error: invalid storage class for function ‘freeClientMultiState’
+redis.c:5894:13: error: invalid storage class for function ‘queueMultiCommand’
+redis.c:5910:13: error: invalid storage class for function ‘multiCommand’
+redis.c:5915:13: error: invalid storage class for function ‘discardCommand’
+redis.c:5929:13: error: invalid storage class for function ‘execCommandReplicateMulti’
+redis.c:5939:13: error: invalid storage class for function ‘execCommand’
+redis.c:6008:13: error: invalid storage class for function ‘blockForKeys’
+redis.c:6058:13: error: invalid storage class for function ‘unblockClientWaitingData’
+redis.c:6099:12: error: invalid storage class for function ‘handleClientsWaitingListPush’
+redis.c:6120:13: error: invalid storage class for function ‘blockingPopGenericCommand’
+redis.c:6189:13: error: invalid storage class for function ‘blpopCommand’
+redis.c:6193:13: error: invalid storage class for function ‘brpopCommand’
+redis.c:6199:12: error: invalid storage class for function ‘syncWrite’
+redis.c:6219:12: error: invalid storage class for function ‘syncRead’
+redis.c:6240:12: error: invalid storage class for function ‘syncReadLine’
+redis.c:6261:13: error: invalid storage class for function ‘sendBulkToSlave’
+redis.c:6315:13: error: invalid storage class for function ‘slaveofCommand’
+redis.c:6343:12: error: invalid storage class for function ‘tryFreeOneObjectFromFreelist’
+redis.c:6368:13: error: invalid storage class for function ‘freeMemoryIfNeeded’
+redis.c:6408:13: error: invalid storage class for function ‘configSetCommand’
+redis.c:6448:13: error: invalid storage class for function ‘configGetCommand’
+redis.c:6492:13: error: invalid storage class for function ‘configCommand’
+redis.c:6520:13: error: invalid storage class for function ‘freePubsubPattern’
+redis.c:6527:12: error: invalid storage class for function ‘listMatchPubsubPattern’
+redis.c:6536:12: error: invalid storage class for function ‘pubsubSubscribeChannel’
+redis.c:6566:12: error: invalid storage class for function ‘pubsubUnsubscribeChannel’
+redis.c:6605:12: error: invalid storage class for function ‘pubsubSubscribePattern’
+redis.c:6628:12: error: invalid storage class for function ‘pubsubUnsubscribePattern’
+redis.c:6656:12: error: invalid storage class for function ‘pubsubUnsubscribeAllChannels’
+redis.c:6672:12: error: invalid storage class for function ‘pubsubUnsubscribeAllPatterns’
+redis.c:6687:12: error: invalid storage class for function ‘pubsubPublishMessage’
+redis.c:6735:13: error: invalid storage class for function ‘subscribeCommand’
+redis.c:6742:13: error: invalid storage class for function ‘unsubscribeCommand’
+redis.c:6754:13: error: invalid storage class for function ‘psubscribeCommand’
+redis.c:6761:13: error: invalid storage class for function ‘punsubscribeCommand’
+redis.c:6773:13: error: invalid storage class for function ‘publishCommand’
+redis.c:6786:13: error: invalid storage class for function ‘xorDigest’
+redis.c:6799:13: error: invalid storage class for function ‘xorObjectDigest’
+redis.c:6819:13: error: invalid storage class for function ‘mixDigest’
+redis.c:6829:13: error: invalid storage class for function ‘mixObjectDigest’
+redis.c:6841:13: error: invalid storage class for function ‘computeDatasetDigest’
+redis.c:6950:13: error: invalid storage class for function ‘_redisAssert’
+redis.c:6959:13: error: invalid storage class for function ‘_redisPanic’
+redis.c:6992:13: error: invalid storage class for function ‘version’
+redis.c:6997:13: error: invalid storage class for function ‘usage’
+redis.c:7033:14: error: invalid storage class for function ‘findFuncName’
+redis.c:7035:14: error: invalid storage class for function ‘getMcontextEip’
+redis.c:7061:13: error: invalid storage class for function ‘segvHandler’
+redis.c: In function ‘segvHandler’:
+redis.c:7085:20: warning: initialization makes pointer from integer without a cast [enabled by default]
+redis.c: In function ‘rdbSaveBackground’:
+redis.c:7098:13: error: invalid storage class for function ‘sigtermHandler’
+redis.c:7105:13: error: invalid storage class for function ‘setupSigSegvAction’
+In file included from redis.c:7125:0:
+staticsymbols.h:3:1: error: initializer element is not constant
+staticsymbols.h:3:1: error: (near initialization for ‘symsTable[0].pointer’)
+staticsymbols.h:4:1: error: initializer element is not constant
+staticsymbols.h:4:1: error: (near initialization for ‘symsTable[1].pointer’)
+staticsymbols.h:5:1: error: initializer element is not constant
+staticsymbols.h:5:1: error: (near initialization for ‘symsTable[2].pointer’)
+staticsymbols.h:6:1: error: initializer element is not constant
+staticsymbols.h:6:1: error: (near initialization for ‘symsTable[3].pointer’)
+staticsymbols.h:7:1: error: initializer element is not constant
+staticsymbols.h:7:1: error: (near initialization for ‘symsTable[4].pointer’)
+staticsymbols.h:8:1: error: initializer element is not constant
+staticsymbols.h:8:1: error: (near initialization for ‘symsTable[5].pointer’)
+staticsymbols.h:9:1: error: initializer element is not constant
+staticsymbols.h:9:1: error: (near initialization for ‘symsTable[6].pointer’)
+staticsymbols.h:10:1: error: initializer element is not constant
+staticsymbols.h:10:1: error: (near initialization for ‘symsTable[7].pointer’)
+staticsymbols.h:11:1: error: initializer element is not constant
+staticsymbols.h:11:1: error: (near initialization for ‘symsTable[8].pointer’)
+staticsymbols.h:12:1: error: initializer element is not constant
+staticsymbols.h:12:1: error: (near initialization for ‘symsTable[9].pointer’)
+staticsymbols.h:13:1: error: initializer element is not constant
+staticsymbols.h:13:1: error: (near initialization for ‘symsTable[10].pointer’)
+staticsymbols.h:17:1: error: initializer element is not constant
+staticsymbols.h:17:1: error: (near initialization for ‘symsTable[11].pointer’)
+staticsymbols.h:18:1: error: initializer element is not constant
+staticsymbols.h:18:1: error: (near initialization for ‘symsTable[12].pointer’)
+staticsymbols.h:22:1: error: initializer element is not constant
+staticsymbols.h:22:1: error: (near initialization for ‘symsTable[13].pointer’)
+staticsymbols.h:23:1: error: initializer element is not constant
+staticsymbols.h:23:1: error: (near initialization for ‘symsTable[14].pointer’)
+staticsymbols.h:24:1: error: initializer element is not constant
+staticsymbols.h:24:1: error: (near initialization for ‘symsTable[15].pointer’)
+staticsymbols.h:25:1: error: initializer element is not constant
+staticsymbols.h:25:1: error: (near initialization for ‘symsTable[16].pointer’)
+staticsymbols.h:26:1: error: initializer element is not constant
+staticsymbols.h:26:1: error: (near initialization for ‘symsTable[17].pointer’)
+staticsymbols.h:27:1: error: initializer element is not constant
+staticsymbols.h:27:1: error: (near initialization for ‘symsTable[18].pointer’)
+staticsymbols.h:30:1: error: initializer element is not constant
+staticsymbols.h:30:1: error: (near initialization for ‘symsTable[19].pointer’)
+staticsymbols.h:31:1: error: initializer element is not constant
+staticsymbols.h:31:1: error: (near initialization for ‘symsTable[20].pointer’)
+staticsymbols.h:32:1: error: initializer element is not constant
+staticsymbols.h:32:1: error: (near initialization for ‘symsTable[21].pointer’)
+staticsymbols.h:33:1: error: initializer element is not constant
+staticsymbols.h:33:1: error: (near initialization for ‘symsTable[22].pointer’)
+staticsymbols.h:35:1: error: initializer element is not constant
+staticsymbols.h:35:1: error: (near initialization for ‘symsTable[23].pointer’)
+staticsymbols.h:36:1: error: initializer element is not constant
+staticsymbols.h:36:1: error: (near initialization for ‘symsTable[24].pointer’)
+staticsymbols.h:37:1: error: initializer element is not constant
+staticsymbols.h:37:1: error: (near initialization for ‘symsTable[25].pointer’)
+staticsymbols.h:38:1: error: initializer element is not constant
+staticsymbols.h:38:1: error: (near initialization for ‘symsTable[26].pointer’)
+staticsymbols.h:39:1: error: initializer element is not constant
+staticsymbols.h:39:1: error: (near initialization for ‘symsTable[27].pointer’)
+staticsymbols.h:40:1: error: initializer element is not constant
+staticsymbols.h:40:1: error: (near initialization for ‘symsTable[28].pointer’)
+staticsymbols.h:41:1: error: initializer element is not constant
+staticsymbols.h:41:1: error: (near initialization for ‘symsTable[29].pointer’)
+staticsymbols.h:42:1: error: initializer element is not constant
+staticsymbols.h:42:1: error: (near initialization for ‘symsTable[30].pointer’)
+staticsymbols.h:43:1: error: initializer element is not constant
+staticsymbols.h:43:1: error: (near initialization for ‘symsTable[31].pointer’)
+staticsymbols.h:44:1: error: initializer element is not constant
+staticsymbols.h:44:1: error: (near initialization for ‘symsTable[32].pointer’)
+staticsymbols.h:45:1: error: initializer element is not constant
+staticsymbols.h:45:1: error: (near initialization for ‘symsTable[33].pointer’)
+staticsymbols.h:46:1: error: initializer element is not constant
+staticsymbols.h:46:1: error: (near initialization for ‘symsTable[34].pointer’)
+staticsymbols.h:47:1: error: initializer element is not constant
+staticsymbols.h:47:1: error: (near initialization for ‘symsTable[35].pointer’)
+staticsymbols.h:48:1: error: initializer element is not constant
+staticsymbols.h:48:1: error: (near initialization for ‘symsTable[36].pointer’)
+staticsymbols.h:50:1: error: initializer element is not constant
+staticsymbols.h:50:1: error: (near initialization for ‘symsTable[37].pointer’)
+staticsymbols.h:52:1: error: initializer element is not constant
+staticsymbols.h:52:1: error: (near initialization for ‘symsTable[38].pointer’)
+staticsymbols.h:53:1: error: initializer element is not constant
+staticsymbols.h:53:1: error: (near initialization for ‘symsTable[39].pointer’)
+staticsymbols.h:54:1: error: initializer element is not constant
+staticsymbols.h:54:1: error: (near initialization for ‘symsTable[40].pointer’)
+staticsymbols.h:55:1: error: initializer element is not constant
+staticsymbols.h:55:1: error: (near initialization for ‘symsTable[41].pointer’)
+staticsymbols.h:57:1: error: initializer element is not constant
+staticsymbols.h:57:1: error: (near initialization for ‘symsTable[42].pointer’)
+staticsymbols.h:58:1: error: initializer element is not constant
+staticsymbols.h:58:1: error: (near initialization for ‘symsTable[43].pointer’)
+staticsymbols.h:59:1: error: initializer element is not constant
+staticsymbols.h:59:1: error: (near initialization for ‘symsTable[44].pointer’)
+staticsymbols.h:60:1: error: initializer element is not constant
+staticsymbols.h:60:1: error: (near initialization for ‘symsTable[45].pointer’)
+staticsymbols.h:61:1: error: initializer element is not constant
+staticsymbols.h:61:1: error: (near initialization for ‘symsTable[46].pointer’)
+staticsymbols.h:62:1: error: initializer element is not constant
+staticsymbols.h:62:1: error: (near initialization for ‘symsTable[47].pointer’)
+staticsymbols.h:63:1: error: initializer element is not constant
+staticsymbols.h:63:1: error: (near initialization for ‘symsTable[48].pointer’)
+staticsymbols.h:64:1: error: initializer element is not constant
+staticsymbols.h:64:1: error: (near initialization for ‘symsTable[49].pointer’)
+staticsymbols.h:66:1: error: initializer element is not constant
+staticsymbols.h:66:1: error: (near initialization for ‘symsTable[50].pointer’)
+staticsymbols.h:67:1: error: initializer element is not constant
+staticsymbols.h:67:1: error: (near initialization for ‘symsTable[51].pointer’)
+staticsymbols.h:68:1: error: initializer element is not constant
+staticsymbols.h:68:1: error: (near initialization for ‘symsTable[52].pointer’)
+staticsymbols.h:69:1: error: initializer element is not constant
+staticsymbols.h:69:1: error: (near initialization for ‘symsTable[53].pointer’)
+staticsymbols.h:71:1: error: initializer element is not constant
+staticsymbols.h:71:1: error: (near initialization for ‘symsTable[54].pointer’)
+staticsymbols.h:72:1: error: initializer element is not constant
+staticsymbols.h:72:1: error: (near initialization for ‘symsTable[55].pointer’)
+staticsymbols.h:73:1: error: initializer element is not constant
+staticsymbols.h:73:1: error: (near initialization for ‘symsTable[56].pointer’)
+staticsymbols.h:74:1: error: initializer element is not constant
+staticsymbols.h:74:1: error: (near initialization for ‘symsTable[57].pointer’)
+staticsymbols.h:75:1: error: initializer element is not constant
+staticsymbols.h:75:1: error: (near initialization for ‘symsTable[58].pointer’)
+staticsymbols.h:76:1: error: initializer element is not constant
+staticsymbols.h:76:1: error: (near initialization for ‘symsTable[59].pointer’)
+staticsymbols.h:77:1: error: initializer element is not constant
+staticsymbols.h:77:1: error: (near initialization for ‘symsTable[60].pointer’)
+staticsymbols.h:79:32: error: ‘findFuncName’ undeclared (first use in this function)
+staticsymbols.h:79:1: error: initializer element is not constant
+staticsymbols.h:79:1: error: (near initialization for ‘symsTable[61].pointer’)
+staticsymbols.h:82:1: error: initializer element is not constant
+staticsymbols.h:82:1: error: (near initialization for ‘symsTable[62].pointer’)
+staticsymbols.h:83:1: error: initializer element is not constant
+staticsymbols.h:83:1: error: (near initialization for ‘symsTable[63].pointer’)
+staticsymbols.h:84:1: error: initializer element is not constant
+staticsymbols.h:84:1: error: (near initialization for ‘symsTable[64].pointer’)
+staticsymbols.h:85:1: error: initializer element is not constant
+staticsymbols.h:85:1: error: (near initialization for ‘symsTable[65].pointer’)
+staticsymbols.h:87:1: error: initializer element is not constant
+staticsymbols.h:87:1: error: (near initialization for ‘symsTable[66].pointer’)
+staticsymbols.h:89:1: error: initializer element is not constant
+staticsymbols.h:89:1: error: (near initialization for ‘symsTable[67].pointer’)
+staticsymbols.h:90:1: error: initializer element is not constant
+staticsymbols.h:90:1: error: (near initialization for ‘symsTable[68].pointer’)
+staticsymbols.h:91:1: error: initializer element is not constant
+staticsymbols.h:91:1: error: (near initialization for ‘symsTable[69].pointer’)
+staticsymbols.h:92:1: error: initializer element is not constant
+staticsymbols.h:92:1: error: (near initialization for ‘symsTable[70].pointer’)
+staticsymbols.h:93:1: error: initializer element is not constant
+staticsymbols.h:93:1: error: (near initialization for ‘symsTable[71].pointer’)
+staticsymbols.h:94:1: error: initializer element is not constant
+staticsymbols.h:94:1: error: (near initialization for ‘symsTable[72].pointer’)
+staticsymbols.h:99:1: error: initializer element is not constant
+staticsymbols.h:99:1: error: (near initialization for ‘symsTable[73].pointer’)
+staticsymbols.h:100:1: error: initializer element is not constant
+staticsymbols.h:100:1: error: (near initialization for ‘symsTable[74].pointer’)
+staticsymbols.h:101:1: error: initializer element is not constant
+staticsymbols.h:101:1: error: (near initialization for ‘symsTable[75].pointer’)
+staticsymbols.h:102:1: error: initializer element is not constant
+staticsymbols.h:102:1: error: (near initialization for ‘symsTable[76].pointer’)
+staticsymbols.h:103:1: error: initializer element is not constant
+staticsymbols.h:103:1: error: (near initialization for ‘symsTable[77].pointer’)
+staticsymbols.h:104:1: error: initializer element is not constant
+staticsymbols.h:104:1: error: (near initialization for ‘symsTable[78].pointer’)
+staticsymbols.h:105:1: error: initializer element is not constant
+staticsymbols.h:105:1: error: (near initialization for ‘symsTable[79].pointer’)
+staticsymbols.h:106:1: error: initializer element is not constant
+staticsymbols.h:106:1: error: (near initialization for ‘symsTable[80].pointer’)
+staticsymbols.h:107:1: error: initializer element is not constant
+staticsymbols.h:107:1: error: (near initialization for ‘symsTable[81].pointer’)
+staticsymbols.h:108:1: error: initializer element is not constant
+staticsymbols.h:108:1: error: (near initialization for ‘symsTable[82].pointer’)
+staticsymbols.h:109:1: error: initializer element is not constant
+staticsymbols.h:109:1: error: (near initialization for ‘symsTable[83].pointer’)
+staticsymbols.h:110:1: error: initializer element is not constant
+staticsymbols.h:110:1: error: (near initialization for ‘symsTable[84].pointer’)
+staticsymbols.h:111:1: error: initializer element is not constant
+staticsymbols.h:111:1: error: (near initialization for ‘symsTable[85].pointer’)
+staticsymbols.h:112:1: error: initializer element is not constant
+staticsymbols.h:112:1: error: (near initialization for ‘symsTable[86].pointer’)
+staticsymbols.h:113:1: error: initializer element is not constant
+staticsymbols.h:113:1: error: (near initialization for ‘symsTable[87].pointer’)
+staticsymbols.h:115:1: error: initializer element is not constant
+staticsymbols.h:115:1: error: (near initialization for ‘symsTable[88].pointer’)
+staticsymbols.h:116:1: error: initializer element is not constant
+staticsymbols.h:116:1: error: (near initialization for ‘symsTable[89].pointer’)
+staticsymbols.h:117:1: error: initializer element is not constant
+staticsymbols.h:117:1: error: (near initialization for ‘symsTable[90].pointer’)
+staticsymbols.h:118:1: error: initializer element is not constant
+staticsymbols.h:118:1: error: (near initialization for ‘symsTable[91].pointer’)
+staticsymbols.h:119:1: error: initializer element is not constant
+staticsymbols.h:119:1: error: (near initialization for ‘symsTable[92].pointer’)
+staticsymbols.h:120:1: error: initializer element is not constant
+staticsymbols.h:120:1: error: (near initialization for ‘symsTable[93].pointer’)
+staticsymbols.h:121:1: error: initializer element is not constant
+staticsymbols.h:121:1: error: (near initialization for ‘symsTable[94].pointer’)
+staticsymbols.h:122:1: error: initializer element is not constant
+staticsymbols.h:122:1: error: (near initialization for ‘symsTable[95].pointer’)
+staticsymbols.h:123:1: error: initializer element is not constant
+staticsymbols.h:123:1: error: (near initialization for ‘symsTable[96].pointer’)
+staticsymbols.h:124:1: error: initializer element is not constant
+staticsymbols.h:124:1: error: (near initialization for ‘symsTable[97].pointer’)
+staticsymbols.h:125:1: error: initializer element is not constant
+staticsymbols.h:125:1: error: (near initialization for ‘symsTable[98].pointer’)
+staticsymbols.h:126:1: error: initializer element is not constant
+staticsymbols.h:126:1: error: (near initialization for ‘symsTable[99].pointer’)
+staticsymbols.h:127:1: error: initializer element is not constant
+staticsymbols.h:127:1: error: (near initialization for ‘symsTable[100].pointer’)
+staticsymbols.h:128:1: error: initializer element is not constant
+staticsymbols.h:128:1: error: (near initialization for ‘symsTable[101].pointer’)
+staticsymbols.h:129:1: error: initializer element is not constant
+staticsymbols.h:129:1: error: (near initialization for ‘symsTable[102].pointer’)
+staticsymbols.h:130:1: error: initializer element is not constant
+staticsymbols.h:130:1: error: (near initialization for ‘symsTable[103].pointer’)
+staticsymbols.h:131:1: error: initializer element is not constant
+staticsymbols.h:131:1: error: (near initialization for ‘symsTable[104].pointer’)
+staticsymbols.h:132:1: error: initializer element is not constant
+staticsymbols.h:132:1: error: (near initialization for ‘symsTable[105].pointer’)
+staticsymbols.h:133:1: error: initializer element is not constant
+staticsymbols.h:133:1: error: (near initialization for ‘symsTable[106].pointer’)
+staticsymbols.h:134:1: error: initializer element is not constant
+staticsymbols.h:134:1: error: (near initialization for ‘symsTable[107].pointer’)
+staticsymbols.h:135:1: error: initializer element is not constant
+staticsymbols.h:135:1: error: (near initialization for ‘symsTable[108].pointer’)
+staticsymbols.h:136:1: error: initializer element is not constant
+staticsymbols.h:136:1: error: (near initialization for ‘symsTable[109].pointer’)
+staticsymbols.h:137:1: error: initializer element is not constant
+staticsymbols.h:137:1: error: (near initialization for ‘symsTable[110].pointer’)
+staticsymbols.h:138:1: error: initializer element is not constant
+staticsymbols.h:138:1: error: (near initialization for ‘symsTable[111].pointer’)
+staticsymbols.h:139:1: error: initializer element is not constant
+staticsymbols.h:139:1: error: (near initialization for ‘symsTable[112].pointer’)
+staticsymbols.h:140:1: error: initializer element is not constant
+staticsymbols.h:140:1: error: (near initialization for ‘symsTable[113].pointer’)
+staticsymbols.h:141:1: error: initializer element is not constant
+staticsymbols.h:141:1: error: (near initialization for ‘symsTable[114].pointer’)
+staticsymbols.h:142:1: error: initializer element is not constant
+staticsymbols.h:142:1: error: (near initialization for ‘symsTable[115].pointer’)
+staticsymbols.h:143:1: error: initializer element is not constant
+staticsymbols.h:143:1: error: (near initialization for ‘symsTable[116].pointer’)
+staticsymbols.h:144:1: error: initializer element is not constant
+staticsymbols.h:144:1: error: (near initialization for ‘symsTable[117].pointer’)
+staticsymbols.h:145:1: error: initializer element is not constant
+staticsymbols.h:145:1: error: (near initialization for ‘symsTable[118].pointer’)
+staticsymbols.h:146:1: error: initializer element is not constant
+staticsymbols.h:146:1: error: (near initialization for ‘symsTable[119].pointer’)
+staticsymbols.h:147:1: error: initializer element is not constant
+staticsymbols.h:147:1: error: (near initialization for ‘symsTable[120].pointer’)
+staticsymbols.h:148:1: error: initializer element is not constant
+staticsymbols.h:148:1: error: (near initialization for ‘symsTable[121].pointer’)
+staticsymbols.h:149:1: error: initializer element is not constant
+staticsymbols.h:149:1: error: (near initialization for ‘symsTable[122].pointer’)
+staticsymbols.h:150:1: error: initializer element is not constant
+staticsymbols.h:150:1: error: (near initialization for ‘symsTable[123].pointer’)
+staticsymbols.h:151:1: error: initializer element is not constant
+staticsymbols.h:151:1: error: (near initialization for ‘symsTable[124].pointer’)
+staticsymbols.h:152:1: error: initializer element is not constant
+staticsymbols.h:152:1: error: (near initialization for ‘symsTable[125].pointer’)
+staticsymbols.h:153:1: error: initializer element is not constant
+staticsymbols.h:153:1: error: (near initialization for ‘symsTable[126].pointer’)
+staticsymbols.h:154:1: error: initializer element is not constant
+staticsymbols.h:154:1: error: (near initialization for ‘symsTable[127].pointer’)
+staticsymbols.h:155:1: error: initializer element is not constant
+staticsymbols.h:155:1: error: (near initialization for ‘symsTable[128].pointer’)
+staticsymbols.h:156:1: error: initializer element is not constant
+staticsymbols.h:156:1: error: (near initialization for ‘symsTable[129].pointer’)
+staticsymbols.h:157:1: error: initializer element is not constant
+staticsymbols.h:157:1: error: (near initialization for ‘symsTable[130].pointer’)
+staticsymbols.h:159:1: error: initializer element is not constant
+staticsymbols.h:159:1: error: (near initialization for ‘symsTable[131].pointer’)
+staticsymbols.h:160:1: error: initializer element is not constant
+staticsymbols.h:160:1: error: (near initialization for ‘symsTable[132].pointer’)
+staticsymbols.h:161:1: error: initializer element is not constant
+staticsymbols.h:161:1: error: (near initialization for ‘symsTable[133].pointer’)
+staticsymbols.h:162:1: error: initializer element is not constant
+staticsymbols.h:162:1: error: (near initialization for ‘symsTable[134].pointer’)
+staticsymbols.h:163:1: error: initializer element is not constant
+staticsymbols.h:163:1: error: (near initialization for ‘symsTable[135].pointer’)
+staticsymbols.h:164:1: error: initializer element is not constant
+staticsymbols.h:164:1: error: (near initialization for ‘symsTable[136].pointer’)
+staticsymbols.h:165:1: error: initializer element is not constant
+staticsymbols.h:165:1: error: (near initialization for ‘symsTable[137].pointer’)
+staticsymbols.h:166:1: error: initializer element is not constant
+staticsymbols.h:166:1: error: (near initialization for ‘symsTable[138].pointer’)
+staticsymbols.h:167:1: error: initializer element is not constant
+staticsymbols.h:167:1: error: (near initialization for ‘symsTable[139].pointer’)
+staticsymbols.h:168:1: error: initializer element is not constant
+staticsymbols.h:168:1: error: (near initialization for ‘symsTable[140].pointer’)
+staticsymbols.h:169:1: error: initializer element is not constant
+staticsymbols.h:169:1: error: (near initialization for ‘symsTable[141].pointer’)
+staticsymbols.h:170:1: error: initializer element is not constant
+staticsymbols.h:170:1: error: (near initialization for ‘symsTable[142].pointer’)
+staticsymbols.h:171:1: error: initializer element is not constant
+staticsymbols.h:171:1: error: (near initialization for ‘symsTable[143].pointer’)
+staticsymbols.h:172:1: error: initializer element is not constant
+staticsymbols.h:172:1: error: (near initialization for ‘symsTable[144].pointer’)
+staticsymbols.h:173:1: error: initializer element is not constant
+staticsymbols.h:173:1: error: (near initialization for ‘symsTable[145].pointer’)
+staticsymbols.h:174:1: error: initializer element is not constant
+staticsymbols.h:174:1: error: (near initialization for ‘symsTable[146].pointer’)
+staticsymbols.h:175:1: error: initializer element is not constant
+staticsymbols.h:175:1: error: (near initialization for ‘symsTable[147].pointer’)
+staticsymbols.h:176:1: error: initializer element is not constant
+staticsymbols.h:176:1: error: (near initialization for ‘symsTable[148].pointer’)
+staticsymbols.h:177:1: error: initializer element is not constant
+staticsymbols.h:177:1: error: (near initialization for ‘symsTable[149].pointer’)
+staticsymbols.h:178:1: error: initializer element is not constant
+staticsymbols.h:178:1: error: (near initialization for ‘symsTable[150].pointer’)
+staticsymbols.h:179:1: error: initializer element is not constant
+staticsymbols.h:179:1: error: (near initialization for ‘symsTable[151].pointer’)
+staticsymbols.h:180:1: error: initializer element is not constant
+staticsymbols.h:180:1: error: (near initialization for ‘symsTable[152].pointer’)
+staticsymbols.h:181:1: error: initializer element is not constant
+staticsymbols.h:181:1: error: (near initialization for ‘symsTable[153].pointer’)
+staticsymbols.h:182:1: error: initializer element is not constant
+staticsymbols.h:182:1: error: (near initialization for ‘symsTable[154].pointer’)
+staticsymbols.h:183:1: error: initializer element is not constant
+staticsymbols.h:183:1: error: (near initialization for ‘symsTable[155].pointer’)
+staticsymbols.h:184:1: error: initializer element is not constant
+staticsymbols.h:184:1: error: (near initialization for ‘symsTable[156].pointer’)
+staticsymbols.h:185:1: error: initializer element is not constant
+staticsymbols.h:185:1: error: (near initialization for ‘symsTable[157].pointer’)
+staticsymbols.h:186:1: error: initializer element is not constant
+staticsymbols.h:186:1: error: (near initialization for ‘symsTable[158].pointer’)
+staticsymbols.h:187:1: error: initializer element is not constant
+staticsymbols.h:187:1: error: (near initialization for ‘symsTable[159].pointer’)
+staticsymbols.h:188:1: error: initializer element is not constant
+staticsymbols.h:188:1: error: (near initialization for ‘symsTable[160].pointer’)
+staticsymbols.h:189:1: error: initializer element is not constant
+staticsymbols.h:189:1: error: (near initialization for ‘symsTable[161].pointer’)
+staticsymbols.h:190:1: error: initializer element is not constant
+staticsymbols.h:190:1: error: (near initialization for ‘symsTable[162].pointer’)
+staticsymbols.h:191:1: error: initializer element is not constant
+staticsymbols.h:191:1: error: (near initialization for ‘symsTable[163].pointer’)
+staticsymbols.h:192:1: error: initializer element is not constant
+staticsymbols.h:192:1: error: (near initialization for ‘symsTable[164].pointer’)
+staticsymbols.h:193:1: error: initializer element is not constant
+staticsymbols.h:193:1: error: (near initialization for ‘symsTable[165].pointer’)
+staticsymbols.h:194:1: error: initializer element is not constant
+staticsymbols.h:194:1: error: (near initialization for ‘symsTable[166].pointer’)
+staticsymbols.h:195:1: error: initializer element is not constant
+staticsymbols.h:195:1: error: (near initialization for ‘symsTable[167].pointer’)
+staticsymbols.h:196:1: error: initializer element is not constant
+staticsymbols.h:196:1: error: (near initialization for ‘symsTable[168].pointer’)
+staticsymbols.h:197:1: error: initializer element is not constant
+staticsymbols.h:197:1: error: (near initialization for ‘symsTable[169].pointer’)
+staticsymbols.h:198:1: error: initializer element is not constant
+staticsymbols.h:198:1: error: (near initialization for ‘symsTable[170].pointer’)
+staticsymbols.h:200:1: error: initializer element is not constant
+staticsymbols.h:200:1: error: (near initialization for ‘symsTable[171].pointer’)
+staticsymbols.h:201:1: error: initializer element is not constant
+staticsymbols.h:201:1: error: (near initialization for ‘symsTable[172].pointer’)
+staticsymbols.h:228:1: error: initializer element is not constant
+staticsymbols.h:228:1: error: (near initialization for ‘symsTable[173].pointer’)
+staticsymbols.h:229:1: error: initializer element is not constant
+staticsymbols.h:229:1: error: (near initialization for ‘symsTable[174].pointer’)
+staticsymbols.h:230:1: error: initializer element is not constant
+staticsymbols.h:230:1: error: (near initialization for ‘symsTable[175].pointer’)
+staticsymbols.h:231:1: error: initializer element is not constant
+staticsymbols.h:231:1: error: (near initialization for ‘symsTable[176].pointer’)
+staticsymbols.h:232:1: error: initializer element is not constant
+staticsymbols.h:232:1: error: (near initialization for ‘symsTable[177].pointer’)
+staticsymbols.h:233:1: error: initializer element is not constant
+staticsymbols.h:233:1: error: (near initialization for ‘symsTable[178].pointer’)
+staticsymbols.h:234:1: error: initializer element is not constant
+staticsymbols.h:234:1: error: (near initialization for ‘symsTable[179].pointer’)
+staticsymbols.h:235:1: error: initializer element is not constant
+staticsymbols.h:235:1: error: (near initialization for ‘symsTable[180].pointer’)
+staticsymbols.h:236:1: error: initializer element is not constant
+staticsymbols.h:236:1: error: (near initialization for ‘symsTable[181].pointer’)
+staticsymbols.h:240:1: error: initializer element is not constant
+staticsymbols.h:240:1: error: (near initialization for ‘symsTable[182].pointer’)
+staticsymbols.h:241:1: error: initializer element is not constant
+staticsymbols.h:241:1: error: (near initialization for ‘symsTable[183].pointer’)
+staticsymbols.h:242:1: error: initializer element is not constant
+staticsymbols.h:242:1: error: (near initialization for ‘symsTable[184].pointer’)
+staticsymbols.h:243:1: error: initializer element is not constant
+staticsymbols.h:243:1: error: (near initialization for ‘symsTable[185].pointer’)
+staticsymbols.h:245:1: error: initializer element is not constant
+staticsymbols.h:245:1: error: (near initialization for ‘symsTable[186].pointer’)
+staticsymbols.h:246:1: error: initializer element is not constant
+staticsymbols.h:246:1: error: (near initialization for ‘symsTable[187].pointer’)
+staticsymbols.h:247:1: error: initializer element is not constant
+staticsymbols.h:247:1: error: (near initialization for ‘symsTable[188].pointer’)
+staticsymbols.h:248:1: error: initializer element is not constant
+staticsymbols.h:248:1: error: (near initialization for ‘symsTable[189].pointer’)
+staticsymbols.h:249:1: error: initializer element is not constant
+staticsymbols.h:249:1: error: (near initialization for ‘symsTable[190].pointer’)
+staticsymbols.h:250:1: error: initializer element is not constant
+staticsymbols.h:250:1: error: (near initialization for ‘symsTable[191].pointer’)
+staticsymbols.h:251:1: error: initializer element is not constant
+staticsymbols.h:251:1: error: (near initialization for ‘symsTable[192].pointer’)
+staticsymbols.h:252:1: error: initializer element is not constant
+staticsymbols.h:252:1: error: (near initialization for ‘symsTable[193].pointer’)
+staticsymbols.h:253:1: error: initializer element is not constant
+staticsymbols.h:253:1: error: (near initialization for ‘symsTable[194].pointer’)
+staticsymbols.h:254:1: error: initializer element is not constant
+staticsymbols.h:254:1: error: (near initialization for ‘symsTable[195].pointer’)
+staticsymbols.h:256:1: error: initializer element is not constant
+staticsymbols.h:256:1: error: (near initialization for ‘symsTable[196].pointer’)
+staticsymbols.h:257:1: error: initializer element is not constant
+staticsymbols.h:257:1: error: (near initialization for ‘symsTable[197].pointer’)
+staticsymbols.h:258:1: error: initializer element is not constant
+staticsymbols.h:258:1: error: (near initialization for ‘symsTable[198].pointer’)
+staticsymbols.h:259:1: error: initializer element is not constant
+staticsymbols.h:259:1: error: (near initialization for ‘symsTable[199].pointer’)
+staticsymbols.h:260:1: error: initializer element is not constant
+staticsymbols.h:260:1: error: (near initialization for ‘symsTable[200].pointer’)
+staticsymbols.h:261:1: error: initializer element is not constant
+staticsymbols.h:261:1: error: (near initialization for ‘symsTable[201].pointer’)
+staticsymbols.h:262:1: error: initializer element is not constant
+staticsymbols.h:262:1: error: (near initialization for ‘symsTable[202].pointer’)
+staticsymbols.h:263:1: error: initializer element is not constant
+staticsymbols.h:263:1: error: (near initialization for ‘symsTable[203].pointer’)
+staticsymbols.h:264:1: error: initializer element is not constant
+staticsymbols.h:264:1: error: (near initialization for ‘symsTable[204].pointer’)
+staticsymbols.h:265:1: error: initializer element is not constant
+staticsymbols.h:265:1: error: (near initialization for ‘symsTable[205].pointer’)
+staticsymbols.h:266:1: error: initializer element is not constant
+staticsymbols.h:266:1: error: (near initialization for ‘symsTable[206].pointer’)
+staticsymbols.h:267:1: error: initializer element is not constant
+staticsymbols.h:267:1: error: (near initialization for ‘symsTable[207].pointer’)
+staticsymbols.h:268:1: error: initializer element is not constant
+staticsymbols.h:268:1: error: (near initialization for ‘symsTable[208].pointer’)
+staticsymbols.h:269:1: error: initializer element is not constant
+staticsymbols.h:269:1: error: (near initialization for ‘symsTable[209].pointer’)
+staticsymbols.h:270:1: error: initializer element is not constant
+staticsymbols.h:270:1: error: (near initialization for ‘symsTable[210].pointer’)
+staticsymbols.h:271:1: error: initializer element is not constant
+staticsymbols.h:271:1: error: (near initialization for ‘symsTable[211].pointer’)
+staticsymbols.h:272:1: error: initializer element is not constant
+staticsymbols.h:272:1: error: (near initialization for ‘symsTable[212].pointer’)
+staticsymbols.h:274:1: error: initializer element is not constant
+staticsymbols.h:274:1: error: (near initialization for ‘symsTable[213].pointer’)
+staticsymbols.h:275:1: error: initializer element is not constant
+staticsymbols.h:275:1: error: (near initialization for ‘symsTable[214].pointer’)
+staticsymbols.h:276:1: error: initializer element is not constant
+staticsymbols.h:276:1: error: (near initialization for ‘symsTable[215].pointer’)
+staticsymbols.h:279:1: error: initializer element is not constant
+staticsymbols.h:279:1: error: (near initialization for ‘symsTable[216].pointer’)
+staticsymbols.h:280:1: error: initializer element is not constant
+staticsymbols.h:280:1: error: (near initialization for ‘symsTable[217].pointer’)
+staticsymbols.h:281:1: error: initializer element is not constant
+staticsymbols.h:281:1: error: (near initialization for ‘symsTable[218].pointer’)
+staticsymbols.h:282:1: error: initializer element is not constant
+staticsymbols.h:282:1: error: (near initialization for ‘symsTable[219].pointer’)
+staticsymbols.h:283:1: error: initializer element is not constant
+staticsymbols.h:283:1: error: (near initialization for ‘symsTable[220].pointer’)
+staticsymbols.h:284:1: error: initializer element is not constant
+staticsymbols.h:284:1: error: (near initialization for ‘symsTable[221].pointer’)
+staticsymbols.h:285:1: error: initializer element is not constant
+staticsymbols.h:285:1: error: (near initialization for ‘symsTable[222].pointer’)
+staticsymbols.h:286:1: error: initializer element is not constant
+staticsymbols.h:286:1: error: (near initialization for ‘symsTable[223].pointer’)
+staticsymbols.h:288:1: error: initializer element is not constant
+staticsymbols.h:288:1: error: (near initialization for ‘symsTable[224].pointer’)
+staticsymbols.h:289:1: error: initializer element is not constant
+staticsymbols.h:289:1: error: (near initialization for ‘symsTable[225].pointer’)
+staticsymbols.h:291:1: error: initializer element is not constant
+staticsymbols.h:291:1: error: (near initialization for ‘symsTable[226].pointer’)
+staticsymbols.h:292:1: error: initializer element is not constant
+staticsymbols.h:292:1: error: (near initialization for ‘symsTable[227].pointer’)
+staticsymbols.h:293:1: error: initializer element is not constant
+staticsymbols.h:293:1: error: (near initialization for ‘symsTable[228].pointer’)
+staticsymbols.h:294:1: error: initializer element is not constant
+staticsymbols.h:294:1: error: (near initialization for ‘symsTable[229].pointer’)
+staticsymbols.h:295:1: error: initializer element is not constant
+staticsymbols.h:295:1: error: (near initialization for ‘symsTable[230].pointer’)
+staticsymbols.h:296:1: error: initializer element is not constant
+staticsymbols.h:296:1: error: (near initialization for ‘symsTable[231].pointer’)
+staticsymbols.h:297:1: error: initializer element is not constant
+staticsymbols.h:297:1: error: (near initialization for ‘symsTable[232].pointer’)
+staticsymbols.h:299:1: error: initializer element is not constant
+staticsymbols.h:299:1: error: (near initialization for ‘symsTable[233].pointer’)
+staticsymbols.h:300:1: error: initializer element is not constant
+staticsymbols.h:300:1: error: (near initialization for ‘symsTable[234].pointer’)
+staticsymbols.h:302:1: error: initializer element is not constant
+staticsymbols.h:302:1: error: (near initialization for ‘symsTable[235].pointer’)
+staticsymbols.h:303:1: error: initializer element is not constant
+staticsymbols.h:303:1: error: (near initialization for ‘symsTable[236].pointer’)
+staticsymbols.h:328:1: error: initializer element is not constant
+staticsymbols.h:328:1: error: (near initialization for ‘symsTable[237].pointer’)
+staticsymbols.h:329:1: error: initializer element is not constant
+staticsymbols.h:329:1: error: (near initialization for ‘symsTable[238].pointer’)
+staticsymbols.h:330:1: error: initializer element is not constant
+staticsymbols.h:330:1: error: (near initialization for ‘symsTable[239].pointer’)
+staticsymbols.h:331:1: error: initializer element is not constant
+staticsymbols.h:331:1: error: (near initialization for ‘symsTable[240].pointer’)
+staticsymbols.h:332:1: error: initializer element is not constant
+staticsymbols.h:332:1: error: (near initialization for ‘symsTable[241].pointer’)
+staticsymbols.h:333:1: error: initializer element is not constant
+staticsymbols.h:333:1: error: (near initialization for ‘symsTable[242].pointer’)
+staticsymbols.h:334:1: error: initializer element is not constant
+staticsymbols.h:334:1: error: (near initialization for ‘symsTable[243].pointer’)
+staticsymbols.h:335:1: error: initializer element is not constant
+staticsymbols.h:335:1: error: (near initialization for ‘symsTable[244].pointer’)
+staticsymbols.h:336:1: error: initializer element is not constant
+staticsymbols.h:336:1: error: (near initialization for ‘symsTable[245].pointer’)
+staticsymbols.h:337:1: error: initializer element is not constant
+staticsymbols.h:337:1: error: (near initialization for ‘symsTable[246].pointer’)
+staticsymbols.h:338:1: error: initializer element is not constant
+staticsymbols.h:338:1: error: (near initialization for ‘symsTable[247].pointer’)
+staticsymbols.h:339:1: error: initializer element is not constant
+staticsymbols.h:339:1: error: (near initialization for ‘symsTable[248].pointer’)
+staticsymbols.h:340:1: error: initializer element is not constant
+staticsymbols.h:340:1: error: (near initialization for ‘symsTable[249].pointer’)
+staticsymbols.h:341:1: error: initializer element is not constant
+staticsymbols.h:341:1: error: (near initialization for ‘symsTable[250].pointer’)
+staticsymbols.h:342:1: error: initializer element is not constant
+staticsymbols.h:342:1: error: (near initialization for ‘symsTable[251].pointer’)
+staticsymbols.h:343:1: error: initializer element is not constant
+staticsymbols.h:343:1: error: (near initialization for ‘symsTable[252].pointer’)
+staticsymbols.h:344:1: error: initializer element is not constant
+staticsymbols.h:344:1: error: (near initialization for ‘symsTable[253].pointer’)
+staticsymbols.h:345:1: error: initializer element is not constant
+staticsymbols.h:345:1: error: (near initialization for ‘symsTable[254].pointer’)
+staticsymbols.h:346:1: error: initializer element is not constant
+staticsymbols.h:346:1: error: (near initialization for ‘symsTable[255].pointer’)
+staticsymbols.h:347:1: error: initializer element is not constant
+staticsymbols.h:347:1: error: (near initialization for ‘symsTable[256].pointer’)
+staticsymbols.h:348:1: error: initializer element is not constant
+staticsymbols.h:348:1: error: (near initialization for ‘symsTable[257].pointer’)
+staticsymbols.h:349:1: error: initializer element is not constant
+staticsymbols.h:349:1: error: (near initialization for ‘symsTable[258].pointer’)
+staticsymbols.h:350:1: error: initializer element is not constant
+staticsymbols.h:350:1: error: (near initialization for ‘symsTable[259].pointer’)
+staticsymbols.h:351:1: error: initializer element is not constant
+staticsymbols.h:351:1: error: (near initialization for ‘symsTable[260].pointer’)
+staticsymbols.h:352:1: error: initializer element is not constant
+staticsymbols.h:352:1: error: (near initialization for ‘symsTable[261].pointer’)
+staticsymbols.h:353:1: error: initializer element is not constant
+staticsymbols.h:353:1: error: (near initialization for ‘symsTable[262].pointer’)
+staticsymbols.h:354:1: error: initializer element is not constant
+staticsymbols.h:354:1: error: (near initialization for ‘symsTable[263].pointer’)
+staticsymbols.h:355:1: error: initializer element is not constant
+staticsymbols.h:355:1: error: (near initialization for ‘symsTable[264].pointer’)
+staticsymbols.h:357:1: error: initializer element is not constant
+staticsymbols.h:357:1: error: (near initialization for ‘symsTable[265].pointer’)
+staticsymbols.h:358:1: error: initializer element is not constant
+staticsymbols.h:358:1: error: (near initialization for ‘symsTable[266].pointer’)
+redis.c:7129:14: error: invalid storage class for function ‘findFuncName’
+redis.c:7148:1: error: expected declaration or statement at end of input
+redis.c: At top level:
+redis.c:191:13: warning: ‘_redisAssert’ used but never defined [enabled by default]
+redis.c:192:13: warning: ‘_redisPanic’ used but never defined [enabled by default]
+redis.c:403:13: warning: ‘decrRefCount’ used but never defined [enabled by default]
+redis.c:404:14: warning: ‘createObject’ used but never defined [enabled by default]
+redis.c:405:13: warning: ‘freeClient’ used but never defined [enabled by default]
+redis.c:406:13: warning: ‘addReply’ used but never defined [enabled by default]
+redis.c:407:13: warning: ‘addReplySds’ used but never defined [enabled by default]
+redis.c:408:13: warning: ‘incrRefCount’ used but never defined [enabled by default]
+make: *** [redis.o] Error 1
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/pqsort.c xen-4.2.1-merge/stubdom/c_httpd_redis/pqsort.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/pqsort.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/pqsort.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,197 @@
+/* The following is the NetBSD libc qsort implementation modified in order to
+ * support partial sorting of ranges for Redis.
+ *
+ * Copyright(C) 2009-2010 Salvatore Sanfilippo. All rights reserved.
+ *
+ * The original copyright notice follows. */
+
+
+/*	$NetBSD: qsort.c,v 1.19 2009/01/30 23:38:44 lukem Exp $	*/
+
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <stdlib.h>
+
+static inline char	*med3 (char *, char *, char *,
+    int (*)(const void *, const void *));
+static inline void	 swapfunc (char *, char *, size_t, int);
+
+#define min(a, b)	(a) < (b) ? a : b
+
+/*
+ * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
+ */
+#define swapcode(TYPE, parmi, parmj, n) { 		\
+	size_t i = (n) / sizeof (TYPE); 		\
+	TYPE *pi = (TYPE *)(void *)(parmi); 		\
+	TYPE *pj = (TYPE *)(void *)(parmj); 		\
+	do { 						\
+		TYPE	t = *pi;			\
+		*pi++ = *pj;				\
+		*pj++ = t;				\
+        } while (--i > 0);				\
+}
+
+#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
+	es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
+
+static inline void
+swapfunc(char *a, char *b, size_t n, int swaptype)
+{
+
+	if (swaptype <= 1) 
+		swapcode(long, a, b, n)
+	else
+		swapcode(char, a, b, n)
+}
+
+#define swap(a, b)						\
+	if (swaptype == 0) {					\
+		long t = *(long *)(void *)(a);			\
+		*(long *)(void *)(a) = *(long *)(void *)(b);	\
+		*(long *)(void *)(b) = t;			\
+	} else							\
+		swapfunc(a, b, es, swaptype)
+
+#define vecswap(a, b, n) if ((n) > 0) swapfunc((a), (b), (size_t)(n), swaptype)
+
+static inline char *
+med3(char *a, char *b, char *c,
+    int (*cmp) (const void *, const void *))
+{
+
+	return cmp(a, b) < 0 ?
+	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
+              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
+}
+
+static void
+_pqsort(void *a, size_t n, size_t es,
+    int (*cmp) (const void *, const void *), void *lrange, void *rrange)
+{
+	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
+	size_t d, r;
+	int swaptype, swap_cnt, cmp_result;
+
+loop:	SWAPINIT(a, es);
+	swap_cnt = 0;
+	if (n < 7) {
+		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
+			     pl -= es)
+				swap(pl, pl - es);
+		return;
+	}
+	pm = (char *) a + (n / 2) * es;
+	if (n > 7) {
+		pl = (char *) a;
+		pn = (char *) a + (n - 1) * es;
+		if (n > 40) {
+			d = (n / 8) * es;
+			pl = med3(pl, pl + d, pl + 2 * d, cmp);
+			pm = med3(pm - d, pm, pm + d, cmp);
+			pn = med3(pn - 2 * d, pn - d, pn, cmp);
+		}
+		pm = med3(pl, pm, pn, cmp);
+	}
+	swap(a, pm);
+	pa = pb = (char *) a + es;
+
+	pc = pd = (char *) a + (n - 1) * es;
+	for (;;) {
+		while (pb <= pc && (cmp_result = cmp(pb, a)) <= 0) {
+			if (cmp_result == 0) {
+				swap_cnt = 1;
+				swap(pa, pb);
+				pa += es;
+			}
+			pb += es;
+		}
+		while (pb <= pc && (cmp_result = cmp(pc, a)) >= 0) {
+			if (cmp_result == 0) {
+				swap_cnt = 1;
+				swap(pc, pd);
+				pd -= es;
+			}
+			pc -= es;
+		}
+		if (pb > pc)
+			break;
+		swap(pb, pc);
+		swap_cnt = 1;
+		pb += es;
+		pc -= es;
+	}
+	if (swap_cnt == 0) {  /* Switch to insertion sort */
+		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
+			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0; 
+			     pl -= es)
+				swap(pl, pl - es);
+		return;
+	}
+
+	pn = (char *) a + n * es;
+	r = min(pa - (char *) a, pb - pa);
+	vecswap(a, pb - r, r);
+	r = min((size_t)(pd - pc), pn - pd - es);
+	vecswap(pb, pn - r, r);
+	if ((r = pb - pa) > es) {
+                void *_l = a, *_r = ((unsigned char*)a)+r-1;
+                if (!((lrange < _l && rrange < _l) ||
+                    (lrange > _r && rrange > _r)))
+		    _pqsort(a, r / es, es, cmp, lrange, rrange);
+        }
+	if ((r = pd - pc) > es) { 
+                void *_l, *_r;
+                
+		/* Iterate rather than recurse to save stack space */
+		a = pn - r;
+		n = r / es;
+
+                _l = a;
+                _r = ((unsigned char*)a)+r-1;
+                if (!((lrange < _l && rrange < _l) ||
+                    (lrange > _r && rrange > _r)))
+		    goto loop;
+	}
+/*		qsort(pn - r, r / es, es, cmp);*/
+}
+
+void
+pqsort(void *a, size_t n, size_t es,
+    int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
+{
+    _pqsort(a,n,es,cmp,((unsigned char*)a)+(lrange*es),
+                       ((unsigned char*)a)+((rrange+1)*es)-1);
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/pqsort.h xen-4.2.1-merge/stubdom/c_httpd_redis/pqsort.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/pqsort.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/pqsort.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,15 @@
+/* The following is the NetBSD libc qsort implementation modified in order to
+ * support partial sorting of ranges for Redis.
+ *
+ * Copyright(C) 2009-2010 Salvatore Sanfilippo. All rights reserved.
+ *
+ * See the pqsort.c file for the original copyright notice. */
+
+#ifndef __PQSORT_H
+#define __PQSORT_H
+
+void
+pqsort(void *a, size_t n, size_t es,
+    int (*cmp) (const void *, const void *), size_t lrange, size_t rrange);
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/redis.c xen-4.2.1-merge/stubdom/c_httpd_redis/redis.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/redis.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/redis.c	2016-08-05 14:21:39.000000000 +0800
@@ -0,0 +1,7157 @@
+/*
+ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define REDIS_VERSION "2.0.4"
+
+#include "fmacros.h"
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <signal.h>
+
+#ifdef HAVE_BACKTRACE
+#include <execinfo.h>
+#include <ucontext.h>
+#endif /* HAVE_BACKTRACE */
+
+#include <sys/wait.h>
+#include <errno.h>
+#include <assert.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <inttypes.h>
+#include <arpa/inet.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include "uio.h"
+#include <limits.h>
+#include <float.h>
+#include <math.h>
+
+#if defined(__sun)
+#include "solarisfixes.h"
+#endif
+
+#include "redis.h"
+#include "ae.h"     /* Event driven programming library */
+#include "sds.h"    /* Dynamic safe strings */
+#include "anet.h"   /* Networking the easy way */
+#include "dict.h"   /* Hash tables */
+#include "adlist.h" /* Linked lists */
+#include "zmalloc.h" /* total memory usage aware version of malloc/free */
+#include "lzf.h"    /* LZF compression library */
+#include "pqsort.h" /* Partial qsort for SORT+LIMIT */
+#include "zipmap.h" /* Compact dictionary-alike data structure */
+#include "sha1.h"   /* SHA1 is used for DEBUG DIGEST */
+#include "release.h" /* Release and/or git repository information */
+
+/* Error codes */
+#define REDIS_OK                0
+#define REDIS_ERR               -1
+
+/* Static server configuration */
+#define REDIS_SERVERPORT        6379    /* TCP port */
+#define REDIS_MAXIDLETIME       (60*5)  /* default client timeout */
+#define REDIS_IOBUF_LEN         1024
+#define REDIS_LOADBUF_LEN       1024
+#define REDIS_STATIC_ARGS       8
+#define REDIS_DEFAULT_DBNUM     16
+#define REDIS_CONFIGLINE_MAX    1024
+#define REDIS_OBJFREELIST_MAX   1000000 /* Max number of objects to cache */
+#define REDIS_MAX_SYNC_TIME     60      /* Slave can't take more to sync */
+#define REDIS_EXPIRELOOKUPS_PER_CRON    10 /* lookup 10 expires per loop */
+#define REDIS_MAX_WRITE_PER_EVENT (1024*64)
+#define REDIS_REQUEST_MAX_SIZE (1024*1024*256) /* max bytes in inline command */
+
+/* If more then REDIS_WRITEV_THRESHOLD write packets are pending use writev */
+#define REDIS_WRITEV_THRESHOLD      3
+/* Max number of iovecs used for each writev call */
+#define REDIS_WRITEV_IOVEC_COUNT    256
+
+/* Hash table parameters */
+#define REDIS_HT_MINFILL        10      /* Minimal hash table fill 10% */
+
+/* Command flags */
+#define REDIS_CMD_BULK          1       /* Bulk write command */
+#define REDIS_CMD_INLINE        2       /* Inline command */
+/* REDIS_CMD_DENYOOM reserves a longer comment: all the commands marked with
+   this flags will return an error when the 'maxmemory' option is set in the
+   config file and the server is using more than maxmemory bytes of memory.
+   In short this commands are denied on low memory conditions. */
+#define REDIS_CMD_DENYOOM       4
+#define REDIS_CMD_FORCE_REPLICATION 8 /* Force replication even if dirty is 0 */
+
+/* Object types */
+#define REDIS_STRING 0
+#define REDIS_LIST 1
+#define REDIS_SET 2
+#define REDIS_ZSET 3
+#define REDIS_HASH 4
+
+/* Objects encoding. Some kind of objects like Strings and Hashes can be
+ * internally represented in multiple ways. The 'encoding' field of the object
+ * is set to one of this fields for this object. */
+#define REDIS_ENCODING_RAW 0    /* Raw representation */
+#define REDIS_ENCODING_INT 1    /* Encoded as integer */
+#define REDIS_ENCODING_ZIPMAP 2 /* Encoded as zipmap */
+#define REDIS_ENCODING_HT 3     /* Encoded as an hash table */
+
+static char* strencoding[] = {
+    "raw", "int", "zipmap", "hashtable"
+};
+
+/* Object types only used for dumping to disk */
+#define REDIS_EXPIRETIME 253
+#define REDIS_SELECTDB 254
+#define REDIS_EOF 255
+
+/* Client flags */
+#define REDIS_SLAVE 1       /* This client is a slave server */
+#define REDIS_MASTER 2      /* This client is a master server */
+#define REDIS_MONITOR 4     /* This client is a slave monitor, see MONITOR */
+#define REDIS_MULTI 8       /* This client is in a MULTI context */
+#define REDIS_BLOCKED 16    /* The client is waiting in a blocking operation */
+#define REDIS_IO_WAIT 32    /* The client is waiting for Virtual Memory I/O */
+
+/* Slave replication state - slave side */
+#define REDIS_REPL_NONE 0   /* No active replication */
+#define REDIS_REPL_CONNECT 1    /* Must connect to master */
+#define REDIS_REPL_CONNECTED 2  /* Connected to master */
+
+/* Slave replication state - from the point of view of master
+ * Note that in SEND_BULK and ONLINE state the slave receives new updates
+ * in its output queue. In the WAIT_BGSAVE state instead the server is waiting
+ * to start the next background saving in order to send updates to it. */
+#define REDIS_REPL_WAIT_BGSAVE_START 3 /* master waits bgsave to start feeding it */
+#define REDIS_REPL_WAIT_BGSAVE_END 4 /* master waits bgsave to start bulk DB transmission */
+#define REDIS_REPL_SEND_BULK 5 /* master is sending the bulk DB */
+#define REDIS_REPL_ONLINE 6 /* bulk DB already transmitted, receive updates */
+
+/* List related stuff */
+#define REDIS_HEAD 0
+#define REDIS_TAIL 1
+
+/* Sort operations */
+#define REDIS_SORT_GET 0
+#define REDIS_SORT_ASC 1
+#define REDIS_SORT_DESC 2
+#define REDIS_SORTKEY_MAX 1024
+
+/* Log levels */
+#define REDIS_DEBUG 0
+#define REDIS_VERBOSE 1
+#define REDIS_NOTICE 2
+#define REDIS_WARNING 3
+
+/* Anti-warning macro... */
+#define REDIS_NOTUSED(V) ((void) V)
+
+#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */
+#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */
+
+/* Hashes related defaults */
+#define REDIS_HASH_MAX_ZIPMAP_ENTRIES 64
+#define REDIS_HASH_MAX_ZIPMAP_VALUE 512
+
+/* We can print the stacktrace, so our assert is defined this way: */
+#define redisAssert(_e) ((_e)?(void)0 : (_redisAssert(#_e,__FILE__,__LINE__),_exit(1)))
+#define redisPanic(_e) _redisPanic(#_e,__FILE__,__LINE__),_exit(1)
+static void _redisAssert(char *estr, char *file, int line);
+static void _redisPanic(char *msg, char *file, int line);
+
+/*================================= Data types ============================== */
+
+/* A redis object, that is a type able to hold a string / list / set */
+
+/* The actual Redis Object */
+typedef struct redisObject {
+    void *ptr;
+    unsigned char type;
+    unsigned char encoding;
+	 int refcount;
+} robj;
+
+/* Macro used to initalize a Redis object allocated on the stack.
+ * Note that this macro is taken near the structure definition to make sure
+ * we'll update it when the structure is changed, to avoid bugs like
+ * bug #85 introduced exactly in this way. */
+#define initStaticStringObject(_var,_ptr) do { \
+    _var.refcount = 1; \
+    _var.type = REDIS_STRING; \
+    _var.encoding = REDIS_ENCODING_RAW; \
+    _var.ptr = _ptr; \
+} while(0);
+
+typedef struct redisDb {
+    dict *dict;                 /* The keyspace for this DB */
+    dict *expires;              /* Timeout of keys with a timeout set */
+    dict *blockingkeys;         /* Keys with clients waiting for data (BLPOP) */
+    int id;
+} redisDb;
+
+/* Client MULTI/EXEC state */
+typedef struct multiCmd {
+    robj **argv;
+    int argc;
+    struct redisCommand *cmd;
+} multiCmd;
+
+typedef struct multiState {
+    multiCmd *commands;     /* Array of MULTI commands */
+    int count;              /* Total number of MULTI commands */
+} multiState;
+
+/* With multiplexing we need to take per-clinet state.
+ * Clients are taken in a liked list. */
+typedef struct redisClient {
+    int fd;
+    redisDb *db;
+    int dictid;
+    sds querybuf;
+    robj **argv, **mbargv;
+    int argc, mbargc;
+    int bulklen;            /* bulk read len. -1 if not in bulk read mode */
+    int multibulk;          /* multi bulk command format active */
+    list *reply;
+    int sentlen;
+    time_t lastinteraction; /* time of the last interaction, used for timeout */
+    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */
+    int slaveseldb;         /* slave selected db, if this client is a slave */
+    int authenticated;      /* when requirepass is non-NULL */
+    int replstate;          /* replication state if this is a slave */
+    int repldbfd;           /* replication DB file descriptor */
+    long repldboff;         /* replication DB file offset */
+    off_t repldbsize;       /* replication DB file size */
+    multiState mstate;      /* MULTI/EXEC state */
+    robj **blockingkeys;    /* The key we are waiting to terminate a blocking
+                             * operation such as BLPOP. Otherwise NULL. */
+    int blockingkeysnum;    /* Number of blocking keys */
+    time_t blockingto;      /* Blocking operation timeout. If UNIX current time
+                             * is >= blockingto then the operation timed out. */
+    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */
+    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */
+} redisClient;
+
+
+/* Global server state structure */
+struct redisServer {
+    int port;
+    int fd;
+    redisDb *db;
+	long long dirty;            /* changes to DB from the last save */
+    list *clients;
+    list *slaves, *monitors;
+    char neterr[ANET_ERR_LEN];
+    aeEventLoop *el;
+    int cronloops;              /* number of times the cron function run */
+    list *objfreelist;          /* A list of freed objects to avoid malloc() */
+    time_t lastsave;            /* Unix time of last save succeeede */
+    /* Fields used only for stats */
+    time_t stat_starttime;         /* server start time */
+    long long stat_numcommands;    /* number of processed commands */
+    long long stat_numconnections; /* number of connections received */
+    long long stat_expiredkeys;   /* number of expired keys */
+    /* Configuration */
+    int verbosity;
+    int glueoutputbuf;
+    int maxidletime;
+    int dbnum;
+    int shutdown_asap;
+    time_t lastfsync;
+    char *logfile;
+    char *bindaddr;
+    char *dbfilename;
+    char *requirepass;
+    int activerehashing;
+    /* Replication related */
+    int isslave;
+    char *masterauth;
+    char *masterhost;
+    int masterport;
+    redisClient *master;    /* client that is master for this slave */
+    int replstate;
+    unsigned int maxclients;
+    unsigned long long maxmemory;
+    unsigned int blpop_blocked_clients;
+    /* Sort parameters - qsort_r() is only available under BSD so we
+     * have to take this state global, in order to pass it to sortCompare() */
+    int sort_desc;
+    int sort_alpha;
+    int sort_bypattern;
+    /* Hashes config */
+    size_t hash_max_zipmap_entries;
+    size_t hash_max_zipmap_value;
+    time_t unixtime;    /* Unix time sampled every second. */
+    /* Pubsub */
+    dict *pubsub_channels; /* Map channels to list of subscribed clients */
+    list *pubsub_patterns; /* A list of pubsub_patterns */
+    /* Misc */
+    FILE *devnull;
+};
+
+typedef struct pubsubPattern {
+    redisClient *client;
+    robj *pattern;
+} pubsubPattern;
+
+typedef void redisCommandProc(redisClient *c);
+struct redisCommand {
+    char *name;
+    redisCommandProc *proc;
+    int arity;
+    int flags;
+};
+
+struct redisFunctionSym {
+    char *name;
+    unsigned long pointer;
+};
+
+typedef struct _redisSortObject {
+    robj *obj;
+    union {
+        double score;
+        robj *cmpobj;
+    } u;
+} redisSortObject;
+
+typedef struct _redisSortOperation {
+    int type;
+    robj *pattern;
+} redisSortOperation;
+
+/* ZSETs use a specialized version of Skiplists */
+
+typedef struct zskiplistNode {
+    struct zskiplistNode **forward;
+    struct zskiplistNode *backward;
+    unsigned int *span;
+    double score;
+    robj *obj;
+} zskiplistNode;
+
+typedef struct zskiplist {
+    struct zskiplistNode *header, *tail;
+    unsigned long length;
+    int level;
+} zskiplist;
+
+typedef struct zset {
+    dict *dict;
+    zskiplist *zsl;
+} zset;
+
+/* Our shared "common" objects */
+
+#define REDIS_SHARED_INTEGERS 10000
+struct sharedObjectsStruct {
+    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *pong, *space,
+    *colon, *nullbulk, *nullmultibulk, *queued,
+    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,
+    *outofrangeerr, *plus,
+    *select0, *select1, *select2, *select3, *select4,
+    *select5, *select6, *select7, *select8, *select9,
+    *messagebulk, *pmessagebulk, *subscribebulk, *unsubscribebulk, *mbulk3,
+    *mbulk4, *psubscribebulk, *punsubscribebulk,
+    *integers[REDIS_SHARED_INTEGERS];
+} shared;
+
+/* Global vars that are actally used as constants. The following double
+ * values are used for double on-disk serialization, and are initialized
+ * at runtime to avoid strange compiler optimizations. */
+
+static double R_Zero, R_PosInf, R_NegInf, R_Nan;
+
+/*================================ Prototypes =============================== */
+
+static void freeStringObject(robj *o);
+static void freeListObject(robj *o);
+static void freeSetObject(robj *o);
+static void decrRefCount(void *o);
+static robj *createObject(int type, void *ptr);
+static void freeClient(redisClient *c);
+static void addReply(redisClient *c, robj *obj);
+static void addReplySds(redisClient *c, sds s);
+static void incrRefCount(robj *o);
+static robj *createStringObject(char *ptr, size_t len);
+static robj *dupStringObject(robj *o);
+static void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);
+static void replicationFeedMonitors(list *monitors, int dictid, robj **argv, int argc);
+static robj *tryObjectEncoding(robj *o);
+static robj *getDecodedObject(robj *o);
+static int removeExpire(redisDb *db, robj *key);
+static int expireIfNeeded(redisDb *db, robj *key);
+static int deleteIfVolatile(redisDb *db, robj *key);
+static int deleteKey(redisDb *db, robj *key);
+static time_t getExpire(redisDb *db, robj *key);
+static int setExpire(redisDb *db, robj *key, time_t when);
+static void freeMemoryIfNeeded(void);
+static int processCommand(redisClient *c);
+static void setupSigSegvAction(void);
+static size_t stringObjectLen(robj *o);
+static void processInputBuffer(redisClient *c);
+static zskiplist *zslCreate(void);
+static void zslFree(zskiplist *zsl);
+static void zslInsert(zskiplist *zsl, double score, robj *obj);
+static void initClientMultiState(redisClient *c);
+static void freeClientMultiState(redisClient *c);
+static void queueMultiCommand(redisClient *c, struct redisCommand *cmd);
+static void unblockClientWaitingData(redisClient *c);
+static int handleClientsWaitingListPush(redisClient *c, robj *key, robj *ele);
+
+static int tryFreeOneObjectFromFreelist(void);
+static void acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);
+static void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask);
+static struct redisCommand *lookupCommand(char *name);
+static void call(redisClient *c, struct redisCommand *cmd);
+static void resetClient(redisClient *c);
+static void convertToRealHash(robj *o);
+static int pubsubUnsubscribeAllChannels(redisClient *c, int notify);
+static int pubsubUnsubscribeAllPatterns(redisClient *c, int notify);
+static void freePubsubPattern(void *p);
+static int listMatchPubsubPattern(void *a, void *b);
+static int compareStringObjects(robj *a, robj *b);
+static int equalStringObjects(robj *a, robj *b);
+static void usage();
+static int prepareForShutdown();
+
+static void authCommand(redisClient *c);
+static void pingCommand(redisClient *c);
+static void echoCommand(redisClient *c);
+static void setCommand(redisClient *c);
+static void setnxCommand(redisClient *c);
+static void setexCommand(redisClient *c);
+static void getCommand(redisClient *c);
+static void delCommand(redisClient *c);
+static void existsCommand(redisClient *c);
+static void incrCommand(redisClient *c);
+static void decrCommand(redisClient *c);
+static void incrbyCommand(redisClient *c);
+static void decrbyCommand(redisClient *c);
+static void selectCommand(redisClient *c);
+static void randomkeyCommand(redisClient *c);
+static void keysCommand(redisClient *c);
+static void dbsizeCommand(redisClient *c);
+static void lastsaveCommand(redisClient *c);
+static void shutdownCommand(redisClient *c);
+static void moveCommand(redisClient *c);
+static void renameCommand(redisClient *c);
+static void renamenxCommand(redisClient *c);
+static void lpushCommand(redisClient *c);
+static void rpushCommand(redisClient *c);
+static void lpopCommand(redisClient *c);
+static void rpopCommand(redisClient *c);
+static void llenCommand(redisClient *c);
+static void lindexCommand(redisClient *c);
+static void lrangeCommand(redisClient *c);
+static void ltrimCommand(redisClient *c);
+static void typeCommand(redisClient *c);
+static void lsetCommand(redisClient *c);
+static void saddCommand(redisClient *c);
+static void sremCommand(redisClient *c);
+static void smoveCommand(redisClient *c);
+static void sismemberCommand(redisClient *c);
+static void scardCommand(redisClient *c);
+static void spopCommand(redisClient *c);
+static void srandmemberCommand(redisClient *c);
+static void sinterCommand(redisClient *c);
+static void sinterstoreCommand(redisClient *c);
+static void sunionCommand(redisClient *c);
+static void sunionstoreCommand(redisClient *c);
+static void sdiffCommand(redisClient *c);
+static void sdiffstoreCommand(redisClient *c);
+static void flushdbCommand(redisClient *c);
+static void sortCommand(redisClient *c);
+static void lremCommand(redisClient *c);
+static void rpoplpushcommand(redisClient *c);
+static void infoCommand(redisClient *c);
+static void mgetCommand(redisClient *c);
+static void monitorCommand(redisClient *c);
+static void expireCommand(redisClient *c);
+static void expireatCommand(redisClient *c);
+static void getsetCommand(redisClient *c);
+static void ttlCommand(redisClient *c);
+static void slaveofCommand(redisClient *c);
+static void msetCommand(redisClient *c);
+static void msetnxCommand(redisClient *c);
+static void zaddCommand(redisClient *c);
+static void zincrbyCommand(redisClient *c);
+static void zrangeCommand(redisClient *c);
+static void zrangebyscoreCommand(redisClient *c);
+static void zcountCommand(redisClient *c);
+static void zrevrangeCommand(redisClient *c);
+static void zcardCommand(redisClient *c);
+static void zremCommand(redisClient *c);
+static void zscoreCommand(redisClient *c);
+static void zremrangebyscoreCommand(redisClient *c);
+static void multiCommand(redisClient *c);
+static void execCommand(redisClient *c);
+static void discardCommand(redisClient *c);
+static void blpopCommand(redisClient *c);
+static void brpopCommand(redisClient *c);
+static void substrCommand(redisClient *c);
+static void zrankCommand(redisClient *c);
+static void zrevrankCommand(redisClient *c);
+static void hsetCommand(redisClient *c);
+static void hsetnxCommand(redisClient *c);
+static void hgetCommand(redisClient *c);
+static void hmsetCommand(redisClient *c);
+static void hmgetCommand(redisClient *c);
+static void hdelCommand(redisClient *c);
+static void hlenCommand(redisClient *c);
+static void zremrangebyrankCommand(redisClient *c);
+static void zunionstoreCommand(redisClient *c);
+static void zinterstoreCommand(redisClient *c);
+static void hkeysCommand(redisClient *c);
+static void hvalsCommand(redisClient *c);
+static void hgetallCommand(redisClient *c);
+static void hexistsCommand(redisClient *c);
+static void configCommand(redisClient *c);
+static void hincrbyCommand(redisClient *c);
+static void subscribeCommand(redisClient *c);
+static void unsubscribeCommand(redisClient *c);
+static void psubscribeCommand(redisClient *c);
+static void punsubscribeCommand(redisClient *c);
+static void publishCommand(redisClient *c);
+
+/*================================= Globals ================================= */
+
+/* Global vars */
+static struct redisServer server; /* server global state */
+static struct redisCommand cmdTable[] = {
+    {"get",getCommand,2,REDIS_CMD_INLINE},
+    {"set",setCommand,3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"setnx",setnxCommand,3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"setex",setexCommand,4,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"substr",substrCommand,4,REDIS_CMD_INLINE},
+    {"del",delCommand,-2,REDIS_CMD_INLINE},
+    {"exists",existsCommand,2,REDIS_CMD_INLINE},
+    {"incr",incrCommand,2,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"decr",decrCommand,2,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"mget",mgetCommand,-2,REDIS_CMD_INLINE},
+    {"rpush",rpushCommand,3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"lpush",lpushCommand,3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"rpop",rpopCommand,2,REDIS_CMD_INLINE},
+    {"lpop",lpopCommand,2,REDIS_CMD_INLINE},
+    {"brpop",brpopCommand,-3,REDIS_CMD_INLINE},
+    {"blpop",blpopCommand,-3,REDIS_CMD_INLINE},
+    {"llen",llenCommand,2,REDIS_CMD_INLINE},
+    {"lindex",lindexCommand,3,REDIS_CMD_INLINE},
+    {"lset",lsetCommand,4,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"lrange",lrangeCommand,4,REDIS_CMD_INLINE},
+    {"ltrim",ltrimCommand,4,REDIS_CMD_INLINE},
+    {"lrem",lremCommand,4,REDIS_CMD_BULK},
+    {"rpoplpush",rpoplpushcommand,3,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"sadd",saddCommand,3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"srem",sremCommand,3,REDIS_CMD_BULK},
+    {"smove",smoveCommand,4,REDIS_CMD_BULK},
+    {"sismember",sismemberCommand,3,REDIS_CMD_BULK},
+    {"scard",scardCommand,2,REDIS_CMD_INLINE},
+    {"spop",spopCommand,2,REDIS_CMD_INLINE},
+    {"srandmember",srandmemberCommand,2,REDIS_CMD_INLINE},
+    {"sinter",sinterCommand,-2,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"sinterstore",sinterstoreCommand,-3,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"sunion",sunionCommand,-2,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"sunionstore",sunionstoreCommand,-3,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"sdiff",sdiffCommand,-2,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"sdiffstore",sdiffstoreCommand,-3,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"smembers",sinterCommand,2,REDIS_CMD_INLINE},
+    {"zadd",zaddCommand,4,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"zincrby",zincrbyCommand,4,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"zrem",zremCommand,3,REDIS_CMD_BULK},
+    {"zremrangebyscore",zremrangebyscoreCommand,4,REDIS_CMD_INLINE},
+    {"zremrangebyrank",zremrangebyrankCommand,4,REDIS_CMD_INLINE},
+    {"zunionstore",zunionstoreCommand,-4,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"zinterstore",zinterstoreCommand,-4,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"zrange",zrangeCommand,-4,REDIS_CMD_INLINE},
+    {"zrangebyscore",zrangebyscoreCommand,-4,REDIS_CMD_INLINE},
+    {"zcount",zcountCommand,4,REDIS_CMD_INLINE},
+    {"zrevrange",zrevrangeCommand,-4,REDIS_CMD_INLINE},
+    {"zcard",zcardCommand,2,REDIS_CMD_INLINE},
+    {"zscore",zscoreCommand,3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"zrank",zrankCommand,3,REDIS_CMD_BULK},
+    {"zrevrank",zrevrankCommand,3,REDIS_CMD_BULK},
+    {"hset",hsetCommand,4,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"hsetnx",hsetnxCommand,4,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"hget",hgetCommand,3,REDIS_CMD_BULK},
+    {"hmset",hmsetCommand,-4,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"hmget",hmgetCommand,-3,REDIS_CMD_BULK},
+    {"hincrby",hincrbyCommand,4,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"hdel",hdelCommand,3,REDIS_CMD_BULK},
+    {"hlen",hlenCommand,2,REDIS_CMD_INLINE},
+    {"hkeys",hkeysCommand,2,REDIS_CMD_INLINE},
+    {"hvals",hvalsCommand,2,REDIS_CMD_INLINE},
+    {"hgetall",hgetallCommand,2,REDIS_CMD_INLINE},
+    {"hexists",hexistsCommand,3,REDIS_CMD_BULK},
+    {"incrby",incrbyCommand,3,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"decrby",decrbyCommand,3,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"getset",getsetCommand,3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"mset",msetCommand,-3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"msetnx",msetnxCommand,-3,REDIS_CMD_BULK|REDIS_CMD_DENYOOM},
+    {"randomkey",randomkeyCommand,1,REDIS_CMD_INLINE},
+    {"select",selectCommand,2,REDIS_CMD_INLINE},
+    {"move",moveCommand,3,REDIS_CMD_INLINE},
+    {"rename",renameCommand,3,REDIS_CMD_INLINE},
+    {"renamenx",renamenxCommand,3,REDIS_CMD_INLINE},
+    {"expire",expireCommand,3,REDIS_CMD_INLINE},
+    {"expireat",expireatCommand,3,REDIS_CMD_INLINE},
+    {"keys",keysCommand,2,REDIS_CMD_INLINE},
+    {"dbsize",dbsizeCommand,1,REDIS_CMD_INLINE},
+    {"auth",authCommand,2,REDIS_CMD_INLINE},
+    {"ping",pingCommand,1,REDIS_CMD_INLINE},
+    {"echo",echoCommand,2,REDIS_CMD_BULK},
+    {"shutdown",shutdownCommand,1,REDIS_CMD_INLINE},
+    {"lastsave",lastsaveCommand,1,REDIS_CMD_INLINE},
+    {"type",typeCommand,2,REDIS_CMD_INLINE},
+    {"multi",multiCommand,1,REDIS_CMD_INLINE},
+    {"discard",discardCommand,1,REDIS_CMD_INLINE},
+    {"flushdb",flushdbCommand,1,REDIS_CMD_INLINE},
+    {"sort",sortCommand,-2,REDIS_CMD_INLINE|REDIS_CMD_DENYOOM},
+    {"info",infoCommand,1,REDIS_CMD_INLINE},
+    {"monitor",monitorCommand,1,REDIS_CMD_INLINE},
+    {"ttl",ttlCommand,2,REDIS_CMD_INLINE},
+    {"slaveof",slaveofCommand,3,REDIS_CMD_INLINE},
+    {"config",configCommand,-2,REDIS_CMD_BULK},
+    {"subscribe",subscribeCommand,-2,REDIS_CMD_INLINE},
+    {"unsubscribe",unsubscribeCommand,-1,REDIS_CMD_INLINE},
+    {"psubscribe",psubscribeCommand,-2,REDIS_CMD_INLINE},
+    {"punsubscribe",punsubscribeCommand,-1,REDIS_CMD_INLINE},
+    {"publish",publishCommand,3,REDIS_CMD_BULK|REDIS_CMD_FORCE_REPLICATION},
+    {NULL,NULL,0,0}
+};
+
+/*============================ Utility functions ============================ */
+
+/* Glob-style pattern matching. */
+static int stringmatchlen(const char *pattern, int patternLen,
+        const char *string, int stringLen, int nocase)
+{
+    while(patternLen) {
+        switch(pattern[0]) {
+        case '*':
+            while (pattern[1] == '*') {
+                pattern++;
+                patternLen--;
+            }
+            if (patternLen == 1)
+                return 1; /* match */
+            while(stringLen) {
+                if (stringmatchlen(pattern+1, patternLen-1,
+                            string, stringLen, nocase))
+                    return 1; /* match */
+                string++;
+                stringLen--;
+            }
+            return 0; /* no match */
+            break;
+        case '?':
+            if (stringLen == 0)
+                return 0; /* no match */
+            string++;
+            stringLen--;
+            break;
+        case '[':
+        {
+            int not, match;
+
+            pattern++;
+            patternLen--;
+            not = pattern[0] == '^';
+            if (not) {
+                pattern++;
+                patternLen--;
+            }
+            match = 0;
+            while(1) {
+                if (pattern[0] == '\\') {
+                    pattern++;
+                    patternLen--;
+                    if (pattern[0] == string[0])
+                        match = 1;
+                } else if (pattern[0] == ']') {
+                    break;
+                } else if (patternLen == 0) {
+                    pattern--;
+                    patternLen++;
+                    break;
+                } else if (pattern[1] == '-' && patternLen >= 3) {
+                    int start = pattern[0];
+                    int end = pattern[2];
+                    int c = string[0];
+                    if (start > end) {
+                        int t = start;
+                        start = end;
+                        end = t;
+                    }
+                    if (nocase) {
+                        start = tolower(start);
+                        end = tolower(end);
+                        c = tolower(c);
+                    }
+                    pattern += 2;
+                    patternLen -= 2;
+                    if (c >= start && c <= end)
+                        match = 1;
+                } else {
+                    if (!nocase) {
+                        if (pattern[0] == string[0])
+                            match = 1;
+                    } else {
+                        if (tolower((int)pattern[0]) == tolower((int)string[0]))
+                            match = 1;
+                    }
+                }
+                pattern++;
+                patternLen--;
+            }
+            if (not)
+                match = !match;
+            if (!match)
+                return 0; /* no match */
+            string++;
+            stringLen--;
+            break;
+        }
+        case '\\':
+            if (patternLen >= 2) {
+                pattern++;
+                patternLen--;
+            }
+            /* fall through */
+        default:
+            if (!nocase) {
+                if (pattern[0] != string[0])
+                    return 0; /* no match */
+            } else {
+                if (tolower((int)pattern[0]) != tolower((int)string[0]))
+                    return 0; /* no match */
+            }
+            string++;
+            stringLen--;
+            break;
+        }
+        pattern++;
+        patternLen--;
+        if (stringLen == 0) {
+            while(*pattern == '*') {
+                pattern++;
+                patternLen--;
+            }
+            break;
+        }
+    }
+    if (patternLen == 0 && stringLen == 0)
+        return 1;
+    return 0;
+}
+
+static int stringmatch(const char *pattern, const char *string, int nocase) {
+    return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);
+}
+
+/* Convert a string representing an amount of memory into the number of
+ * bytes, so for instance memtoll("1Gi") will return 1073741824 that is
+ * (1024*1024*1024).
+ *
+ * On parsing error, if *err is not NULL, it's set to 1, otherwise it's
+ * set to 0 */
+static long long memtoll(const char *p, int *err) {
+    const char *u;
+    char buf[128];
+    long mul; /* unit multiplier */
+    long long val;
+    unsigned int digits;
+
+    if (err) *err = 0;
+    /* Search the first non digit character. */
+    u = p;
+    if (*u == '-') u++;
+    while(*u && isdigit(*u)) u++;
+    if (*u == '\0' || !strcasecmp(u,"b")) {
+        mul = 1;
+    } else if (!strcasecmp(u,"k")) {
+        mul = 1000;
+    } else if (!strcasecmp(u,"kb")) {
+        mul = 1024;
+    } else if (!strcasecmp(u,"m")) {
+        mul = 1000*1000;
+    } else if (!strcasecmp(u,"mb")) {
+        mul = 1024*1024;
+    } else if (!strcasecmp(u,"g")) {
+        mul = 1000L*1000*1000;
+    } else if (!strcasecmp(u,"gb")) {
+        mul = 1024L*1024*1024;
+    } else {
+        if (err) *err = 1;
+        mul = 1;
+    }
+    digits = u-p;
+    if (digits >= sizeof(buf)) {
+        if (err) *err = 1;
+        return LLONG_MAX;
+    }
+    memcpy(buf,p,digits);
+    buf[digits] = '\0';
+    val = strtoll(buf,NULL,10);
+    return val*mul;
+}
+
+/* Convert a long long into a string. Returns the number of
+ * characters needed to represent the number, that can be shorter if passed
+ * buffer length is not enough to store the whole number. */
+static int ll2string(char *s, size_t len, long long value) {
+    char buf[32], *p;
+    unsigned long long v;
+    size_t l;
+
+    if (len == 0) return 0;
+    v = (value < 0) ? -value : value;
+    p = buf+31; /* point to the last character */
+    do {
+        *p-- = '0'+(v%10);
+        v /= 10;
+    } while(v);
+    if (value < 0) *p-- = '-';
+    p++;
+    l = 32-(p-buf);
+    if (l+1 > len) l = len-1; /* Make sure it fits, including the nul term */
+    memcpy(s,p,l);
+    s[l] = '\0';
+    return l;
+}
+
+static void redisLog(int level, const char *fmt, ...) {
+    va_list ap;
+    FILE *fp;
+    char *c = ".-*#";
+    char buf[64];
+    time_t now;
+
+    if (level < server.verbosity) return;
+
+    fp = (server.logfile == NULL) ? stdout : fopen(server.logfile,"a");
+    if (!fp) return;
+
+    va_start(ap, fmt);
+    now = time(NULL);
+    strftime(buf,64,"%d %b %H:%M:%S",localtime(&now));
+    fprintf(fp,"[%d] %s %c ",(int)getpid(),buf,c[level]);
+    vfprintf(fp, fmt, ap);
+    fprintf(fp,"\n");
+    fflush(fp);
+    va_end(ap);
+
+    if (server.logfile) fclose(fp);
+}
+
+/*====================== Hash table type implementation  ==================== */
+
+/* This is an hash table type that uses the SDS dynamic strings libary as
+ * keys and radis objects as values (objects can hold SDS strings,
+ * lists, sets). */
+
+static void dictVanillaFree(void *privdata, void *val)
+{
+    DICT_NOTUSED(privdata);
+    zfree(val);
+}
+
+static void dictListDestructor(void *privdata, void *val)
+{
+    DICT_NOTUSED(privdata);
+    listRelease((list*)val);
+}
+
+static int sdsDictKeyCompare(void *privdata, const void *key1,
+        const void *key2)
+{
+    int l1,l2;
+    DICT_NOTUSED(privdata);
+
+    l1 = sdslen((sds)key1);
+    l2 = sdslen((sds)key2);
+    if (l1 != l2) return 0;
+    return memcmp(key1, key2, l1) == 0;
+}
+
+static void dictRedisObjectDestructor(void *privdata, void *val)
+{
+    DICT_NOTUSED(privdata);
+
+    if (val == NULL) return; /* Values of swapped out keys as set to NULL */
+    decrRefCount(val);
+}
+
+static int dictObjKeyCompare(void *privdata, const void *key1,
+        const void *key2)
+{
+    const robj *o1 = key1, *o2 = key2;
+    return sdsDictKeyCompare(privdata,o1->ptr,o2->ptr);
+}
+
+static unsigned int dictObjHash(const void *key) {
+    const robj *o = key;
+    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
+}
+
+static int dictEncObjKeyCompare(void *privdata, const void *key1,
+        const void *key2)
+{
+    robj *o1 = (robj*) key1, *o2 = (robj*) key2;
+    int cmp;
+
+    if (o1->encoding == REDIS_ENCODING_INT &&
+        o2->encoding == REDIS_ENCODING_INT)
+            return o1->ptr == o2->ptr;
+
+    o1 = getDecodedObject(o1);
+    o2 = getDecodedObject(o2);
+    cmp = sdsDictKeyCompare(privdata,o1->ptr,o2->ptr);
+    decrRefCount(o1);
+    decrRefCount(o2);
+    return cmp;
+}
+
+static unsigned int dictEncObjHash(const void *key) {
+    robj *o = (robj*) key;
+
+    if (o->encoding == REDIS_ENCODING_RAW) {
+        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
+    } else {
+        if (o->encoding == REDIS_ENCODING_INT) {
+            char buf[32];
+            int len;
+
+            len = ll2string(buf,32,(long)o->ptr);
+            return dictGenHashFunction((unsigned char*)buf, len);
+        } else {
+            unsigned int hash;
+
+            o = getDecodedObject(o);
+            hash = dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
+            decrRefCount(o);
+            return hash;
+        }
+    }
+}
+
+/* Sets type and expires */
+static dictType setDictType = {
+    dictEncObjHash,            /* hash function */
+    NULL,                      /* key dup */
+    NULL,                      /* val dup */
+    dictEncObjKeyCompare,      /* key compare */
+    dictRedisObjectDestructor, /* key destructor */
+    NULL                       /* val destructor */
+};
+
+/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */
+static dictType zsetDictType = {
+    dictEncObjHash,            /* hash function */
+    NULL,                      /* key dup */
+    NULL,                      /* val dup */
+    dictEncObjKeyCompare,      /* key compare */
+    dictRedisObjectDestructor, /* key destructor */
+    dictVanillaFree            /* val destructor of malloc(sizeof(double)) */
+};
+
+/* Db->dict */
+static dictType dbDictType = {
+    dictObjHash,                /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictObjKeyCompare,          /* key compare */
+    dictRedisObjectDestructor,  /* key destructor */
+    dictRedisObjectDestructor   /* val destructor */
+};
+
+/* Db->expires */
+static dictType keyptrDictType = {
+    dictObjHash,               /* hash function */
+    NULL,                      /* key dup */
+    NULL,                      /* val dup */
+    dictObjKeyCompare,         /* key compare */
+    dictRedisObjectDestructor, /* key destructor */
+    NULL                       /* val destructor */
+};
+
+/* Hash type hash table (note that small hashes are represented with zimpaps) */
+static dictType hashDictType = {
+    dictEncObjHash,             /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictEncObjKeyCompare,       /* key compare */
+    dictRedisObjectDestructor,  /* key destructor */
+    dictRedisObjectDestructor   /* val destructor */
+};
+
+/* Keylist hash table type has unencoded redis objects as keys and
+ * lists as values. It's used for blocking operations (BLPOP) and to
+ * map swapped keys to a list of clients waiting for this keys to be loaded. */
+static dictType keylistDictType = {
+    dictObjHash,                /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictObjKeyCompare,          /* key compare */
+    dictRedisObjectDestructor,  /* key destructor */
+    dictListDestructor          /* val destructor */
+};
+
+static void version();
+
+/* ========================= Random utility functions ======================= */
+
+/* Redis generally does not try to recover from out of memory conditions
+ * when allocating objects or strings, it is not clear if it will be possible
+ * to report this condition to the client since the networking layer itself
+ * is based on heap allocation for send buffers, so we simply abort.
+ * At least the code will be simpler to read... */
+static void oom(const char *msg) {
+    redisLog(REDIS_WARNING, "%s: Out of memory\n",msg);
+    sleep(1);
+    abort();
+}
+
+/* ====================== Redis server networking stuff ===================== */
+static void closeTimedoutClients(void) {
+    redisClient *c;
+    listNode *ln;
+    time_t now = time(NULL);
+    listIter li;
+
+    listRewind(server.clients,&li);
+    while ((ln = listNext(&li)) != NULL) {
+        c = listNodeValue(ln);
+        if (server.maxidletime &&
+            !(c->flags & REDIS_SLAVE) &&    /* no timeout for slaves */
+            !(c->flags & REDIS_MASTER) &&   /* no timeout for masters */
+            dictSize(c->pubsub_channels) == 0 && /* no timeout for pubsub */
+            listLength(c->pubsub_patterns) == 0 &&
+            (now - c->lastinteraction > server.maxidletime))
+        {
+            redisLog(REDIS_VERBOSE,"Closing idle client");
+            freeClient(c);
+        } else if (c->flags & REDIS_BLOCKED) {
+            if (c->blockingto != 0 && c->blockingto < now) {
+                addReply(c,shared.nullmultibulk);
+                unblockClientWaitingData(c);
+            }
+        }
+    }
+}
+
+static int htNeedsResize(dict *dict) {
+    long long size, used;
+
+    size = dictSlots(dict);
+    used = dictSize(dict);
+    return (size && used && size > DICT_HT_INITIAL_SIZE &&
+            (used*100/size < REDIS_HT_MINFILL));
+}
+
+/* If the percentage of used slots in the HT reaches REDIS_HT_MINFILL
+ * we resize the hash table to save memory */
+static void tryResizeHashTables(void) {
+    int j;
+
+    for (j = 0; j < server.dbnum; j++) {
+        if (htNeedsResize(server.db[j].dict))
+            dictResize(server.db[j].dict);
+        if (htNeedsResize(server.db[j].expires))
+            dictResize(server.db[j].expires);
+    }
+}
+
+/* Our hash table implementation performs rehashing incrementally while
+ * we write/read from the hash table. Still if the server is idle, the hash
+ * table will use two tables for a long time. So we try to use 1 millisecond
+ * of CPU time at every serverCron() loop in order to rehash some key. */
+static void incrementallyRehash(void) {
+    int j;
+
+    for (j = 0; j < server.dbnum; j++) {
+        if (dictIsRehashing(server.db[j].dict)) {
+            dictRehashMilliseconds(server.db[j].dict,1);
+            break; /* already used our millisecond for this loop... */
+        }
+    }
+}
+
+/* This function is called once a background process of some kind terminates,
+ * as we want to avoid resizing the hash tables when there is a child in order
+ * to play well with copy-on-write (otherwise when a resize happens lots of
+ * memory pages are copied). The goal of this function is to update the ability
+ * for dict.c to resize the hash tables accordingly to the fact we have o not
+ * running childs. */
+static void updateDictResizePolicy(void) {
+        dictDisableResize();
+}
+
+static int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
+    int j, loops = server.cronloops++;
+    REDIS_NOTUSED(eventLoop);
+    REDIS_NOTUSED(id);
+    REDIS_NOTUSED(clientData);
+
+    /* We take a cached value of the unix time in the global state because
+     * with virtual memory and aging there is to store the current time
+     * in objects at every object access, and accuracy is not needed.
+     * To access a global var is faster than calling time(NULL) */
+    server.unixtime = time(NULL);
+
+    /* We received a SIGTERM, shutting down here in a safe way, as it is
+     * not ok doing so inside the signal handler. */
+    if (server.shutdown_asap) {
+        if (prepareForShutdown() == REDIS_OK) exit(0);
+        redisLog(REDIS_WARNING,"SIGTERM received but errors trying to shut down the server, check the logs for more information");
+    }
+
+    /* Show some info about non-empty databases */
+    for (j = 0; j < server.dbnum; j++) {
+        long long size, used, vkeys;
+
+        size = dictSlots(server.db[j].dict);
+        used = dictSize(server.db[j].dict);
+        vkeys = dictSize(server.db[j].expires);
+        if (!(loops % 50) && (used || vkeys)) {
+            redisLog(REDIS_VERBOSE,"DB %d: %lld keys (%lld volatile) in %lld slots HT.",j,used,vkeys,size);
+            /* dictPrintStats(server.dict); */
+        }
+    }
+
+
+    /* Show information about connected clients */
+    if (!(loops % 50)) {
+        redisLog(REDIS_VERBOSE,"%d clients connected (%d slaves), %zu bytes in use",
+            listLength(server.clients)-listLength(server.slaves),
+            listLength(server.slaves),
+            zmalloc_used_memory());
+    }
+
+    /* Close connections of timedout clients */
+    if ((server.maxidletime && !(loops % 100)) || server.blpop_blocked_clients)
+        closeTimedoutClients();
+
+    /* Try to expire a few timed out keys. The algorithm used is adaptive and
+     * will use few CPU cycles if there are few expiring keys, otherwise
+     * it will get more aggressive to avoid that too much memory is used by
+     * keys that can be removed from the keyspace. */
+    for (j = 0; j < server.dbnum; j++) {
+        int expired;
+        redisDb *db = server.db+j;
+
+        /* Continue to expire if at the end of the cycle more than 25%
+         * of the keys were expired. */
+        do {
+            long num = dictSize(db->expires);
+            time_t now = time(NULL);
+
+            expired = 0;
+            if (num > REDIS_EXPIRELOOKUPS_PER_CRON)
+                num = REDIS_EXPIRELOOKUPS_PER_CRON;
+            while (num--) {
+                dictEntry *de;
+                robj *key;
+                time_t t;
+
+                if ((de = dictGetRandomKey(db->expires)) == NULL) break;
+                t = (time_t) dictGetEntryVal(de);
+                key = dictGetEntryKey(de);
+                /* Don't expire keys that are in the contest of I/O jobs.
+                 * Otherwise decrRefCount will kill the I/O thread and
+                 * clients waiting for this keys will wait forever.
+                 *
+                 * In general this change will not have any impact on the
+                 * performance of the expiring algorithm but it's much safer. */
+                if (now > t) {
+                    deleteKey(db,dictGetEntryKey(de));
+                    expired++;
+                    server.stat_expiredkeys++;
+                }
+            }
+        } while (expired > REDIS_EXPIRELOOKUPS_PER_CRON/4);
+    }
+
+    /* Check if we should connect to a MASTER */
+    if (server.replstate == REDIS_REPL_CONNECT && !(loops % 10)) {
+        redisLog(REDIS_NOTICE,"Connecting to MASTER...");
+    }
+    return 100;
+}
+
+/* This function gets called every time Redis is entering the
+ * main loop of the event driven library, that is, before to sleep
+ * for ready file descriptors. */
+static void beforeSleep(struct aeEventLoop *eventLoop) {
+    REDIS_NOTUSED(eventLoop);
+}
+
+static void createSharedObjects(void) {
+    int j;
+
+    shared.crlf = createObject(REDIS_STRING,sdsnew("\r\n"));
+    shared.ok = createObject(REDIS_STRING,sdsnew("+OK\r\n"));
+    shared.err = createObject(REDIS_STRING,sdsnew("-ERR\r\n"));
+    shared.emptybulk = createObject(REDIS_STRING,sdsnew("$0\r\n\r\n"));
+    shared.czero = createObject(REDIS_STRING,sdsnew(":0\r\n"));
+    shared.cone = createObject(REDIS_STRING,sdsnew(":1\r\n"));
+    shared.nullbulk = createObject(REDIS_STRING,sdsnew("$-1\r\n"));
+    shared.nullmultibulk = createObject(REDIS_STRING,sdsnew("*-1\r\n"));
+    shared.emptymultibulk = createObject(REDIS_STRING,sdsnew("*0\r\n"));
+    shared.pong = createObject(REDIS_STRING,sdsnew("+PONG\r\n"));
+    shared.queued = createObject(REDIS_STRING,sdsnew("+QUEUED\r\n"));
+    shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(
+        "-ERR Operation against a key holding the wrong kind of value\r\n"));
+    shared.nokeyerr = createObject(REDIS_STRING,sdsnew(
+        "-ERR no such key\r\n"));
+    shared.syntaxerr = createObject(REDIS_STRING,sdsnew(
+        "-ERR syntax error\r\n"));
+    shared.sameobjecterr = createObject(REDIS_STRING,sdsnew(
+        "-ERR source and destination objects are the same\r\n"));
+    shared.outofrangeerr = createObject(REDIS_STRING,sdsnew(
+        "-ERR index out of range\r\n"));
+    shared.space = createObject(REDIS_STRING,sdsnew(" "));
+    shared.colon = createObject(REDIS_STRING,sdsnew(":"));
+    shared.plus = createObject(REDIS_STRING,sdsnew("+"));
+    shared.select0 = createStringObject("select 0\r\n",10);
+    shared.select1 = createStringObject("select 1\r\n",10);
+    shared.select2 = createStringObject("select 2\r\n",10);
+    shared.select3 = createStringObject("select 3\r\n",10);
+    shared.select4 = createStringObject("select 4\r\n",10);
+    shared.select5 = createStringObject("select 5\r\n",10);
+    shared.select6 = createStringObject("select 6\r\n",10);
+    shared.select7 = createStringObject("select 7\r\n",10);
+    shared.select8 = createStringObject("select 8\r\n",10);
+    shared.select9 = createStringObject("select 9\r\n",10);
+    shared.messagebulk = createStringObject("$7\r\nmessage\r\n",13);
+    shared.pmessagebulk = createStringObject("$8\r\npmessage\r\n",14);
+    shared.subscribebulk = createStringObject("$9\r\nsubscribe\r\n",15);
+    shared.unsubscribebulk = createStringObject("$11\r\nunsubscribe\r\n",18);
+    shared.psubscribebulk = createStringObject("$10\r\npsubscribe\r\n",17);
+    shared.punsubscribebulk = createStringObject("$12\r\npunsubscribe\r\n",19);
+    shared.mbulk3 = createStringObject("*3\r\n",4);
+    shared.mbulk4 = createStringObject("*4\r\n",4);
+    for (j = 0; j < REDIS_SHARED_INTEGERS; j++) {
+        shared.integers[j] = createObject(REDIS_STRING,(void*)(long)j);
+        shared.integers[j]->encoding = REDIS_ENCODING_INT;
+    }
+}
+
+static void initServerConfig() {
+    //extern int main_port;
+    //printf("==================> main_port:%d\n", main_port);
+    server.dbnum = REDIS_DEFAULT_DBNUM;
+    server.port = REDIS_SERVERPORT;//main_port++;
+    server.verbosity = REDIS_VERBOSE;
+    server.maxidletime = REDIS_MAXIDLETIME;
+    server.logfile = NULL; /* NULL = log on standard output */
+    server.bindaddr = NULL;
+    server.glueoutputbuf = 1;
+    server.lastfsync = time(NULL);
+    server.requirepass = NULL;
+    server.activerehashing = 1;
+    server.maxclients = 256;
+    server.blpop_blocked_clients = 0;
+    server.maxmemory = 0;
+    server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES;
+    server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE;
+    server.shutdown_asap = 0;
+
+
+
+    server.isslave = 0;
+    server.masterauth = NULL;
+    server.masterhost = NULL;
+    server.masterport = 6379;
+    server.master = NULL;
+    server.replstate = REDIS_REPL_NONE;
+
+    /* Double constants initialization */
+    R_Zero = 0.0;
+    R_PosInf = 1.0/R_Zero;
+    R_NegInf = -1.0/R_Zero;
+    R_Nan = R_Zero/R_Zero;
+}
+
+static void initServer() {
+    int j;
+
+    signal(SIGHUP, SIG_IGN);
+    signal(SIGPIPE, SIG_IGN);
+    setupSigSegvAction();
+
+    server.devnull = fopen("/dev/null","w");
+    if (server.devnull == NULL) {
+        redisLog(REDIS_WARNING, "Can't open /dev/null: %s", server.neterr);
+        //exit(1);
+    }
+    server.clients = listCreate();
+    server.slaves = listCreate();
+    server.monitors = listCreate();
+    server.objfreelist = listCreate();
+    createSharedObjects();
+    server.el = aeCreateEventLoop();
+    server.db = zmalloc(sizeof(redisDb)*server.dbnum);
+    server.fd = anetTcpServer(server.neterr, server.port, server.bindaddr);
+    if (server.fd == -1) {
+        redisLog(REDIS_WARNING, "Opening TCP port: %s", server.neterr);
+        exit(1);
+    }
+    for (j = 0; j < server.dbnum; j++) {
+        server.db[j].dict = dictCreate(&dbDictType,NULL);
+        server.db[j].expires = dictCreate(&keyptrDictType,NULL);
+        server.db[j].blockingkeys = dictCreate(&keylistDictType,NULL);
+        server.db[j].id = j;
+    }
+    server.pubsub_channels = dictCreate(&keylistDictType,NULL);
+    server.pubsub_patterns = listCreate();
+    listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);
+    listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);
+    server.cronloops = 0;
+    server.lastsave = time(NULL);
+    server.stat_numcommands = 0;
+    server.stat_numconnections = 0;
+    server.stat_expiredkeys = 0;
+    server.stat_starttime = time(NULL);
+    server.unixtime = time(NULL);
+    aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL);
+    if (aeCreateFileEvent(server.el, server.fd, AE_READABLE,
+        acceptHandler, NULL) == AE_ERR) oom("creating file event");
+
+}
+
+/* Empty the whole database */
+static long long emptyDb() {
+    int j;
+    long long removed = 0;
+
+    for (j = 0; j < server.dbnum; j++) {
+        removed += dictSize(server.db[j].dict);
+        dictEmpty(server.db[j].dict);
+        dictEmpty(server.db[j].expires);
+    }
+    return removed;
+}
+
+static int yesnotoi(char *s) {
+    if (!strcasecmp(s,"yes")) return 1;
+    else if (!strcasecmp(s,"no")) return 0;
+    else return -1;
+}
+
+/* I agree, this is a very rudimental way to load a configuration...
+   will improve later if the config gets more complex */
+static void loadServerConfig(char *filename) {
+    FILE *fp;
+    char buf[REDIS_CONFIGLINE_MAX+1], *err = NULL;
+    int linenum = 0;
+    sds line = NULL;
+
+    if (filename[0] == '-' && filename[1] == '\0')
+        fp = stdin;
+    else {
+        if ((fp = fopen(filename,"r")) == NULL) {
+            redisLog(REDIS_WARNING, "Fatal error, can't open config file '%s'", filename);
+            exit(1);
+        }
+    }
+
+    while(fgets(buf,REDIS_CONFIGLINE_MAX+1,fp) != NULL) {
+        sds *argv;
+        int argc, j;
+
+        linenum++;
+        line = sdsnew(buf);
+        line = sdstrim(line," \t\r\n");
+
+        /* Skip comments and blank lines*/
+        if (line[0] == '#' || line[0] == '\0') {
+            sdsfree(line);
+            continue;
+        }
+
+        /* Split into arguments */
+        argv = sdssplitlen(line,sdslen(line)," ",1,&argc);
+        sdstolower(argv[0]);
+
+        /* Execute config directives */
+        if (!strcasecmp(argv[0],"timeout") && argc == 2) {
+            server.maxidletime = atoi(argv[1]);
+            if (server.maxidletime < 0) {
+                err = "Invalid timeout value"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"port") && argc == 2) {
+            server.port = atoi(argv[1]);
+            if (server.port < 1 || server.port > 65535) {
+                err = "Invalid port"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"bind") && argc == 2) {
+            server.bindaddr = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"dir") && argc == 2) {
+            if (chdir(argv[1]) == -1) {
+                redisLog(REDIS_WARNING,"Can't chdir to '%s': %s",
+                    argv[1], strerror(errno));
+                exit(1);
+            }
+        } else if (!strcasecmp(argv[0],"loglevel") && argc == 2) {
+            if (!strcasecmp(argv[1],"debug")) server.verbosity = REDIS_DEBUG;
+            else if (!strcasecmp(argv[1],"verbose")) server.verbosity = REDIS_VERBOSE;
+            else if (!strcasecmp(argv[1],"notice")) server.verbosity = REDIS_NOTICE;
+            else if (!strcasecmp(argv[1],"warning")) server.verbosity = REDIS_WARNING;
+            else {
+                err = "Invalid log level. Must be one of debug, notice, warning";
+                goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"logfile") && argc == 2) {
+            FILE *logfp;
+
+            server.logfile = zstrdup(argv[1]);
+            if (!strcasecmp(server.logfile,"stdout")) {
+                zfree(server.logfile);
+                server.logfile = NULL;
+            }
+            if (server.logfile) {
+                /* Test if we are able to open the file. The server will not
+                 * be able to abort just for this problem later... */
+                logfp = fopen(server.logfile,"a");
+                if (logfp == NULL) {
+                    err = sdscatprintf(sdsempty(),
+                        "Can't open the log file: %s", strerror(errno));
+                    goto loaderr;
+                }
+                fclose(logfp);
+            }
+        } else if (!strcasecmp(argv[0],"databases") && argc == 2) {
+            server.dbnum = atoi(argv[1]);
+            if (server.dbnum < 1) {
+                err = "Invalid number of databases"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"include") && argc == 2) {
+            loadServerConfig(argv[1]);
+        } else if (!strcasecmp(argv[0],"maxclients") && argc == 2) {
+            server.maxclients = atoi(argv[1]);
+		printf("-----------------------------> %d\n", server.maxclients);
+        } else if (!strcasecmp(argv[0],"maxmemory") && argc == 2) {
+            server.maxmemory = memtoll(argv[1],NULL);
+        } else if (!strcasecmp(argv[0],"slaveof") && argc == 3) {
+            server.masterhost = sdsnew(argv[1]);
+            server.masterport = atoi(argv[2]);
+            server.replstate = REDIS_REPL_CONNECT;
+        } else if (!strcasecmp(argv[0],"masterauth") && argc == 2) {
+        	server.masterauth = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"glueoutputbuf") && argc == 2) {
+            if ((server.glueoutputbuf = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"activerehashing") && argc == 2) {
+            if ((server.activerehashing = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"requirepass") && argc == 2) {
+            server.requirepass = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"dbfilename") && argc == 2) {
+            zfree(server.dbfilename);
+            server.dbfilename = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"hash-max-zipmap-entries") && argc == 2){
+            server.hash_max_zipmap_entries = memtoll(argv[1], NULL);
+        } else if (!strcasecmp(argv[0],"hash-max-zipmap-value") && argc == 2){
+            server.hash_max_zipmap_value = memtoll(argv[1], NULL);
+        } else {
+            err = "Bad directive or wrong number of arguments"; goto loaderr;
+        }
+        for (j = 0; j < argc; j++)
+            sdsfree(argv[j]);
+        zfree(argv);
+        sdsfree(line);
+    }
+    if (fp != stdin) fclose(fp);
+    return;
+
+loaderr:
+    fprintf(stderr, "\n*** FATAL CONFIG FILE ERROR ***\n");
+    fprintf(stderr, "Reading the configuration file, at line %d\n", linenum);
+    fprintf(stderr, ">>> '%s'\n", line);
+    fprintf(stderr, "%s\n", err);
+    exit(1);
+}
+
+static void freeClientArgv(redisClient *c) {
+    int j;
+
+    for (j = 0; j < c->argc; j++)
+        decrRefCount(c->argv[j]);
+    for (j = 0; j < c->mbargc; j++)
+        decrRefCount(c->mbargv[j]);
+    c->argc = 0;
+    c->mbargc = 0;
+}
+
+static void freeClient(redisClient *c) {
+    listNode *ln;
+
+    /* Note that if the client we are freeing is blocked into a blocking
+     * call, we have to set querybuf to NULL *before* to call
+     * unblockClientWaitingData() to avoid processInputBuffer() will get
+     * called. Also it is important to remove the file events after
+     * this, because this call adds the READABLE event. */
+    sdsfree(c->querybuf);
+    c->querybuf = NULL;
+    if (c->flags & REDIS_BLOCKED)
+        unblockClientWaitingData(c);
+
+    /* Unsubscribe from all the pubsub channels */
+    pubsubUnsubscribeAllChannels(c,0);
+    pubsubUnsubscribeAllPatterns(c,0);
+    dictRelease(c->pubsub_channels);
+    listRelease(c->pubsub_patterns);
+    /* Obvious cleanup */
+    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
+    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+    listRelease(c->reply);
+    freeClientArgv(c);
+    close(c->fd);
+    /* Remove from the list of clients */
+    ln = listSearchKey(server.clients,c);
+    redisAssert(ln != NULL);
+    listDelNode(server.clients,ln);
+    /* Master/slave cleanup */
+    if (c->flags & REDIS_SLAVE) {
+        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)
+            close(c->repldbfd);
+        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;
+        ln = listSearchKey(l,c);
+        redisAssert(ln != NULL);
+        listDelNode(l,ln);
+    }
+    if (c->flags & REDIS_MASTER) {
+        server.master = NULL;
+        server.replstate = REDIS_REPL_CONNECT;
+    }
+    /* Release memory */
+    zfree(c->argv);
+    zfree(c->mbargv);
+    freeClientMultiState(c);
+    zfree(c);
+}
+
+#define GLUEREPLY_UP_TO (1024)
+static void glueReplyBuffersIfNeeded(redisClient *c) {
+    int copylen = 0;
+    char buf[GLUEREPLY_UP_TO];
+    listNode *ln;
+    listIter li;
+    robj *o;
+
+    listRewind(c->reply,&li);
+    while((ln = listNext(&li))) {
+        int objlen;
+
+        o = ln->value;
+        objlen = sdslen(o->ptr);
+        if (copylen + objlen <= GLUEREPLY_UP_TO) {
+            memcpy(buf+copylen,o->ptr,objlen);
+            copylen += objlen;
+            listDelNode(c->reply,ln);
+        } else {
+            if (copylen == 0) return;
+            break;
+        }
+    }
+    /* Now the output buffer is empty, add the new single element */
+    o = createObject(REDIS_STRING,sdsnewlen(buf,copylen));
+    listAddNodeHead(c->reply,o);
+}
+
+static void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
+    redisClient *c = privdata;
+    int nwritten = 0, totwritten = 0, objlen;
+    robj *o;
+    REDIS_NOTUSED(el);
+    REDIS_NOTUSED(mask);
+
+    /* Use writev() if we have enough buffers to send */
+    if (!server.glueoutputbuf &&
+        listLength(c->reply) > REDIS_WRITEV_THRESHOLD &&
+        !(c->flags & REDIS_MASTER))
+    {
+        return;
+    }
+
+    while(listLength(c->reply)) {
+        if (server.glueoutputbuf && listLength(c->reply) > 1)
+            glueReplyBuffersIfNeeded(c);
+
+        o = listNodeValue(listFirst(c->reply));
+        objlen = sdslen(o->ptr);
+
+        if (objlen == 0) {
+            listDelNode(c->reply,listFirst(c->reply));
+            continue;
+        }
+
+        if (c->flags & REDIS_MASTER) {
+            /* Don't reply to a master */
+            nwritten = objlen - c->sentlen;
+        } else {
+            nwritten = write(fd, ((char*)o->ptr)+c->sentlen, objlen - c->sentlen);
+            if (nwritten <= 0) break;
+        }
+        c->sentlen += nwritten;
+        totwritten += nwritten;
+        /* If we fully sent the object on head go to the next one */
+        if (c->sentlen == objlen) {
+            listDelNode(c->reply,listFirst(c->reply));
+            c->sentlen = 0;
+        }
+        /* Note that we avoid to send more thank REDIS_MAX_WRITE_PER_EVENT
+         * bytes, in a single threaded server it's a good idea to serve
+         * other clients as well, even if a very large request comes from
+         * super fast link that is always able to accept data (in real world
+         * scenario think about 'KEYS *' against the loopback interfae) */
+        if (totwritten > REDIS_MAX_WRITE_PER_EVENT) break;
+    }
+    if (nwritten == -1) {
+        if (errno == EAGAIN) {
+            nwritten = 0;
+        } else {
+            redisLog(REDIS_VERBOSE,
+                "Error writing to client: %s", strerror(errno));
+            freeClient(c);
+            return;
+        }
+    }
+    if (totwritten > 0) c->lastinteraction = time(NULL);
+    if (listLength(c->reply) == 0) {
+        c->sentlen = 0;
+        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+    }
+}
+
+
+static struct redisCommand *lookupCommand(char *name) {
+    int j = 0;
+    while(cmdTable[j].name != NULL) {
+        if (!strcasecmp(name,cmdTable[j].name)) return &cmdTable[j];
+        j++;
+    }
+    return NULL;
+}
+
+/* resetClient prepare the client to process the next command */
+static void resetClient(redisClient *c) {
+    freeClientArgv(c);
+    c->bulklen = -1;
+    c->multibulk = 0;
+}
+
+/* Call() is the core of Redis execution of a command */
+static void call(redisClient *c, struct redisCommand *cmd) {
+    long long dirty;
+
+    dirty = server.dirty;
+    cmd->proc(c);
+    dirty = server.dirty-dirty;
+    if ((dirty || cmd->flags & REDIS_CMD_FORCE_REPLICATION) &&
+        listLength(server.slaves))
+        replicationFeedSlaves(server.slaves,c->db->id,c->argv,c->argc);
+    if (listLength(server.monitors))
+        replicationFeedMonitors(server.monitors,c->db->id,c->argv,c->argc);
+    server.stat_numcommands++;
+}
+
+/* If this function gets called we already read a whole
+ * command, argments are in the client argv/argc fields.
+ * processCommand() execute the command or prepare the
+ * server for a bulk read from the client.
+ *
+ * If 1 is returned the client is still alive and valid and
+ * and other operations can be performed by the caller. Otherwise
+ * if 0 is returned the client was destroied (i.e. after QUIT). */
+static int processCommand(redisClient *c) {
+    struct redisCommand *cmd;
+
+    /* Handle the multi bulk command type. This is an alternative protocol
+     * supported by Redis in order to receive commands that are composed of
+     * multiple binary-safe "bulk" arguments. The latency of processing is
+     * a bit higher but this allows things like multi-sets, so if this
+     * protocol is used only for MSET and similar commands this is a big win. */
+    if (c->multibulk == 0 && c->argc == 1 && ((char*)(c->argv[0]->ptr))[0] == '*') {
+        c->multibulk = atoi(((char*)c->argv[0]->ptr)+1);
+        if (c->multibulk <= 0) {
+            resetClient(c);
+            return 1;
+        } else {
+            decrRefCount(c->argv[c->argc-1]);
+            c->argc--;
+            return 1;
+        }
+    } else if (c->multibulk) {
+        if (c->bulklen == -1) {
+            if (((char*)c->argv[0]->ptr)[0] != '$') {
+                addReplySds(c,sdsnew("-ERR multi bulk protocol error\r\n"));
+                resetClient(c);
+                return 1;
+            } else {
+                int bulklen = atoi(((char*)c->argv[0]->ptr)+1);
+                decrRefCount(c->argv[0]);
+                if (bulklen < 0 || bulklen > 1024*1024*1024) {
+                    c->argc--;
+                    addReplySds(c,sdsnew("-ERR invalid bulk write count\r\n"));
+                    resetClient(c);
+                    return 1;
+                }
+                c->argc--;
+                c->bulklen = bulklen+2; /* add two bytes for CR+LF */
+                return 1;
+            }
+        } else {
+            c->mbargv = zrealloc(c->mbargv,(sizeof(robj*))*(c->mbargc+1));
+            c->mbargv[c->mbargc] = c->argv[0];
+            c->mbargc++;
+            c->argc--;
+            c->multibulk--;
+            if (c->multibulk == 0) {
+                robj **auxargv;
+                int auxargc;
+
+                /* Here we need to swap the multi-bulk argc/argv with the
+                 * normal argc/argv of the client structure. */
+                auxargv = c->argv;
+                c->argv = c->mbargv;
+                c->mbargv = auxargv;
+
+                auxargc = c->argc;
+                c->argc = c->mbargc;
+                c->mbargc = auxargc;
+
+                /* We need to set bulklen to something different than -1
+                 * in order for the code below to process the command without
+                 * to try to read the last argument of a bulk command as
+                 * a special argument. */
+                c->bulklen = 0;
+                /* continue below and process the command */
+            } else {
+                c->bulklen = -1;
+                return 1;
+            }
+        }
+    }
+    /* -- end of multi bulk commands processing -- */
+
+    /* The QUIT command is handled as a special case. Normal command
+     * procs are unable to close the client connection safely */
+    if (!strcasecmp(c->argv[0]->ptr,"quit")) {
+        freeClient(c);
+        return 0;
+    }
+
+    /* Now lookup the command and check ASAP about trivial error conditions
+     * such wrong arity, bad command name and so forth. */
+    cmd = lookupCommand(c->argv[0]->ptr);
+    if (!cmd) {
+        addReplySds(c,
+            sdscatprintf(sdsempty(), "-ERR unknown command '%s'\r\n",
+                (char*)c->argv[0]->ptr));
+        resetClient(c);
+        return 1;
+    } else if ((cmd->arity > 0 && cmd->arity != c->argc) ||
+               (c->argc < -cmd->arity)) {
+        addReplySds(c,
+            sdscatprintf(sdsempty(),
+                "-ERR wrong number of arguments for '%s' command\r\n",
+                cmd->name));
+        resetClient(c);
+        return 1;
+    } else if (cmd->flags & REDIS_CMD_BULK && c->bulklen == -1) {
+        /* This is a bulk command, we have to read the last argument yet. */
+        int bulklen = atoi(c->argv[c->argc-1]->ptr);
+
+        decrRefCount(c->argv[c->argc-1]);
+        if (bulklen < 0 || bulklen > 1024*1024*1024) {
+            c->argc--;
+            addReplySds(c,sdsnew("-ERR invalid bulk write count\r\n"));
+            resetClient(c);
+            return 1;
+        }
+        c->argc--;
+        c->bulklen = bulklen+2; /* add two bytes for CR+LF */
+        /* It is possible that the bulk read is already in the
+         * buffer. Check this condition and handle it accordingly.
+         * This is just a fast path, alternative to call processInputBuffer().
+         * It's a good idea since the code is small and this condition
+         * happens most of the times. */
+        if ((signed)sdslen(c->querybuf) >= c->bulklen) {
+            c->argv[c->argc] = createStringObject(c->querybuf,c->bulklen-2);
+            c->argc++;
+            c->querybuf = sdsrange(c->querybuf,c->bulklen,-1);
+        } else {
+            /* Otherwise return... there is to read the last argument
+             * from the socket. */
+            return 1;
+        }
+    }
+    /* Let's try to encode the bulk object to save space. */
+    if (cmd->flags & REDIS_CMD_BULK)
+        c->argv[c->argc-1] = tryObjectEncoding(c->argv[c->argc-1]);
+
+    /* Check if the user is authenticated */
+    if (server.requirepass && !c->authenticated && cmd->proc != authCommand) {
+        addReplySds(c,sdsnew("-ERR operation not permitted\r\n"));
+        resetClient(c);
+        return 1;
+    }
+
+    /* Handle the maxmemory directive.
+     *
+     * First we try to free some memory if possible (if there are volatile
+     * keys in the dataset). If there are not the only thing we can do
+     * is returning an error. */
+    if (server.maxmemory) freeMemoryIfNeeded();
+    if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) &&
+        zmalloc_used_memory() > server.maxmemory)
+    {
+        addReplySds(c,sdsnew("-ERR command not allowed when used memory > 'maxmemory'\r\n"));
+        resetClient(c);
+        return 1;
+    }
+
+    /* Only allow SUBSCRIBE and UNSUBSCRIBE in the context of Pub/Sub */
+    if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0)
+        &&
+        cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand &&
+        cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) {
+        addReplySds(c,sdsnew("-ERR only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context\r\n"));
+        resetClient(c);
+        return 1;
+    }
+
+    /* Exec the command */
+    if (c->flags & REDIS_MULTI && cmd->proc != execCommand && cmd->proc != discardCommand) {
+        queueMultiCommand(c,cmd);
+        addReply(c,shared.queued);
+    } else {
+        call(c,cmd);
+    }
+
+    /* Prepare the client for the next command */
+    resetClient(c);
+    return 1;
+}
+
+static void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
+    listNode *ln;
+    listIter li;
+    int outc = 0, j;
+    robj **outv;
+    /* We need 1+(ARGS*3) objects since commands are using the new protocol
+     * and we one 1 object for the first "*<count>\r\n" multibulk count, then
+     * for every additional object we have "$<count>\r\n" + object + "\r\n". */
+    robj *static_outv[REDIS_STATIC_ARGS*3+1];
+    robj *lenobj;
+
+    if (argc <= REDIS_STATIC_ARGS) {
+        outv = static_outv;
+    } else {
+        outv = zmalloc(sizeof(robj*)*(argc*3+1));
+    }
+
+    lenobj = createObject(REDIS_STRING,
+            sdscatprintf(sdsempty(), "*%d\r\n", argc));
+    lenobj->refcount = 0;
+    outv[outc++] = lenobj;
+    for (j = 0; j < argc; j++) {
+        lenobj = createObject(REDIS_STRING,
+            sdscatprintf(sdsempty(),"$%lu\r\n",
+                (unsigned long) stringObjectLen(argv[j])));
+        lenobj->refcount = 0;
+        outv[outc++] = lenobj;
+        outv[outc++] = argv[j];
+        outv[outc++] = shared.crlf;
+    }
+
+    /* Increment all the refcounts at start and decrement at end in order to
+     * be sure to free objects if there is no slave in a replication state
+     * able to be feed with commands */
+    for (j = 0; j < outc; j++) incrRefCount(outv[j]);
+    listRewind(slaves,&li);
+    while((ln = listNext(&li))) {
+        redisClient *slave = ln->value;
+
+        /* Don't feed slaves that are still waiting for BGSAVE to start */
+        if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) continue;
+
+        /* Feed all the other slaves, MONITORs and so on */
+        if (slave->slaveseldb != dictid) {
+            robj *selectcmd;
+
+            switch(dictid) {
+            case 0: selectcmd = shared.select0; break;
+            case 1: selectcmd = shared.select1; break;
+            case 2: selectcmd = shared.select2; break;
+            case 3: selectcmd = shared.select3; break;
+            case 4: selectcmd = shared.select4; break;
+            case 5: selectcmd = shared.select5; break;
+            case 6: selectcmd = shared.select6; break;
+            case 7: selectcmd = shared.select7; break;
+            case 8: selectcmd = shared.select8; break;
+            case 9: selectcmd = shared.select9; break;
+            default:
+                selectcmd = createObject(REDIS_STRING,
+                    sdscatprintf(sdsempty(),"select %d\r\n",dictid));
+                selectcmd->refcount = 0;
+                break;
+            }
+            addReply(slave,selectcmd);
+            slave->slaveseldb = dictid;
+        }
+        for (j = 0; j < outc; j++) addReply(slave,outv[j]);
+    }
+    for (j = 0; j < outc; j++) decrRefCount(outv[j]);
+    if (outv != static_outv) zfree(outv);
+}
+
+static sds sdscatrepr(sds s, char *p, size_t len) {
+    s = sdscatlen(s,"\"",1);
+    while(len--) {
+        switch(*p) {
+        case '\\':
+        case '"':
+            s = sdscatprintf(s,"\\%c",*p);
+            break;
+        case '\n': s = sdscatlen(s,"\\n",1); break;
+        case '\r': s = sdscatlen(s,"\\r",1); break;
+        case '\t': s = sdscatlen(s,"\\t",1); break;
+        case '\a': s = sdscatlen(s,"\\a",1); break;
+        case '\b': s = sdscatlen(s,"\\b",1); break;
+        default:
+            if (isprint(*p))
+                s = sdscatprintf(s,"%c",*p);
+            else
+                s = sdscatprintf(s,"\\x%02x",(unsigned char)*p);
+            break;
+        }
+        p++;
+    }
+    return sdscatlen(s,"\"",1);
+}
+
+static void replicationFeedMonitors(list *monitors, int dictid, robj **argv, int argc) {
+    listNode *ln;
+    listIter li;
+    int j;
+    sds cmdrepr = sdsnew("+");
+    robj *cmdobj;
+    struct timeval tv;
+
+    gettimeofday(&tv,NULL);
+    cmdrepr = sdscatprintf(cmdrepr,"%ld.%ld ",(long)tv.tv_sec,(long)tv.tv_usec);
+    if (dictid != 0) cmdrepr = sdscatprintf(cmdrepr,"(db %d) ", dictid);
+
+    for (j = 0; j < argc; j++) {
+        if (argv[j]->encoding == REDIS_ENCODING_INT) {
+            cmdrepr = sdscatprintf(cmdrepr, "\"%ld\"", (long)argv[j]->ptr);
+        } else {
+            cmdrepr = sdscatrepr(cmdrepr,(char*)argv[j]->ptr,
+                        sdslen(argv[j]->ptr));
+        }
+        if (j != argc-1)
+            cmdrepr = sdscatlen(cmdrepr," ",1);
+    }
+    cmdrepr = sdscatlen(cmdrepr,"\r\n",2);
+    cmdobj = createObject(REDIS_STRING,cmdrepr);
+
+    listRewind(monitors,&li);
+    while((ln = listNext(&li))) {
+        redisClient *monitor = ln->value;
+        addReply(monitor,cmdobj);
+    }
+    decrRefCount(cmdobj);
+}
+
+static void processInputBuffer(redisClient *c) {
+again:
+    /* Before to process the input buffer, make sure the client is not
+     * waitig for a blocking operation such as BLPOP. Note that the first
+     * iteration the client is never blocked, otherwise the processInputBuffer
+     * would not be called at all, but after the execution of the first commands
+     * in the input buffer the client may be blocked, and the "goto again"
+     * will try to reiterate. The following line will make it return asap. */
+    if (c->flags & REDIS_BLOCKED || c->flags & REDIS_IO_WAIT) return;
+    if (c->bulklen == -1) {
+        /* Read the first line of the query */
+        char *p = strchr(c->querybuf,'\n');
+        size_t querylen;
+
+        if (p) {
+            sds query, *argv;
+            int argc, j;
+
+            query = c->querybuf;
+            c->querybuf = sdsempty();
+            querylen = 1+(p-(query));
+            if (sdslen(query) > querylen) {
+                /* leave data after the first line of the query in the buffer */
+                c->querybuf = sdscatlen(c->querybuf,query+querylen,sdslen(query)-querylen);
+            }
+            *p = '\0'; /* remove "\n" */
+            if (*(p-1) == '\r') *(p-1) = '\0'; /* and "\r" if any */
+            sdsupdatelen(query);
+
+            /* Now we can split the query in arguments */
+            argv = sdssplitlen(query,sdslen(query)," ",1,&argc);
+            sdsfree(query);
+
+            if (c->argv) zfree(c->argv);
+            c->argv = zmalloc(sizeof(robj*)*argc);
+
+            for (j = 0; j < argc; j++) {
+                if (sdslen(argv[j])) {
+                    c->argv[c->argc] = createObject(REDIS_STRING,argv[j]);
+                    c->argc++;
+                } else {
+                    sdsfree(argv[j]);
+                }
+            }
+            zfree(argv);
+            if (c->argc) {
+                /* Execute the command. If the client is still valid
+                 * after processCommand() return and there is something
+                 * on the query buffer try to process the next command. */
+                if (processCommand(c) && sdslen(c->querybuf)) goto again;
+            } else {
+                /* Nothing to process, argc == 0. Just process the query
+                 * buffer if it's not empty or return to the caller */
+                if (sdslen(c->querybuf)) goto again;
+            }
+            return;
+        } else if (sdslen(c->querybuf) >= REDIS_REQUEST_MAX_SIZE) {
+            redisLog(REDIS_VERBOSE, "Client protocol error");
+            freeClient(c);
+            return;
+        }
+    } else {
+        /* Bulk read handling. Note that if we are at this point
+           the client already sent a command terminated with a newline,
+           we are reading the bulk data that is actually the last
+           argument of the command. */
+        int qbl = sdslen(c->querybuf);
+
+        if (c->bulklen <= qbl) {
+            /* Copy everything but the final CRLF as final argument */
+            c->argv[c->argc] = createStringObject(c->querybuf,c->bulklen-2);
+            c->argc++;
+            c->querybuf = sdsrange(c->querybuf,c->bulklen,-1);
+            /* Process the command. If the client is still valid after
+             * the processing and there is more data in the buffer
+             * try to parse it. */
+            if (processCommand(c) && sdslen(c->querybuf)) goto again;
+            return;
+        }
+    }
+}
+
+static void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
+    redisClient *c = (redisClient*) privdata;
+    char buf[REDIS_IOBUF_LEN];
+    int nread;
+    REDIS_NOTUSED(el);
+    REDIS_NOTUSED(mask);
+
+    nread = read(fd, buf, REDIS_IOBUF_LEN);
+    if (nread == -1) {
+        if (errno == EAGAIN) {
+            nread = 0;
+        } else {
+            redisLog(REDIS_VERBOSE, "Reading from client: %s",strerror(errno));
+            freeClient(c);
+            return;
+        }
+    } else if (nread == 0) {
+        redisLog(REDIS_VERBOSE, "Client closed connection");
+        freeClient(c);
+        return;
+    }
+    if (nread) {
+        printf("handle the client[%d]\n", fd);
+        c->querybuf = sdscatlen(c->querybuf, buf, nread);
+        c->lastinteraction = time(NULL);
+    } else {
+        return;
+    }
+    processInputBuffer(c);
+}
+
+static int selectDb(redisClient *c, int id) {
+    if (id < 0 || id >= server.dbnum)
+        return REDIS_ERR;
+    c->db = &server.db[id];
+    return REDIS_OK;
+}
+
+static void *dupClientReplyValue(void *o) {
+    incrRefCount((robj*)o);
+    return o;
+}
+
+static int listMatchObjects(void *a, void *b) {
+    return equalStringObjects(a,b);
+}
+
+
+static redisClient *createClient(int fd) {
+    redisClient *c = zmalloc(sizeof(*c));
+
+    anetNonBlock(NULL,fd);
+    anetTcpNoDelay(NULL,fd);
+    if (!c) return NULL;
+    if (aeCreateFileEvent(server.el,fd,AE_READABLE,
+        readQueryFromClient, c) == AE_ERR)
+    {
+        close(fd);
+        zfree(c);
+        return NULL;
+    }
+
+    selectDb(c,0);
+    c->fd = fd;
+    c->querybuf = sdsempty();
+    c->argc = 0;
+    c->argv = NULL;
+    c->bulklen = -1;
+    c->multibulk = 0;
+    c->mbargc = 0;
+    c->mbargv = NULL;
+    c->sentlen = 0;
+    c->flags = 0;
+    c->lastinteraction = time(NULL);
+    c->authenticated = 0;
+    c->replstate = REDIS_REPL_NONE;
+    c->reply = listCreate();
+    listSetFreeMethod(c->reply,decrRefCount);
+    listSetDupMethod(c->reply,dupClientReplyValue);
+    c->blockingkeys = NULL;
+    c->blockingkeysnum = 0;
+    c->pubsub_channels = dictCreate(&setDictType,NULL);
+    c->pubsub_patterns = listCreate();
+    listSetFreeMethod(c->pubsub_patterns,decrRefCount);
+    listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
+    listAddNodeTail(server.clients,c);
+    initClientMultiState(c);
+    return c;
+}
+
+static void addReply(redisClient *c, robj *obj) {
+    if (listLength(c->reply) == 0 &&
+        (c->replstate == REDIS_REPL_NONE ||
+         c->replstate == REDIS_REPL_ONLINE) &&
+        aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,
+        sendReplyToClient, c) == AE_ERR) return;
+    listAddNodeTail(c->reply,getDecodedObject(obj));
+}
+
+static void addReplySds(redisClient *c, sds s) {
+    robj *o = createObject(REDIS_STRING,s);
+    addReply(c,o);
+    decrRefCount(o);
+}
+
+static void addReplyDouble(redisClient *c, double d) {
+    char buf[128];
+
+    snprintf(buf,sizeof(buf),"%.17g",d);
+    addReplySds(c,sdscatprintf(sdsempty(),"$%lu\r\n%s\r\n",
+        (unsigned long) strlen(buf),buf));
+}
+
+static void addReplyLongLong(redisClient *c, long long ll) {
+    char buf[128];
+    size_t len;
+
+    if (ll == 0) {
+        addReply(c,shared.czero);
+        return;
+    } else if (ll == 1) {
+        addReply(c,shared.cone);
+        return;
+    }
+    buf[0] = ':';
+    len = ll2string(buf+1,sizeof(buf)-1,ll);
+    buf[len+1] = '\r';
+    buf[len+2] = '\n';
+    addReplySds(c,sdsnewlen(buf,len+3));
+}
+
+static void addReplyUlong(redisClient *c, unsigned long ul) {
+    char buf[128];
+    size_t len;
+
+    if (ul == 0) {
+        addReply(c,shared.czero);
+        return;
+    } else if (ul == 1) {
+        addReply(c,shared.cone);
+        return;
+    }
+    len = snprintf(buf,sizeof(buf),":%lu\r\n",ul);
+    addReplySds(c,sdsnewlen(buf,len));
+}
+
+static void addReplyBulkLen(redisClient *c, robj *obj) {
+    size_t len, intlen;
+    char buf[128];
+
+    if (obj->encoding == REDIS_ENCODING_RAW) {
+        len = sdslen(obj->ptr);
+    } else {
+        long n = (long)obj->ptr;
+
+        /* Compute how many bytes will take this integer as a radix 10 string */
+        len = 1;
+        if (n < 0) {
+            len++;
+            n = -n;
+        }
+        while((n = n/10) != 0) {
+            len++;
+        }
+    }
+    buf[0] = '$';
+    intlen = ll2string(buf+1,sizeof(buf)-1,(long long)len);
+    buf[intlen+1] = '\r';
+    buf[intlen+2] = '\n';
+    addReplySds(c,sdsnewlen(buf,intlen+3));
+}
+
+static void addReplyBulk(redisClient *c, robj *obj) {
+    addReplyBulkLen(c,obj);
+    addReply(c,obj);
+    addReply(c,shared.crlf);
+}
+
+/* In the CONFIG command we need to add vanilla C string as bulk replies */
+static void addReplyBulkCString(redisClient *c, char *s) {
+    if (s == NULL) {
+        addReply(c,shared.nullbulk);
+    } else {
+        robj *o = createStringObject(s,strlen(s));
+        addReplyBulk(c,o);
+        decrRefCount(o);
+    }
+}
+
+static void acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
+    int cport, cfd;
+    char cip[128];
+    redisClient *c;
+    REDIS_NOTUSED(el);
+    REDIS_NOTUSED(mask);
+    REDIS_NOTUSED(privdata);
+
+    cfd = anetAccept(server.neterr, fd, cip, &cport);
+    if (cfd == AE_ERR) {
+        redisLog(REDIS_VERBOSE,"Accepting client connection: %s", server.neterr);
+        return;
+    }
+    redisLog(REDIS_VERBOSE,"Accepted %s:%d", cip, cport);
+    if ((c = createClient(cfd)) == NULL) {
+        redisLog(REDIS_WARNING,"Error allocating resoures for the client");
+        close(cfd); /* May be already closed, just ingore errors */
+        return;
+    }
+    /* If maxclient directive is set and this is one client more... close the
+     * connection. Note that we create the client instead to check before
+     * for this condition, since now the socket is already set in nonblocking
+     * mode and we can send an error for free using the Kernel I/O */
+    if (server.maxclients && listLength(server.clients) > server.maxclients) {
+        char *err = "-ERR max number of clients reached\r\n";
+printf("----------*********> %d\n", server.maxclients);
+
+        /* That's a best effort error message, don't check write errors */
+        if (write(c->fd,err,strlen(err)) == -1) {
+            /* Nothing to do, Just to avoid the warning... */
+        }
+        freeClient(c);
+        return;
+    }
+    server.stat_numconnections++;
+    printf("client amount: %d\n", server.stat_numconnections);
+}
+
+/* ======================= Redis objects implementation ===================== */
+
+static robj *createObject(int type, void *ptr) {
+    robj *o;
+
+    if (listLength(server.objfreelist)) {
+        listNode *head = listFirst(server.objfreelist);
+        o = listNodeValue(head);
+        listDelNode(server.objfreelist,head);
+    }else {
+		o = zmalloc(sizeof(*o));
+	}
+    o->type = type;
+    o->encoding = REDIS_ENCODING_RAW;
+    o->ptr = ptr;
+    o->refcount = 1;
+    return o;
+}
+
+static robj *createStringObject(char *ptr, size_t len) {
+    return createObject(REDIS_STRING,sdsnewlen(ptr,len));
+}
+
+static robj *createStringObjectFromLongLong(long long value) {
+    robj *o;
+    if (value >= 0 && value < REDIS_SHARED_INTEGERS) {
+        incrRefCount(shared.integers[value]);
+        o = shared.integers[value];
+    } else {
+        if (value >= LONG_MIN && value <= LONG_MAX) {
+            o = createObject(REDIS_STRING, NULL);
+            o->encoding = REDIS_ENCODING_INT;
+            o->ptr = (void*)((long)value);
+        } else {
+            o = createObject(REDIS_STRING,sdsfromlonglong(value));
+        }
+    }
+    return o;
+}
+
+static robj *dupStringObject(robj *o) {
+    assert(o->encoding == REDIS_ENCODING_RAW);
+    return createStringObject(o->ptr,sdslen(o->ptr));
+}
+
+static robj *createListObject(void) {
+    list *l = listCreate();
+
+    listSetFreeMethod(l,decrRefCount);
+    return createObject(REDIS_LIST,l);
+}
+
+static robj *createSetObject(void) {
+    dict *d = dictCreate(&setDictType,NULL);
+    return createObject(REDIS_SET,d);
+}
+
+static robj *createHashObject(void) {
+    /* All the Hashes start as zipmaps. Will be automatically converted
+     * into hash tables if there are enough elements or big elements
+     * inside. */
+    unsigned char *zm = zipmapNew();
+    robj *o = createObject(REDIS_HASH,zm);
+    o->encoding = REDIS_ENCODING_ZIPMAP;
+    return o;
+}
+
+static robj *createZsetObject(void) {
+    zset *zs = zmalloc(sizeof(*zs));
+
+    zs->dict = dictCreate(&zsetDictType,NULL);
+    zs->zsl = zslCreate();
+    return createObject(REDIS_ZSET,zs);
+}
+
+static void freeStringObject(robj *o) {
+    if (o->encoding == REDIS_ENCODING_RAW) {
+        sdsfree(o->ptr);
+    }
+}
+
+static void freeListObject(robj *o) {
+    listRelease((list*) o->ptr);
+}
+
+static void freeSetObject(robj *o) {
+    dictRelease((dict*) o->ptr);
+}
+
+static void freeZsetObject(robj *o) {
+    zset *zs = o->ptr;
+
+    dictRelease(zs->dict);
+    zslFree(zs->zsl);
+    zfree(zs);
+}
+
+static void freeHashObject(robj *o) {
+    switch (o->encoding) {
+    case REDIS_ENCODING_HT:
+        dictRelease((dict*) o->ptr);
+        break;
+    case REDIS_ENCODING_ZIPMAP:
+        zfree(o->ptr);
+        break;
+    default:
+        redisPanic("Unknown hash encoding type");
+        break;
+    }
+}
+
+static void incrRefCount(robj *o) {
+    o->refcount++;
+}
+
+static void decrRefCount(void *obj) {
+    robj *o = obj;
+
+    if (o->refcount <= 0) redisPanic("decrRefCount against refcount <= 0");
+    /* Object is in memory, or in the process of being swapped out. */
+    if (--(o->refcount) == 0) {
+        switch(o->type) {
+        case REDIS_STRING: freeStringObject(o); break;
+        case REDIS_LIST: freeListObject(o); break;
+        case REDIS_SET: freeSetObject(o); break;
+        case REDIS_ZSET: freeZsetObject(o); break;
+        case REDIS_HASH: freeHashObject(o); break;
+        default: redisPanic("Unknown object type"); break;
+        }
+        if (listLength(server.objfreelist) > REDIS_OBJFREELIST_MAX ||
+            !listAddNodeHead(server.objfreelist,o))
+            zfree(o);
+    }
+}
+
+static robj *lookupKey(redisDb *db, robj *key) {
+    dictEntry *de = dictFind(db->dict,key);
+    if (de) {
+        robj *key = dictGetEntryKey(de);
+        robj *val = dictGetEntryVal(de);
+        return val;
+    } else {
+        return NULL;
+    }
+}
+
+static robj *lookupKeyRead(redisDb *db, robj *key) {
+    expireIfNeeded(db,key);
+    return lookupKey(db,key);
+}
+
+static robj *lookupKeyWrite(redisDb *db, robj *key) {
+    deleteIfVolatile(db,key);
+    return lookupKey(db,key);
+}
+
+static robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply) {
+    robj *o = lookupKeyRead(c->db, key);
+    if (!o) addReply(c,reply);
+    return o;
+}
+
+static robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply) {
+    robj *o = lookupKeyWrite(c->db, key);
+    if (!o) addReply(c,reply);
+    return o;
+}
+
+static int checkType(redisClient *c, robj *o, int type) {
+    if (o->type != type) {
+        addReply(c,shared.wrongtypeerr);
+        return 1;
+    }
+    return 0;
+}
+
+static int deleteKey(redisDb *db, robj *key) {
+    int retval;
+
+    /* We need to protect key from destruction: after the first dictDelete()
+     * it may happen that 'key' is no longer valid if we don't increment
+     * it's count. This may happen when we get the object reference directly
+     * from the hash table with dictRandomKey() or dict iterators */
+    incrRefCount(key);
+    
+    if (dictSize(db->expires)) dictDelete(db->expires,key);
+    retval = dictDelete(db->dict,key);
+    decrRefCount(key);
+
+    return retval == DICT_OK;
+}
+
+/* Check if the nul-terminated string 's' can be represented by a long
+ * (that is, is a number that fits into long without any other space or
+ * character before or after the digits).
+ *
+ * If so, the function returns REDIS_OK and *longval is set to the value
+ * of the number. Otherwise REDIS_ERR is returned */
+static int isStringRepresentableAsLong(sds s, long *longval) {
+    char buf[32], *endptr;
+    long value;
+    int slen;
+
+    value = strtol(s, &endptr, 10);
+    if (endptr[0] != '\0') return REDIS_ERR;
+    slen = ll2string(buf,32,value);
+
+    /* If the number converted back into a string is not identical
+     * then it's not possible to encode the string as integer */
+    if (sdslen(s) != (unsigned)slen || memcmp(buf,s,slen)) return REDIS_ERR;
+    if (longval) *longval = value;
+    return REDIS_OK;
+}
+
+/* Try to encode a string object in order to save space */
+static robj *tryObjectEncoding(robj *o) {
+    long value;
+    sds s = o->ptr;
+
+    if (o->encoding != REDIS_ENCODING_RAW)
+        return o; /* Already encoded */
+
+    /* It's not safe to encode shared objects: shared objects can be shared
+     * everywhere in the "object space" of Redis. Encoded objects can only
+     * appear as "values" (and not, for instance, as keys) */
+     if (o->refcount > 1) return o;
+
+    /* Currently we try to encode only strings */
+    redisAssert(o->type == REDIS_STRING);
+
+    /* Check if we can represent this string as a long integer */
+    if (isStringRepresentableAsLong(s,&value) == REDIS_ERR) return o;
+
+    /* Ok, this object can be encoded...
+     *
+     * Can I use a shared object? Only if the object is inside a given
+     * range and if this is the main thread, since when VM is enabled we
+     * have the constraint that I/O thread should only handle non-shared
+     * objects, in order to avoid race conditions (we don't have per-object
+     * locking). */
+    if (value >= 0 && value < REDIS_SHARED_INTEGERS) {
+        decrRefCount(o);
+        incrRefCount(shared.integers[value]);
+        return shared.integers[value];
+    } else {
+        o->encoding = REDIS_ENCODING_INT;
+        sdsfree(o->ptr);
+        o->ptr = (void*) value;
+        return o;
+    }
+}
+
+/* Get a decoded version of an encoded object (returned as a new object).
+ * If the object is already raw-encoded just increment the ref count. */
+static robj *getDecodedObject(robj *o) {
+    robj *dec;
+
+    if (o->encoding == REDIS_ENCODING_RAW) {
+        incrRefCount(o);
+        return o;
+    }
+    if (o->type == REDIS_STRING && o->encoding == REDIS_ENCODING_INT) {
+        char buf[32];
+
+        ll2string(buf,32,(long)o->ptr);
+        dec = createStringObject(buf,strlen(buf));
+        return dec;
+    } else {
+        redisPanic("Unknown encoding type");
+    }
+}
+
+/* Compare two string objects via strcmp() or alike.
+ * Note that the objects may be integer-encoded. In such a case we
+ * use ll2string() to get a string representation of the numbers on the stack
+ * and compare the strings, it's much faster than calling getDecodedObject().
+ *
+ * Important note: if objects are not integer encoded, but binary-safe strings,
+ * sdscmp() from sds.c will apply memcmp() so this function ca be considered
+ * binary safe. */
+static int compareStringObjects(robj *a, robj *b) {
+    redisAssert(a->type == REDIS_STRING && b->type == REDIS_STRING);
+    char bufa[128], bufb[128], *astr, *bstr;
+    int bothsds = 1;
+
+    if (a == b) return 0;
+    if (a->encoding != REDIS_ENCODING_RAW) {
+        ll2string(bufa,sizeof(bufa),(long) a->ptr);
+        astr = bufa;
+        bothsds = 0;
+    } else {
+        astr = a->ptr;
+    }
+    if (b->encoding != REDIS_ENCODING_RAW) {
+        ll2string(bufb,sizeof(bufb),(long) b->ptr);
+        bstr = bufb;
+        bothsds = 0;
+    } else {
+        bstr = b->ptr;
+    }
+    return bothsds ? sdscmp(astr,bstr) : strcmp(astr,bstr);
+}
+
+/* Equal string objects return 1 if the two objects are the same from the
+ * point of view of a string comparison, otherwise 0 is returned. Note that
+ * this function is faster then checking for (compareStringObject(a,b) == 0)
+ * because it can perform some more optimization. */
+static int equalStringObjects(robj *a, robj *b) {
+    if (a->encoding != REDIS_ENCODING_RAW && b->encoding != REDIS_ENCODING_RAW){
+        return a->ptr == b->ptr;
+    } else {
+        return compareStringObjects(a,b) == 0;
+    }
+}
+
+static size_t stringObjectLen(robj *o) {
+    redisAssert(o->type == REDIS_STRING);
+    if (o->encoding == REDIS_ENCODING_RAW) {
+        return sdslen(o->ptr);
+    } else {
+        char buf[32];
+
+        return ll2string(buf,32,(long)o->ptr);
+    }
+}
+
+static int getDoubleFromObject(robj *o, double *target) {
+    double value;
+    char *eptr;
+
+    if (o == NULL) {
+        value = 0;
+    } else {
+        redisAssert(o->type == REDIS_STRING);
+        if (o->encoding == REDIS_ENCODING_RAW) {
+            value = strtod(o->ptr, &eptr);
+            if (eptr[0] != '\0' || isnan(value)) return REDIS_ERR;
+        } else if (o->encoding == REDIS_ENCODING_INT) {
+            value = (long)o->ptr;
+        } else {
+            redisPanic("Unknown string encoding");
+        }
+    }
+
+    *target = value;
+    return REDIS_OK;
+}
+
+static int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg) {
+    double value;
+    if (getDoubleFromObject(o, &value) != REDIS_OK) {
+        if (msg != NULL) {
+            addReplySds(c, sdscatprintf(sdsempty(), "-ERR %s\r\n", msg));
+        } else {
+            addReplySds(c, sdsnew("-ERR value is not a double\r\n"));
+        }
+        return REDIS_ERR;
+    }
+
+    *target = value;
+    return REDIS_OK;
+}
+
+static int getLongLongFromObject(robj *o, long long *target) {
+    long long value;
+    char *eptr;
+
+    if (o == NULL) {
+        value = 0;
+    } else {
+        redisAssert(o->type == REDIS_STRING);
+        if (o->encoding == REDIS_ENCODING_RAW) {
+            value = strtoll(o->ptr, &eptr, 10);
+            if (eptr[0] != '\0') return REDIS_ERR;
+        } else if (o->encoding == REDIS_ENCODING_INT) {
+            value = (long)o->ptr;
+        } else {
+            redisPanic("Unknown string encoding");
+        }
+    }
+
+    *target = value;
+    return REDIS_OK;
+}
+
+static int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg) {
+    long long value;
+    if (getLongLongFromObject(o, &value) != REDIS_OK) {
+        if (msg != NULL) {
+            addReplySds(c, sdscatprintf(sdsempty(), "-ERR %s\r\n", msg));
+        } else {
+            addReplySds(c, sdsnew("-ERR value is not an integer\r\n"));
+        }
+        return REDIS_ERR;
+    }
+
+    *target = value;
+    return REDIS_OK;
+}
+
+static int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg) {
+    long long value;
+
+    if (getLongLongFromObjectOrReply(c, o, &value, msg) != REDIS_OK) return REDIS_ERR;
+    if (value < LONG_MIN || value > LONG_MAX) {
+        if (msg != NULL) {
+            addReplySds(c, sdscatprintf(sdsempty(), "-ERR %s\r\n", msg));
+        } else {
+            addReplySds(c, sdsnew("-ERR value is out of range\r\n"));
+        }
+        return REDIS_ERR;
+    }
+
+    *target = value;
+    return REDIS_OK;
+}
+
+/*============================ RDB saving/loading =========================== */
+/*================================== Shutdown =============================== */
+static int prepareForShutdown() {
+    redisLog(REDIS_WARNING,"User requested shutdown, saving DB...");
+    /* Kill the saving child if there is a background saving in progress.
+       We want to avoid race conditions, for instance our saving child may
+       overwrite the synchronous saving did by SHUTDOWN. */
+    
+    redisLog(REDIS_WARNING,"Not saving DB.");
+    redisLog(REDIS_WARNING,"Server exit now, bye bye...");
+    return REDIS_OK;
+}
+
+/*================================== Commands =============================== */
+
+static void authCommand(redisClient *c) {
+    if (!server.requirepass || !strcmp(c->argv[1]->ptr, server.requirepass)) {
+      c->authenticated = 1;
+      addReply(c,shared.ok);
+    } else {
+      c->authenticated = 0;
+      addReplySds(c,sdscatprintf(sdsempty(),"-ERR invalid password\r\n"));
+    }
+}
+
+static void pingCommand(redisClient *c) {
+    addReply(c,shared.pong);
+}
+
+static void echoCommand(redisClient *c) {
+    addReplyBulk(c,c->argv[1]);
+}
+
+/*=================================== Strings =============================== */
+
+static void setGenericCommand(redisClient *c, int nx, robj *key, robj *val, robj *expire) {
+    int retval;
+    long seconds = 0; /* initialized to avoid an harmness warning */
+
+    if (expire) {
+        if (getLongFromObjectOrReply(c, expire, &seconds, NULL) != REDIS_OK)
+            return;
+        if (seconds <= 0) {
+            addReplySds(c,sdsnew("-ERR invalid expire time in SETEX\r\n"));
+            return;
+        }
+    }
+
+    if (nx) deleteIfVolatile(c->db,key);
+    retval = dictAdd(c->db->dict,key,val);
+    if (retval == DICT_ERR) {
+        if (!nx) {
+            /* If the key is about a swapped value, we want a new key object
+             * to overwrite the old. So we delete the old key in the database.
+             * This will also make sure that swap pages about the old object
+             * will be marked as free. */
+            dictReplace(c->db->dict,key,val);
+            incrRefCount(val);
+        } else {
+            addReply(c,shared.czero);
+            return;
+        }
+    } else {
+        incrRefCount(key);
+        incrRefCount(val);
+    }
+    server.dirty++;
+    removeExpire(c->db,key);
+    if (expire) setExpire(c->db,key,time(NULL)+seconds);
+    addReply(c, nx ? shared.cone : shared.ok);
+}
+
+static void setCommand(redisClient *c) {
+    setGenericCommand(c,0,c->argv[1],c->argv[2],NULL);
+}
+
+static void setnxCommand(redisClient *c) {
+    setGenericCommand(c,1,c->argv[1],c->argv[2],NULL);
+}
+
+static void setexCommand(redisClient *c) {
+    setGenericCommand(c,0,c->argv[1],c->argv[3],c->argv[2]);
+}
+
+static int getGenericCommand(redisClient *c) {
+    robj *o;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL)
+        return REDIS_OK;
+
+    if (o->type != REDIS_STRING) {
+        addReply(c,shared.wrongtypeerr);
+        return REDIS_ERR;
+    } else {
+        addReplyBulk(c,o);
+        return REDIS_OK;
+    }
+}
+
+static void getCommand(redisClient *c) {
+    double num = log(1.0);
+    double num1 = sin(1.0);
+    getGenericCommand(c);
+}
+
+static void getsetCommand(redisClient *c) {
+    if (getGenericCommand(c) == REDIS_ERR) return;
+    if (dictAdd(c->db->dict,c->argv[1],c->argv[2]) == DICT_ERR) {
+        dictReplace(c->db->dict,c->argv[1],c->argv[2]);
+    } else {
+        incrRefCount(c->argv[1]);
+    }
+    incrRefCount(c->argv[2]);
+    server.dirty++;
+    removeExpire(c->db,c->argv[1]);
+}
+
+static void mgetCommand(redisClient *c) {
+    int j;
+
+    addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",c->argc-1));
+    for (j = 1; j < c->argc; j++) {
+        robj *o = lookupKeyRead(c->db,c->argv[j]);
+        if (o == NULL) {
+            addReply(c,shared.nullbulk);
+        } else {
+            if (o->type != REDIS_STRING) {
+                addReply(c,shared.nullbulk);
+            } else {
+                addReplyBulk(c,o);
+            }
+        }
+    }
+}
+
+static void msetGenericCommand(redisClient *c, int nx) {
+    int j, busykeys = 0;
+
+    if ((c->argc % 2) == 0) {
+        addReplySds(c,sdsnew("-ERR wrong number of arguments for MSET\r\n"));
+        return;
+    }
+    /* Handle the NX flag. The MSETNX semantic is to return zero and don't
+     * set nothing at all if at least one already key exists. */
+    if (nx) {
+        for (j = 1; j < c->argc; j += 2) {
+            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
+                busykeys++;
+            }
+        }
+    }
+    if (busykeys) {
+        addReply(c, shared.czero);
+        return;
+    }
+
+    for (j = 1; j < c->argc; j += 2) {
+        int retval;
+
+        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
+        retval = dictAdd(c->db->dict,c->argv[j],c->argv[j+1]);
+        if (retval == DICT_ERR) {
+            dictReplace(c->db->dict,c->argv[j],c->argv[j+1]);
+            incrRefCount(c->argv[j+1]);
+        } else {
+            incrRefCount(c->argv[j]);
+            incrRefCount(c->argv[j+1]);
+        }
+        removeExpire(c->db,c->argv[j]);
+    }
+    server.dirty += (c->argc-1)/2;
+    addReply(c, nx ? shared.cone : shared.ok);
+}
+
+static void msetCommand(redisClient *c) {
+    msetGenericCommand(c,0);
+}
+
+static void msetnxCommand(redisClient *c) {
+    msetGenericCommand(c,1);
+}
+
+static void incrDecrCommand(redisClient *c, long long incr) {
+    long long value;
+    int retval;
+    robj *o;
+
+    o = lookupKeyWrite(c->db,c->argv[1]);
+    if (o != NULL && checkType(c,o,REDIS_STRING)) return;
+    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != REDIS_OK) return;
+
+    value += incr;
+    o = createStringObjectFromLongLong(value);
+    retval = dictAdd(c->db->dict,c->argv[1],o);
+    if (retval == DICT_ERR) {
+        dictReplace(c->db->dict,c->argv[1],o);
+        removeExpire(c->db,c->argv[1]);
+    } else {
+        incrRefCount(c->argv[1]);
+    }
+    server.dirty++;
+    addReply(c,shared.colon);
+    addReply(c,o);
+    addReply(c,shared.crlf);
+}
+
+static void incrCommand(redisClient *c) {
+    incrDecrCommand(c,1);
+}
+
+static void decrCommand(redisClient *c) {
+    incrDecrCommand(c,-1);
+}
+
+static void incrbyCommand(redisClient *c) {
+    long long incr;
+
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != REDIS_OK) return;
+    incrDecrCommand(c,incr);
+}
+
+static void decrbyCommand(redisClient *c) {
+    long long incr;
+
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != REDIS_OK) return;
+    incrDecrCommand(c,-incr);
+}
+
+static void substrCommand(redisClient *c) {
+    robj *o;
+    long start = atoi(c->argv[2]->ptr);
+    long end = atoi(c->argv[3]->ptr);
+    size_t rangelen, strlen;
+    sds range;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,o,REDIS_STRING)) return;
+
+    o = getDecodedObject(o);
+    strlen = sdslen(o->ptr);
+
+    /* convert negative indexes */
+    if (start < 0) start = strlen+start;
+    if (end < 0) end = strlen+end;
+    if (start < 0) start = 0;
+    if (end < 0) end = 0;
+
+    /* indexes sanity checks */
+    if (start > end || (size_t)start >= strlen) {
+        /* Out of range start or start > end result in null reply */
+        addReply(c,shared.nullbulk);
+        decrRefCount(o);
+        return;
+    }
+    if ((size_t)end >= strlen) end = strlen-1;
+    rangelen = (end-start)+1;
+
+    /* Return the result */
+    addReplySds(c,sdscatprintf(sdsempty(),"$%zu\r\n",rangelen));
+    range = sdsnewlen((char*)o->ptr+start,rangelen);
+    addReplySds(c,range);
+    addReply(c,shared.crlf);
+    decrRefCount(o);
+}
+
+/* ========================= Type agnostic commands ========================= */
+
+static void delCommand(redisClient *c) {
+    int deleted = 0, j;
+
+    for (j = 1; j < c->argc; j++) {
+        if (deleteKey(c->db,c->argv[j])) {
+            server.dirty++;
+            deleted++;
+        }
+    }
+    addReplyLongLong(c,deleted);
+}
+
+static void existsCommand(redisClient *c) {
+    expireIfNeeded(c->db,c->argv[1]);
+    if (dictFind(c->db->dict,c->argv[1])) {
+        addReply(c, shared.cone);
+    } else {
+        addReply(c, shared.czero);
+    }
+}
+
+static void selectCommand(redisClient *c) {
+    int id = atoi(c->argv[1]->ptr);
+
+    if (selectDb(c,id) == REDIS_ERR) {
+        addReplySds(c,sdsnew("-ERR invalid DB index\r\n"));
+    } else {
+        addReply(c,shared.ok);
+    }
+}
+
+static void randomkeyCommand(redisClient *c) {
+    dictEntry *de;
+    robj *key;
+
+    while(1) {
+        de = dictGetRandomKey(c->db->dict);
+        if (!de || expireIfNeeded(c->db,dictGetEntryKey(de)) == 0) break;
+    }
+
+    if (de == NULL) {
+        addReply(c,shared.nullbulk);
+        return;
+    }
+
+    key = dictGetEntryKey(de);
+    addReplyBulk(c,key);
+}
+
+static void keysCommand(redisClient *c) {
+    dictIterator *di;
+    dictEntry *de;
+    sds pattern = c->argv[1]->ptr;
+    int plen = sdslen(pattern);
+    unsigned long numkeys = 0;
+    robj *lenobj = createObject(REDIS_STRING,NULL);
+
+    di = dictGetIterator(c->db->dict);
+    addReply(c,lenobj);
+    decrRefCount(lenobj);
+    while((de = dictNext(di)) != NULL) {
+        robj *keyobj = dictGetEntryKey(de);
+
+        sds key = keyobj->ptr;
+        if ((pattern[0] == '*' && pattern[1] == '\0') ||
+            stringmatchlen(pattern,plen,key,sdslen(key),0)) {
+            if (expireIfNeeded(c->db,keyobj) == 0) {
+                addReplyBulk(c,keyobj);
+                numkeys++;
+            }
+        }
+    }
+    dictReleaseIterator(di);
+    lenobj->ptr = sdscatprintf(sdsempty(),"*%lu\r\n",numkeys);
+}
+
+static void dbsizeCommand(redisClient *c) {
+    addReplySds(c,
+        sdscatprintf(sdsempty(),":%lu\r\n",dictSize(c->db->dict)));
+}
+
+static void lastsaveCommand(redisClient *c) {
+    addReplySds(c,
+        sdscatprintf(sdsempty(),":%lu\r\n",server.lastsave));
+}
+
+static void typeCommand(redisClient *c) {
+    robj *o;
+    char *type;
+
+    o = lookupKeyRead(c->db,c->argv[1]);
+    if (o == NULL) {
+        type = "+none";
+    } else {
+        switch(o->type) {
+        case REDIS_STRING: type = "+string"; break;
+        case REDIS_LIST: type = "+list"; break;
+        case REDIS_SET: type = "+set"; break;
+        case REDIS_ZSET: type = "+zset"; break;
+        case REDIS_HASH: type = "+hash"; break;
+        default: type = "+unknown"; break;
+        }
+    }
+    addReplySds(c,sdsnew(type));
+    addReply(c,shared.crlf);
+}
+
+
+static void shutdownCommand(redisClient *c) {
+    if (prepareForShutdown() == REDIS_OK)
+        exit(0);
+    addReplySds(c, sdsnew("-ERR Errors trying to SHUTDOWN. Check logs.\r\n"));
+}
+
+static void renameGenericCommand(redisClient *c, int nx) {
+    robj *o;
+
+    /* To use the same key as src and dst is probably an error */
+    if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) {
+        addReply(c,shared.sameobjecterr);
+        return;
+    }
+
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
+        return;
+
+    incrRefCount(o);
+    deleteIfVolatile(c->db,c->argv[2]);
+    if (dictAdd(c->db->dict,c->argv[2],o) == DICT_ERR) {
+        if (nx) {
+            decrRefCount(o);
+            addReply(c,shared.czero);
+            return;
+        }
+        dictReplace(c->db->dict,c->argv[2],o);
+    } else {
+        incrRefCount(c->argv[2]);
+    }
+    deleteKey(c->db,c->argv[1]);
+    server.dirty++;
+    addReply(c,nx ? shared.cone : shared.ok);
+}
+
+static void renameCommand(redisClient *c) {
+    renameGenericCommand(c,0);
+}
+
+static void renamenxCommand(redisClient *c) {
+    renameGenericCommand(c,1);
+}
+
+static void moveCommand(redisClient *c) {
+    robj *o;
+    redisDb *src, *dst;
+    int srcid;
+
+    /* Obtain source and target DB pointers */
+    src = c->db;
+    srcid = c->db->id;
+    if (selectDb(c,atoi(c->argv[2]->ptr)) == REDIS_ERR) {
+        addReply(c,shared.outofrangeerr);
+        return;
+    }
+    dst = c->db;
+    selectDb(c,srcid); /* Back to the source DB */
+
+    /* If the user is moving using as target the same
+     * DB as the source DB it is probably an error. */
+    if (src == dst) {
+        addReply(c,shared.sameobjecterr);
+        return;
+    }
+
+    /* Check if the element exists and get a reference */
+    o = lookupKeyWrite(c->db,c->argv[1]);
+    if (!o) {
+        addReply(c,shared.czero);
+        return;
+    }
+
+    /* Try to add the element to the target DB */
+    deleteIfVolatile(dst,c->argv[1]);
+    if (dictAdd(dst->dict,c->argv[1],o) == DICT_ERR) {
+        addReply(c,shared.czero);
+        return;
+    }
+    incrRefCount(c->argv[1]);
+    incrRefCount(o);
+
+    /* OK! key moved, free the entry in the source DB */
+    deleteKey(src,c->argv[1]);
+    server.dirty++;
+    addReply(c,shared.cone);
+}
+
+/* =================================== Lists ================================ */
+static void pushGenericCommand(redisClient *c, int where) {
+    robj *lobj;
+    list *list;
+
+    lobj = lookupKeyWrite(c->db,c->argv[1]);
+    if (lobj == NULL) {
+        if (handleClientsWaitingListPush(c,c->argv[1],c->argv[2])) {
+            addReply(c,shared.cone);
+            return;
+        }
+        lobj = createListObject();
+        list = lobj->ptr;
+        if (where == REDIS_HEAD) {
+            listAddNodeHead(list,c->argv[2]);
+        } else {
+            listAddNodeTail(list,c->argv[2]);
+        }
+        dictAdd(c->db->dict,c->argv[1],lobj);
+        incrRefCount(c->argv[1]);
+        incrRefCount(c->argv[2]);
+    } else {
+        if (lobj->type != REDIS_LIST) {
+            addReply(c,shared.wrongtypeerr);
+            return;
+        }
+        if (handleClientsWaitingListPush(c,c->argv[1],c->argv[2])) {
+            addReply(c,shared.cone);
+            return;
+        }
+        list = lobj->ptr;
+        if (where == REDIS_HEAD) {
+            listAddNodeHead(list,c->argv[2]);
+        } else {
+            listAddNodeTail(list,c->argv[2]);
+        }
+        incrRefCount(c->argv[2]);
+    }
+    server.dirty++;
+    addReplyLongLong(c,listLength(list));
+}
+
+static void lpushCommand(redisClient *c) {
+    pushGenericCommand(c,REDIS_HEAD);
+}
+
+static void rpushCommand(redisClient *c) {
+    pushGenericCommand(c,REDIS_TAIL);
+}
+
+static void llenCommand(redisClient *c) {
+    robj *o;
+    list *l;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,REDIS_LIST)) return;
+
+    l = o->ptr;
+    addReplyUlong(c,listLength(l));
+}
+
+static void lindexCommand(redisClient *c) {
+    robj *o;
+    int index = atoi(c->argv[2]->ptr);
+    list *list;
+    listNode *ln;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,o,REDIS_LIST)) return;
+    list = o->ptr;
+
+    ln = listIndex(list, index);
+    if (ln == NULL) {
+        addReply(c,shared.nullbulk);
+    } else {
+        robj *ele = listNodeValue(ln);
+        addReplyBulk(c,ele);
+    }
+}
+
+static void lsetCommand(redisClient *c) {
+    robj *o;
+    int index = atoi(c->argv[2]->ptr);
+    list *list;
+    listNode *ln;
+
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL ||
+        checkType(c,o,REDIS_LIST)) return;
+    list = o->ptr;
+
+    ln = listIndex(list, index);
+    if (ln == NULL) {
+        addReply(c,shared.outofrangeerr);
+    } else {
+        robj *ele = listNodeValue(ln);
+
+        decrRefCount(ele);
+        listNodeValue(ln) = c->argv[3];
+        incrRefCount(c->argv[3]);
+        addReply(c,shared.ok);
+        server.dirty++;
+    }
+}
+
+static void popGenericCommand(redisClient *c, int where) {
+    robj *o;
+    list *list;
+    listNode *ln;
+
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,o,REDIS_LIST)) return;
+    list = o->ptr;
+
+    if (where == REDIS_HEAD)
+        ln = listFirst(list);
+    else
+        ln = listLast(list);
+
+    if (ln == NULL) {
+        addReply(c,shared.nullbulk);
+    } else {
+        robj *ele = listNodeValue(ln);
+        addReplyBulk(c,ele);
+        listDelNode(list,ln);
+        if (listLength(list) == 0) deleteKey(c->db,c->argv[1]);
+        server.dirty++;
+    }
+}
+
+static void lpopCommand(redisClient *c) {
+    popGenericCommand(c,REDIS_HEAD);
+}
+
+static void rpopCommand(redisClient *c) {
+    popGenericCommand(c,REDIS_TAIL);
+}
+
+static void lrangeCommand(redisClient *c) {
+    robj *o;
+    int start = atoi(c->argv[2]->ptr);
+    int end = atoi(c->argv[3]->ptr);
+    int llen;
+    int rangelen, j;
+    list *list;
+    listNode *ln;
+    robj *ele;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
+         || checkType(c,o,REDIS_LIST)) return;
+    list = o->ptr;
+    llen = listLength(list);
+
+    /* convert negative indexes */
+    if (start < 0) start = llen+start;
+    if (end < 0) end = llen+end;
+    if (start < 0) start = 0;
+
+    /* Invariant: start >= 0, so this test will be true when end < 0.
+     * The range is empty when start > end or start >= length. */
+    if (start > end || start >= llen) {
+        /* Out of range start or start > end result in empty list */
+        addReply(c,shared.emptymultibulk);
+        return;
+    }
+    if (end >= llen) end = llen-1;
+    rangelen = (end-start)+1;
+
+    /* Return the result in form of a multi-bulk reply */
+    ln = listIndex(list, start);
+    addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",rangelen));
+    for (j = 0; j < rangelen; j++) {
+        ele = listNodeValue(ln);
+        addReplyBulk(c,ele);
+        ln = ln->next;
+    }
+}
+
+static void ltrimCommand(redisClient *c) {
+    robj *o;
+    int start = atoi(c->argv[2]->ptr);
+    int end = atoi(c->argv[3]->ptr);
+    int llen;
+    int j, ltrim, rtrim;
+    list *list;
+    listNode *ln;
+
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
+        checkType(c,o,REDIS_LIST)) return;
+    list = o->ptr;
+    llen = listLength(list);
+
+    /* convert negative indexes */
+    if (start < 0) start = llen+start;
+    if (end < 0) end = llen+end;
+    if (start < 0) start = 0;
+
+    /* Invariant: start >= 0, so this test will be true when end < 0.
+     * The range is empty when start > end or start >= length. */
+    if (start > end || start >= llen) {
+        /* Out of range start or start > end result in empty list */
+        ltrim = llen;
+        rtrim = 0;
+    } else {
+        if (end >= llen) end = llen-1;
+        ltrim = start;
+        rtrim = llen-end-1;
+    }
+
+    /* Remove list elements to perform the trim */
+    for (j = 0; j < ltrim; j++) {
+        ln = listFirst(list);
+        listDelNode(list,ln);
+    }
+    for (j = 0; j < rtrim; j++) {
+        ln = listLast(list);
+        listDelNode(list,ln);
+    }
+    if (listLength(list) == 0) deleteKey(c->db,c->argv[1]);
+    server.dirty++;
+    addReply(c,shared.ok);
+}
+
+static void lremCommand(redisClient *c) {
+    robj *o;
+    list *list;
+    listNode *ln, *next;
+    int toremove = atoi(c->argv[2]->ptr);
+    int removed = 0;
+    int fromtail = 0;
+
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,REDIS_LIST)) return;
+    list = o->ptr;
+
+    if (toremove < 0) {
+        toremove = -toremove;
+        fromtail = 1;
+    }
+    ln = fromtail ? list->tail : list->head;
+    while (ln) {
+        robj *ele = listNodeValue(ln);
+
+        next = fromtail ? ln->prev : ln->next;
+        if (equalStringObjects(ele,c->argv[3])) {
+            listDelNode(list,ln);
+            server.dirty++;
+            removed++;
+            if (toremove && removed == toremove) break;
+        }
+        ln = next;
+    }
+    if (listLength(list) == 0) deleteKey(c->db,c->argv[1]);
+    addReplySds(c,sdscatprintf(sdsempty(),":%d\r\n",removed));
+}
+
+/* This is the semantic of this command:
+ *  RPOPLPUSH srclist dstlist:
+ *   IF LLEN(srclist) > 0
+ *     element = RPOP srclist
+ *     LPUSH dstlist element
+ *     RETURN element
+ *   ELSE
+ *     RETURN nil
+ *   END
+ *  END
+ *
+ * The idea is to be able to get an element from a list in a reliable way
+ * since the element is not just returned but pushed against another list
+ * as well. This command was originally proposed by Ezra Zygmuntowicz.
+ */
+static void rpoplpushcommand(redisClient *c) {
+    robj *sobj;
+    list *srclist;
+    listNode *ln;
+
+    if ((sobj = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,sobj,REDIS_LIST)) return;
+    srclist = sobj->ptr;
+    ln = listLast(srclist);
+
+    if (ln == NULL) {
+        addReply(c,shared.nullbulk);
+    } else {
+        robj *dobj = lookupKeyWrite(c->db,c->argv[2]);
+        robj *ele = listNodeValue(ln);
+        list *dstlist;
+
+        if (dobj && dobj->type != REDIS_LIST) {
+            addReply(c,shared.wrongtypeerr);
+            return;
+        }
+
+        /* Add the element to the target list (unless it's directly
+         * passed to some BLPOP-ing client */
+        if (!handleClientsWaitingListPush(c,c->argv[2],ele)) {
+            if (dobj == NULL) {
+                /* Create the list if the key does not exist */
+                dobj = createListObject();
+                dictAdd(c->db->dict,c->argv[2],dobj);
+                incrRefCount(c->argv[2]);
+            }
+            dstlist = dobj->ptr;
+            listAddNodeHead(dstlist,ele);
+            incrRefCount(ele);
+        }
+
+        /* Send the element to the client as reply as well */
+        addReplyBulk(c,ele);
+
+        /* Finally remove the element from the source list */
+        listDelNode(srclist,ln);
+        if (listLength(srclist) == 0) deleteKey(c->db,c->argv[1]);
+        server.dirty++;
+    }
+}
+
+/* ==================================== Sets ================================ */
+
+static void saddCommand(redisClient *c) {
+    robj *set;
+
+    set = lookupKeyWrite(c->db,c->argv[1]);
+    if (set == NULL) {
+        set = createSetObject();
+        dictAdd(c->db->dict,c->argv[1],set);
+        incrRefCount(c->argv[1]);
+    } else {
+        if (set->type != REDIS_SET) {
+            addReply(c,shared.wrongtypeerr);
+            return;
+        }
+    }
+    if (dictAdd(set->ptr,c->argv[2],NULL) == DICT_OK) {
+        incrRefCount(c->argv[2]);
+        server.dirty++;
+        addReply(c,shared.cone);
+    } else {
+        addReply(c,shared.czero);
+    }
+}
+
+static void sremCommand(redisClient *c) {
+    robj *set;
+
+    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,set,REDIS_SET)) return;
+
+    if (dictDelete(set->ptr,c->argv[2]) == DICT_OK) {
+        server.dirty++;
+        if (htNeedsResize(set->ptr)) dictResize(set->ptr);
+        if (dictSize((dict*)set->ptr) == 0) deleteKey(c->db,c->argv[1]);
+        addReply(c,shared.cone);
+    } else {
+        addReply(c,shared.czero);
+    }
+}
+
+static void smoveCommand(redisClient *c) {
+    robj *srcset, *dstset;
+
+    srcset = lookupKeyWrite(c->db,c->argv[1]);
+    dstset = lookupKeyWrite(c->db,c->argv[2]);
+
+    /* If the source key does not exist return 0, if it's of the wrong type
+     * raise an error */
+    if (srcset == NULL || srcset->type != REDIS_SET) {
+        addReply(c, srcset ? shared.wrongtypeerr : shared.czero);
+        return;
+    }
+    /* Error if the destination key is not a set as well */
+    if (dstset && dstset->type != REDIS_SET) {
+        addReply(c,shared.wrongtypeerr);
+        return;
+    }
+    /* Remove the element from the source set */
+    if (dictDelete(srcset->ptr,c->argv[3]) == DICT_ERR) {
+        /* Key not found in the src set! return zero */
+        addReply(c,shared.czero);
+        return;
+    }
+    if (dictSize((dict*)srcset->ptr) == 0 && srcset != dstset)
+        deleteKey(c->db,c->argv[1]);
+    server.dirty++;
+    /* Add the element to the destination set */
+    if (!dstset) {
+        dstset = createSetObject();
+        dictAdd(c->db->dict,c->argv[2],dstset);
+        incrRefCount(c->argv[2]);
+    }
+    if (dictAdd(dstset->ptr,c->argv[3],NULL) == DICT_OK)
+        incrRefCount(c->argv[3]);
+    addReply(c,shared.cone);
+}
+
+static void sismemberCommand(redisClient *c) {
+    robj *set;
+
+    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,set,REDIS_SET)) return;
+
+    if (dictFind(set->ptr,c->argv[2]))
+        addReply(c,shared.cone);
+    else
+        addReply(c,shared.czero);
+}
+
+static void scardCommand(redisClient *c) {
+    robj *o;
+    dict *s;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,REDIS_SET)) return;
+
+    s = o->ptr;
+    addReplyUlong(c,dictSize(s));
+}
+
+static void spopCommand(redisClient *c) {
+    robj *set;
+    dictEntry *de;
+
+    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,set,REDIS_SET)) return;
+
+    de = dictGetRandomKey(set->ptr);
+    if (de == NULL) {
+        addReply(c,shared.nullbulk);
+    } else {
+        robj *ele = dictGetEntryKey(de);
+
+        addReplyBulk(c,ele);
+        dictDelete(set->ptr,ele);
+        if (htNeedsResize(set->ptr)) dictResize(set->ptr);
+        if (dictSize((dict*)set->ptr) == 0) deleteKey(c->db,c->argv[1]);
+        server.dirty++;
+    }
+}
+
+static void srandmemberCommand(redisClient *c) {
+    robj *set;
+    dictEntry *de;
+
+    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,set,REDIS_SET)) return;
+
+    de = dictGetRandomKey(set->ptr);
+    if (de == NULL) {
+        addReply(c,shared.nullbulk);
+    } else {
+        robj *ele = dictGetEntryKey(de);
+
+        addReplyBulk(c,ele);
+    }
+}
+
+static int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
+    dict **d1 = (void*) s1, **d2 = (void*) s2;
+
+    return dictSize(*d1)-dictSize(*d2);
+}
+
+static void sinterGenericCommand(redisClient *c, robj **setskeys, unsigned long setsnum, robj *dstkey) {
+    dict **dv = zmalloc(sizeof(dict*)*setsnum);
+    dictIterator *di;
+    dictEntry *de;
+    robj *lenobj = NULL, *dstset = NULL;
+    unsigned long j, cardinality = 0;
+
+    for (j = 0; j < setsnum; j++) {
+        robj *setobj;
+
+        setobj = dstkey ?
+                    lookupKeyWrite(c->db,setskeys[j]) :
+                    lookupKeyRead(c->db,setskeys[j]);
+        if (!setobj) {
+            zfree(dv);
+            if (dstkey) {
+                if (deleteKey(c->db,dstkey))
+                    server.dirty++;
+                addReply(c,shared.czero);
+            } else {
+                addReply(c,shared.emptymultibulk);
+            }
+            return;
+        }
+        if (setobj->type != REDIS_SET) {
+            zfree(dv);
+            addReply(c,shared.wrongtypeerr);
+            return;
+        }
+        dv[j] = setobj->ptr;
+    }
+    /* Sort sets from the smallest to largest, this will improve our
+     * algorithm's performace */
+    qsort(dv,setsnum,sizeof(dict*),qsortCompareSetsByCardinality);
+
+    /* The first thing we should output is the total number of elements...
+     * since this is a multi-bulk write, but at this stage we don't know
+     * the intersection set size, so we use a trick, append an empty object
+     * to the output list and save the pointer to later modify it with the
+     * right length */
+    if (!dstkey) {
+        lenobj = createObject(REDIS_STRING,NULL);
+        addReply(c,lenobj);
+        decrRefCount(lenobj);
+    } else {
+        /* If we have a target key where to store the resulting set
+         * create this key with an empty set inside */
+        dstset = createSetObject();
+    }
+
+    /* Iterate all the elements of the first (smallest) set, and test
+     * the element against all the other sets, if at least one set does
+     * not include the element it is discarded */
+    di = dictGetIterator(dv[0]);
+
+    while((de = dictNext(di)) != NULL) {
+        robj *ele;
+
+        for (j = 1; j < setsnum; j++)
+            if (dictFind(dv[j],dictGetEntryKey(de)) == NULL) break;
+        if (j != setsnum)
+            continue; /* at least one set does not contain the member */
+        ele = dictGetEntryKey(de);
+        if (!dstkey) {
+            addReplyBulk(c,ele);
+            cardinality++;
+        } else {
+            dictAdd(dstset->ptr,ele,NULL);
+            incrRefCount(ele);
+        }
+    }
+    dictReleaseIterator(di);
+
+    if (dstkey) {
+        /* Store the resulting set into the target, if the intersection
+         * is not an empty set. */
+        deleteKey(c->db,dstkey);
+        if (dictSize((dict*)dstset->ptr) > 0) {
+            dictAdd(c->db->dict,dstkey,dstset);
+            incrRefCount(dstkey);
+            addReplyLongLong(c,dictSize((dict*)dstset->ptr));
+        } else {
+            decrRefCount(dstset);
+            addReply(c,shared.czero);
+        }
+        server.dirty++;
+    } else {
+        lenobj->ptr = sdscatprintf(sdsempty(),"*%lu\r\n",cardinality);
+    }
+    zfree(dv);
+}
+
+static void sinterCommand(redisClient *c) {
+    sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
+}
+
+static void sinterstoreCommand(redisClient *c) {
+    sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
+}
+
+#define REDIS_OP_UNION 0
+#define REDIS_OP_DIFF 1
+#define REDIS_OP_INTER 2
+
+static void sunionDiffGenericCommand(redisClient *c, robj **setskeys, int setsnum, robj *dstkey, int op) {
+    dict **dv = zmalloc(sizeof(dict*)*setsnum);
+    dictIterator *di;
+    dictEntry *de;
+    robj *dstset = NULL;
+    int j, cardinality = 0;
+
+    for (j = 0; j < setsnum; j++) {
+        robj *setobj;
+
+        setobj = dstkey ?
+                    lookupKeyWrite(c->db,setskeys[j]) :
+                    lookupKeyRead(c->db,setskeys[j]);
+        if (!setobj) {
+            dv[j] = NULL;
+            continue;
+        }
+        if (setobj->type != REDIS_SET) {
+            zfree(dv);
+            addReply(c,shared.wrongtypeerr);
+            return;
+        }
+        dv[j] = setobj->ptr;
+    }
+
+    /* We need a temp set object to store our union. If the dstkey
+     * is not NULL (that is, we are inside an SUNIONSTORE operation) then
+     * this set object will be the resulting object to set into the target key*/
+    dstset = createSetObject();
+
+    /* Iterate all the elements of all the sets, add every element a single
+     * time to the result set */
+    for (j = 0; j < setsnum; j++) {
+        if (op == REDIS_OP_DIFF && j == 0 && !dv[j]) break; /* result set is empty */
+        if (!dv[j]) continue; /* non existing keys are like empty sets */
+
+        di = dictGetIterator(dv[j]);
+
+        while((de = dictNext(di)) != NULL) {
+            robj *ele;
+
+            /* dictAdd will not add the same element multiple times */
+            ele = dictGetEntryKey(de);
+            if (op == REDIS_OP_UNION || j == 0) {
+                if (dictAdd(dstset->ptr,ele,NULL) == DICT_OK) {
+                    incrRefCount(ele);
+                    cardinality++;
+                }
+            } else if (op == REDIS_OP_DIFF) {
+                if (dictDelete(dstset->ptr,ele) == DICT_OK) {
+                    cardinality--;
+                }
+            }
+        }
+        dictReleaseIterator(di);
+
+        /* result set is empty? Exit asap. */
+        if (op == REDIS_OP_DIFF && cardinality == 0) break;
+    }
+
+    /* Output the content of the resulting set, if not in STORE mode */
+    if (!dstkey) {
+        addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",cardinality));
+        di = dictGetIterator(dstset->ptr);
+        while((de = dictNext(di)) != NULL) {
+            robj *ele;
+
+            ele = dictGetEntryKey(de);
+            addReplyBulk(c,ele);
+        }
+        dictReleaseIterator(di);
+        decrRefCount(dstset);
+    } else {
+        /* If we have a target key where to store the resulting set
+         * create this key with the result set inside */
+        deleteKey(c->db,dstkey);
+        if (dictSize((dict*)dstset->ptr) > 0) {
+            dictAdd(c->db->dict,dstkey,dstset);
+            incrRefCount(dstkey);
+            addReplyLongLong(c,dictSize((dict*)dstset->ptr));
+        } else {
+            decrRefCount(dstset);
+            addReply(c,shared.czero);
+        }
+        server.dirty++;
+    }
+    zfree(dv);
+}
+
+static void sunionCommand(redisClient *c) {
+    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,REDIS_OP_UNION);
+}
+
+static void sunionstoreCommand(redisClient *c) {
+    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],REDIS_OP_UNION);
+}
+
+static void sdiffCommand(redisClient *c) {
+    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,REDIS_OP_DIFF);
+}
+
+static void sdiffstoreCommand(redisClient *c) {
+    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],REDIS_OP_DIFF);
+}
+
+/* ==================================== ZSets =============================== */
+
+/* ZSETs are ordered sets using two data structures to hold the same elements
+ * in order to get O(log(N)) INSERT and REMOVE operations into a sorted
+ * data structure.
+ *
+ * The elements are added to an hash table mapping Redis objects to scores.
+ * At the same time the elements are added to a skip list mapping scores
+ * to Redis objects (so objects are sorted by scores in this "view"). */
+
+/* This skiplist implementation is almost a C translation of the original
+ * algorithm described by William Pugh in "Skip Lists: A Probabilistic
+ * Alternative to Balanced Trees", modified in three ways:
+ * a) this implementation allows for repeated values.
+ * b) the comparison is not just by key (our 'score') but by satellite data.
+ * c) there is a back pointer, so it's a doubly linked list with the back
+ * pointers being only at "level 1". This allows to traverse the list
+ * from tail to head, useful for ZREVRANGE. */
+
+static zskiplistNode *zslCreateNode(int level, double score, robj *obj) {
+    zskiplistNode *zn = zmalloc(sizeof(*zn));
+
+    zn->forward = zmalloc(sizeof(zskiplistNode*) * level);
+    if (level > 1)
+        zn->span = zmalloc(sizeof(unsigned int) * (level - 1));
+    else
+        zn->span = NULL;
+    zn->score = score;
+    zn->obj = obj;
+    return zn;
+}
+
+static zskiplist *zslCreate(void) {
+    int j;
+    zskiplist *zsl;
+
+    zsl = zmalloc(sizeof(*zsl));
+    zsl->level = 1;
+    zsl->length = 0;
+    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
+    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {
+        zsl->header->forward[j] = NULL;
+
+        /* span has space for ZSKIPLIST_MAXLEVEL-1 elements */
+        if (j < ZSKIPLIST_MAXLEVEL-1)
+            zsl->header->span[j] = 0;
+    }
+    zsl->header->backward = NULL;
+    zsl->tail = NULL;
+    return zsl;
+}
+
+static void zslFreeNode(zskiplistNode *node) {
+    decrRefCount(node->obj);
+    zfree(node->forward);
+    zfree(node->span);
+    zfree(node);
+}
+
+static void zslFree(zskiplist *zsl) {
+    zskiplistNode *node = zsl->header->forward[0], *next;
+
+    zfree(zsl->header->forward);
+    zfree(zsl->header->span);
+    zfree(zsl->header);
+    while(node) {
+        next = node->forward[0];
+        zslFreeNode(node);
+        node = next;
+    }
+    zfree(zsl);
+}
+
+static int zslRandomLevel(void) {
+    int level = 1;
+    while ((rand()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
+        level += 1;
+    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
+}
+
+static void zslInsert(zskiplist *zsl, double score, robj *obj) {
+    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
+    unsigned int rank[ZSKIPLIST_MAXLEVEL];
+    int i, level;
+
+    x = zsl->header;
+    for (i = zsl->level-1; i >= 0; i--) {
+        /* store rank that is crossed to reach the insert position */
+        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
+
+        while (x->forward[i] &&
+            (x->forward[i]->score < score ||
+                (x->forward[i]->score == score &&
+                compareStringObjects(x->forward[i]->obj,obj) < 0))) {
+            rank[i] += i > 0 ? x->span[i-1] : 1;
+            x = x->forward[i];
+        }
+        update[i] = x;
+    }
+    /* we assume the key is not already inside, since we allow duplicated
+     * scores, and the re-insertion of score and redis object should never
+     * happpen since the caller of zslInsert() should test in the hash table
+     * if the element is already inside or not. */
+    level = zslRandomLevel();
+    if (level > zsl->level) {
+        for (i = zsl->level; i < level; i++) {
+            rank[i] = 0;
+            update[i] = zsl->header;
+            update[i]->span[i-1] = zsl->length;
+        }
+        zsl->level = level;
+    }
+    x = zslCreateNode(level,score,obj);
+    for (i = 0; i < level; i++) {
+        x->forward[i] = update[i]->forward[i];
+        update[i]->forward[i] = x;
+
+        /* update span covered by update[i] as x is inserted here */
+        if (i > 0) {
+            x->span[i-1] = update[i]->span[i-1] - (rank[0] - rank[i]);
+            update[i]->span[i-1] = (rank[0] - rank[i]) + 1;
+        }
+    }
+
+    /* increment span for untouched levels */
+    for (i = level; i < zsl->level; i++) {
+        update[i]->span[i-1]++;
+    }
+
+    x->backward = (update[0] == zsl->header) ? NULL : update[0];
+    if (x->forward[0])
+        x->forward[0]->backward = x;
+    else
+        zsl->tail = x;
+    zsl->length++;
+}
+
+/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */
+void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
+    int i;
+    for (i = 0; i < zsl->level; i++) {
+        if (update[i]->forward[i] == x) {
+            if (i > 0) {
+                update[i]->span[i-1] += x->span[i-1] - 1;
+            }
+            update[i]->forward[i] = x->forward[i];
+        } else {
+            /* invariant: i > 0, because update[0]->forward[0]
+             * is always equal to x */
+            update[i]->span[i-1] -= 1;
+        }
+    }
+    if (x->forward[0]) {
+        x->forward[0]->backward = x->backward;
+    } else {
+        zsl->tail = x->backward;
+    }
+    while(zsl->level > 1 && zsl->header->forward[zsl->level-1] == NULL)
+        zsl->level--;
+    zsl->length--;
+}
+
+/* Delete an element with matching score/object from the skiplist. */
+static int zslDelete(zskiplist *zsl, double score, robj *obj) {
+    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
+    int i;
+
+    x = zsl->header;
+    for (i = zsl->level-1; i >= 0; i--) {
+        while (x->forward[i] &&
+            (x->forward[i]->score < score ||
+                (x->forward[i]->score == score &&
+                compareStringObjects(x->forward[i]->obj,obj) < 0)))
+            x = x->forward[i];
+        update[i] = x;
+    }
+    /* We may have multiple elements with the same score, what we need
+     * is to find the element with both the right score and object. */
+    x = x->forward[0];
+    if (x && score == x->score && equalStringObjects(x->obj,obj)) {
+        zslDeleteNode(zsl, x, update);
+        zslFreeNode(x);
+        return 1;
+    } else {
+        return 0; /* not found */
+    }
+    return 0; /* not found */
+}
+
+/* Delete all the elements with score between min and max from the skiplist.
+ * Min and mx are inclusive, so a score >= min || score <= max is deleted.
+ * Note that this function takes the reference to the hash table view of the
+ * sorted set, in order to remove the elements from the hash table too. */
+static unsigned long zslDeleteRangeByScore(zskiplist *zsl, double min, double max, dict *dict) {
+    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
+    unsigned long removed = 0;
+    int i;
+
+    x = zsl->header;
+    for (i = zsl->level-1; i >= 0; i--) {
+        while (x->forward[i] && x->forward[i]->score < min)
+            x = x->forward[i];
+        update[i] = x;
+    }
+    /* We may have multiple elements with the same score, what we need
+     * is to find the element with both the right score and object. */
+    x = x->forward[0];
+    while (x && x->score <= max) {
+        zskiplistNode *next = x->forward[0];
+        zslDeleteNode(zsl, x, update);
+        dictDelete(dict,x->obj);
+        zslFreeNode(x);
+        removed++;
+        x = next;
+    }
+    return removed; /* not found */
+}
+
+/* Delete all the elements with rank between start and end from the skiplist.
+ * Start and end are inclusive. Note that start and end need to be 1-based */
+static unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
+    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
+    unsigned long traversed = 0, removed = 0;
+    int i;
+
+    x = zsl->header;
+    for (i = zsl->level-1; i >= 0; i--) {
+        while (x->forward[i] && (traversed + (i > 0 ? x->span[i-1] : 1)) < start) {
+            traversed += i > 0 ? x->span[i-1] : 1;
+            x = x->forward[i];
+        }
+        update[i] = x;
+    }
+
+    traversed++;
+    x = x->forward[0];
+    while (x && traversed <= end) {
+        zskiplistNode *next = x->forward[0];
+        zslDeleteNode(zsl, x, update);
+        dictDelete(dict,x->obj);
+        zslFreeNode(x);
+        removed++;
+        traversed++;
+        x = next;
+    }
+    return removed;
+}
+
+/* Find the first node having a score equal or greater than the specified one.
+ * Returns NULL if there is no match. */
+static zskiplistNode *zslFirstWithScore(zskiplist *zsl, double score) {
+    zskiplistNode *x;
+    int i;
+
+    x = zsl->header;
+    for (i = zsl->level-1; i >= 0; i--) {
+        while (x->forward[i] && x->forward[i]->score < score)
+            x = x->forward[i];
+    }
+    /* We may have multiple elements with the same score, what we need
+     * is to find the element with both the right score and object. */
+    return x->forward[0];
+}
+
+/* Find the rank for an element by both score and key.
+ * Returns 0 when the element cannot be found, rank otherwise.
+ * Note that the rank is 1-based due to the span of zsl->header to the
+ * first element. */
+static unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) {
+    zskiplistNode *x;
+    unsigned long rank = 0;
+    int i;
+
+    x = zsl->header;
+    for (i = zsl->level-1; i >= 0; i--) {
+        while (x->forward[i] &&
+            (x->forward[i]->score < score ||
+                (x->forward[i]->score == score &&
+                compareStringObjects(x->forward[i]->obj,o) <= 0))) {
+            rank += i > 0 ? x->span[i-1] : 1;
+            x = x->forward[i];
+        }
+
+        /* x might be equal to zsl->header, so test if obj is non-NULL */
+        if (x->obj && equalStringObjects(x->obj,o)) {
+            return rank;
+        }
+    }
+    return 0;
+}
+
+/* Finds an element by its rank. The rank argument needs to be 1-based. */
+zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
+    zskiplistNode *x;
+    unsigned long traversed = 0;
+    int i;
+
+    x = zsl->header;
+    for (i = zsl->level-1; i >= 0; i--) {
+        while (x->forward[i] && (traversed + (i>0 ? x->span[i-1] : 1)) <= rank)
+        {
+            traversed += i > 0 ? x->span[i-1] : 1;
+            x = x->forward[i];
+        }
+        if (traversed == rank) {
+            return x;
+        }
+    }
+    return NULL;
+}
+
+/* The actual Z-commands implementations */
+
+/* This generic command implements both ZADD and ZINCRBY.
+ * scoreval is the score if the operation is a ZADD (doincrement == 0) or
+ * the increment if the operation is a ZINCRBY (doincrement == 1). */
+static void zaddGenericCommand(redisClient *c, robj *key, robj *ele, double scoreval, int doincrement) {
+    robj *zsetobj;
+    zset *zs;
+    double *score;
+
+    zsetobj = lookupKeyWrite(c->db,key);
+    if (zsetobj == NULL) {
+        zsetobj = createZsetObject();
+        dictAdd(c->db->dict,key,zsetobj);
+        incrRefCount(key);
+    } else {
+        if (zsetobj->type != REDIS_ZSET) {
+            addReply(c,shared.wrongtypeerr);
+            return;
+        }
+    }
+    zs = zsetobj->ptr;
+
+    /* Ok now since we implement both ZADD and ZINCRBY here the code
+     * needs to handle the two different conditions. It's all about setting
+     * '*score', that is, the new score to set, to the right value. */
+    score = zmalloc(sizeof(double));
+    if (doincrement) {
+        dictEntry *de;
+
+        /* Read the old score. If the element was not present starts from 0 */
+        de = dictFind(zs->dict,ele);
+        if (de) {
+            double *oldscore = dictGetEntryVal(de);
+            *score = *oldscore + scoreval;
+        } else {
+            *score = scoreval;
+        }
+        if (isnan(*score)) {
+            addReplySds(c,
+                sdsnew("-ERR resulting score is not a number (NaN)\r\n"));
+            zfree(score);
+            /* Note that we don't need to check if the zset may be empty and
+             * should be removed here, as we can only obtain Nan as score if
+             * there was already an element in the sorted set. */
+            return;
+        }
+    } else {
+        *score = scoreval;
+    }
+
+    /* What follows is a simple remove and re-insert operation that is common
+     * to both ZADD and ZINCRBY... */
+    if (dictAdd(zs->dict,ele,score) == DICT_OK) {
+        /* case 1: New element */
+        incrRefCount(ele); /* added to hash */
+        zslInsert(zs->zsl,*score,ele);
+        incrRefCount(ele); /* added to skiplist */
+        server.dirty++;
+        if (doincrement)
+            addReplyDouble(c,*score);
+        else
+            addReply(c,shared.cone);
+    } else {
+        dictEntry *de;
+        double *oldscore;
+
+        /* case 2: Score update operation */
+        de = dictFind(zs->dict,ele);
+        redisAssert(de != NULL);
+        oldscore = dictGetEntryVal(de);
+        if (*score != *oldscore) {
+            int deleted;
+
+            /* Remove and insert the element in the skip list with new score */
+            deleted = zslDelete(zs->zsl,*oldscore,ele);
+            redisAssert(deleted != 0);
+            zslInsert(zs->zsl,*score,ele);
+            incrRefCount(ele);
+            /* Update the score in the hash table */
+            dictReplace(zs->dict,ele,score);
+            server.dirty++;
+        } else {
+            zfree(score);
+        }
+        if (doincrement)
+            addReplyDouble(c,*score);
+        else
+            addReply(c,shared.czero);
+    }
+}
+
+static void zaddCommand(redisClient *c) {
+    double scoreval;
+    if (getDoubleFromObjectOrReply(c,c->argv[2],&scoreval,NULL) != REDIS_OK) return;
+    zaddGenericCommand(c,c->argv[1],c->argv[3],scoreval,0);
+}
+
+static void zincrbyCommand(redisClient *c) {
+    double scoreval;
+    if (getDoubleFromObjectOrReply(c,c->argv[2],&scoreval,NULL) != REDIS_OK) return;
+    zaddGenericCommand(c,c->argv[1],c->argv[3],scoreval,1);
+}
+
+static void zremCommand(redisClient *c) {
+    robj *zsetobj;
+    zset *zs;
+    dictEntry *de;
+    double *oldscore;
+    int deleted;
+
+    if ((zsetobj = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,zsetobj,REDIS_ZSET)) return;
+
+    zs = zsetobj->ptr;
+    de = dictFind(zs->dict,c->argv[2]);
+    if (de == NULL) {
+        addReply(c,shared.czero);
+        return;
+    }
+    /* Delete from the skiplist */
+    oldscore = dictGetEntryVal(de);
+    deleted = zslDelete(zs->zsl,*oldscore,c->argv[2]);
+    redisAssert(deleted != 0);
+
+    /* Delete from the hash table */
+    dictDelete(zs->dict,c->argv[2]);
+    if (htNeedsResize(zs->dict)) dictResize(zs->dict);
+    if (dictSize(zs->dict) == 0) deleteKey(c->db,c->argv[1]);
+    server.dirty++;
+    addReply(c,shared.cone);
+}
+
+static void zremrangebyscoreCommand(redisClient *c) {
+    double min;
+    double max;
+    long deleted;
+    robj *zsetobj;
+    zset *zs;
+
+    if ((getDoubleFromObjectOrReply(c, c->argv[2], &min, NULL) != REDIS_OK) ||
+        (getDoubleFromObjectOrReply(c, c->argv[3], &max, NULL) != REDIS_OK)) return;
+
+    if ((zsetobj = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,zsetobj,REDIS_ZSET)) return;
+
+    zs = zsetobj->ptr;
+    deleted = zslDeleteRangeByScore(zs->zsl,min,max,zs->dict);
+    if (htNeedsResize(zs->dict)) dictResize(zs->dict);
+    if (dictSize(zs->dict) == 0) deleteKey(c->db,c->argv[1]);
+    server.dirty += deleted;
+    addReplyLongLong(c,deleted);
+}
+
+static void zremrangebyrankCommand(redisClient *c) {
+    long start;
+    long end;
+    int llen;
+    long deleted;
+    robj *zsetobj;
+    zset *zs;
+
+    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != REDIS_OK) ||
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != REDIS_OK)) return;
+
+    if ((zsetobj = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,zsetobj,REDIS_ZSET)) return;
+    zs = zsetobj->ptr;
+    llen = zs->zsl->length;
+
+    /* convert negative indexes */
+    if (start < 0) start = llen+start;
+    if (end < 0) end = llen+end;
+    if (start < 0) start = 0;
+
+    /* Invariant: start >= 0, so this test will be true when end < 0.
+     * The range is empty when start > end or start >= length. */
+    if (start > end || start >= llen) {
+        addReply(c,shared.czero);
+        return;
+    }
+    if (end >= llen) end = llen-1;
+
+    /* increment start and end because zsl*Rank functions
+     * use 1-based rank */
+    deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);
+    if (htNeedsResize(zs->dict)) dictResize(zs->dict);
+    if (dictSize(zs->dict) == 0) deleteKey(c->db,c->argv[1]);
+    server.dirty += deleted;
+    addReplyLongLong(c, deleted);
+}
+
+typedef struct {
+    dict *dict;
+    double weight;
+} zsetopsrc;
+
+static int qsortCompareZsetopsrcByCardinality(const void *s1, const void *s2) {
+    zsetopsrc *d1 = (void*) s1, *d2 = (void*) s2;
+    unsigned long size1, size2;
+    size1 = d1->dict ? dictSize(d1->dict) : 0;
+    size2 = d2->dict ? dictSize(d2->dict) : 0;
+    return size1 - size2;
+}
+
+#define REDIS_AGGR_SUM 1
+#define REDIS_AGGR_MIN 2
+#define REDIS_AGGR_MAX 3
+
+inline static void zunionInterAggregate(double *target, double val, int aggregate) {
+    if (aggregate == REDIS_AGGR_SUM) {
+        *target = *target + val;
+        /* The result of adding two doubles is NaN when one variable
+         * is +inf and the other is -inf. When these numbers are added,
+         * we maintain the convention of the result being 0.0. */
+        if (isnan(*target)) *target = 0.0;
+    } else if (aggregate == REDIS_AGGR_MIN) {
+        *target = val < *target ? val : *target;
+    } else if (aggregate == REDIS_AGGR_MAX) {
+        *target = val > *target ? val : *target;
+    } else {
+        /* safety net */
+        redisPanic("Unknown ZUNION/INTER aggregate type");
+    }
+}
+
+static void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {
+    int i, j, zsetnum;
+    int aggregate = REDIS_AGGR_SUM;
+    zsetopsrc *src;
+    robj *dstobj;
+    zset *dstzset;
+    dictIterator *di;
+    dictEntry *de;
+
+    /* expect zsetnum input keys to be given */
+    zsetnum = atoi(c->argv[2]->ptr);
+    if (zsetnum < 1) {
+        addReplySds(c,sdsnew("-ERR at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE\r\n"));
+        return;
+    }
+
+    /* test if the expected number of keys would overflow */
+    if (3+zsetnum > c->argc) {
+        addReply(c,shared.syntaxerr);
+        return;
+    }
+
+    /* read keys to be used for input */
+    src = zmalloc(sizeof(zsetopsrc) * zsetnum);
+    for (i = 0, j = 3; i < zsetnum; i++, j++) {
+        robj *zsetobj = lookupKeyWrite(c->db,c->argv[j]);
+        if (!zsetobj) {
+            src[i].dict = NULL;
+        } else {
+            if (zsetobj->type != REDIS_ZSET) {
+                zfree(src);
+                addReply(c,shared.wrongtypeerr);
+                return;
+            }
+            src[i].dict = ((zset*)zsetobj->ptr)->dict;
+        }
+
+        /* default all weights to 1 */
+        src[i].weight = 1.0;
+    }
+
+    /* parse optional extra arguments */
+    if (j < c->argc) {
+        int remaining = c->argc - j;
+
+        while (remaining) {
+            if (remaining >= (zsetnum + 1) && !strcasecmp(c->argv[j]->ptr,"weights")) {
+                j++; remaining--;
+                for (i = 0; i < zsetnum; i++, j++, remaining--) {
+                    if (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,
+                            "weight value is not a double") != REDIS_OK)
+                    {
+                        zfree(src);
+                        return;
+                    }
+                }
+            } else if (remaining >= 2 && !strcasecmp(c->argv[j]->ptr,"aggregate")) {
+                j++; remaining--;
+                if (!strcasecmp(c->argv[j]->ptr,"sum")) {
+                    aggregate = REDIS_AGGR_SUM;
+                } else if (!strcasecmp(c->argv[j]->ptr,"min")) {
+                    aggregate = REDIS_AGGR_MIN;
+                } else if (!strcasecmp(c->argv[j]->ptr,"max")) {
+                    aggregate = REDIS_AGGR_MAX;
+                } else {
+                    zfree(src);
+                    addReply(c,shared.syntaxerr);
+                    return;
+                }
+                j++; remaining--;
+            } else {
+                zfree(src);
+                addReply(c,shared.syntaxerr);
+                return;
+            }
+        }
+    }
+
+    /* sort sets from the smallest to largest, this will improve our
+     * algorithm's performance */
+    qsort(src,zsetnum,sizeof(zsetopsrc), qsortCompareZsetopsrcByCardinality);
+
+    dstobj = createZsetObject();
+    dstzset = dstobj->ptr;
+
+    if (op == REDIS_OP_INTER) {
+        /* skip going over all entries if the smallest zset is NULL or empty */
+        if (src[0].dict && dictSize(src[0].dict) > 0) {
+            /* precondition: as src[0].dict is non-empty and the zsets are ordered
+             * from small to large, all src[i > 0].dict are non-empty too */
+            di = dictGetIterator(src[0].dict);
+            while((de = dictNext(di)) != NULL) {
+                double *score = zmalloc(sizeof(double)), value;
+                *score = src[0].weight * (*(double*)dictGetEntryVal(de));
+
+                for (j = 1; j < zsetnum; j++) {
+                    dictEntry *other = dictFind(src[j].dict,dictGetEntryKey(de));
+                    if (other) {
+                        value = src[j].weight * (*(double*)dictGetEntryVal(other));
+                        zunionInterAggregate(score, value, aggregate);
+                    } else {
+                        break;
+                    }
+                }
+
+                /* skip entry when not present in every source dict */
+                if (j != zsetnum) {
+                    zfree(score);
+                } else {
+                    robj *o = dictGetEntryKey(de);
+                    dictAdd(dstzset->dict,o,score);
+                    incrRefCount(o); /* added to dictionary */
+                    zslInsert(dstzset->zsl,*score,o);
+                    incrRefCount(o); /* added to skiplist */
+                }
+            }
+            dictReleaseIterator(di);
+        }
+    } else if (op == REDIS_OP_UNION) {
+        for (i = 0; i < zsetnum; i++) {
+            if (!src[i].dict) continue;
+
+            di = dictGetIterator(src[i].dict);
+            while((de = dictNext(di)) != NULL) {
+                /* skip key when already processed */
+                if (dictFind(dstzset->dict,dictGetEntryKey(de)) != NULL) continue;
+
+                double *score = zmalloc(sizeof(double)), value;
+                *score = src[i].weight * (*(double*)dictGetEntryVal(de));
+
+                /* because the zsets are sorted by size, its only possible
+                 * for sets at larger indices to hold this entry */
+                for (j = (i+1); j < zsetnum; j++) {
+                    dictEntry *other = dictFind(src[j].dict,dictGetEntryKey(de));
+                    if (other) {
+                        value = src[j].weight * (*(double*)dictGetEntryVal(other));
+                        zunionInterAggregate(score, value, aggregate);
+                    }
+                }
+
+                robj *o = dictGetEntryKey(de);
+                dictAdd(dstzset->dict,o,score);
+                incrRefCount(o); /* added to dictionary */
+                zslInsert(dstzset->zsl,*score,o);
+                incrRefCount(o); /* added to skiplist */
+            }
+            dictReleaseIterator(di);
+        }
+    } else {
+        /* unknown operator */
+        redisAssert(op == REDIS_OP_INTER || op == REDIS_OP_UNION);
+    }
+
+    if (deleteKey(c->db,dstkey)) server.dirty++;
+    if (dstzset->zsl->length) {
+        dictAdd(c->db->dict,dstkey,dstobj);
+        incrRefCount(dstkey);
+        addReplyLongLong(c, dstzset->zsl->length);
+        server.dirty++;
+    } else {
+        decrRefCount(dstobj);
+        addReply(c, shared.czero);
+    }
+    zfree(src);
+}
+
+static void zunionstoreCommand(redisClient *c) {
+    zunionInterGenericCommand(c,c->argv[1], REDIS_OP_UNION);
+}
+
+static void zinterstoreCommand(redisClient *c) {
+    zunionInterGenericCommand(c,c->argv[1], REDIS_OP_INTER);
+}
+
+static void zrangeGenericCommand(redisClient *c, int reverse) {
+    robj *o;
+    long start;
+    long end;
+    int withscores = 0;
+    int llen;
+    int rangelen, j;
+    zset *zsetobj;
+    zskiplist *zsl;
+    zskiplistNode *ln;
+    robj *ele;
+
+    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != REDIS_OK) ||
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != REDIS_OK)) return;
+
+    if (c->argc == 5 && !strcasecmp(c->argv[4]->ptr,"withscores")) {
+        withscores = 1;
+    } else if (c->argc >= 5) {
+        addReply(c,shared.syntaxerr);
+        return;
+    }
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
+         || checkType(c,o,REDIS_ZSET)) return;
+    zsetobj = o->ptr;
+    zsl = zsetobj->zsl;
+    llen = zsl->length;
+
+    /* convert negative indexes */
+    if (start < 0) start = llen+start;
+    if (end < 0) end = llen+end;
+    if (start < 0) start = 0;
+
+    /* Invariant: start >= 0, so this test will be true when end < 0.
+     * The range is empty when start > end or start >= length. */
+    if (start > end || start >= llen) {
+        addReply(c,shared.emptymultibulk);
+        return;
+    }
+    if (end >= llen) end = llen-1;
+    rangelen = (end-start)+1;
+
+    /* check if starting point is trivial, before searching
+     * the element in log(N) time */
+    if (reverse) {
+        ln = start == 0 ? zsl->tail : zslGetElementByRank(zsl, llen-start);
+    } else {
+        ln = start == 0 ?
+            zsl->header->forward[0] : zslGetElementByRank(zsl, start+1);
+    }
+
+    /* Return the result in form of a multi-bulk reply */
+    addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",
+        withscores ? (rangelen*2) : rangelen));
+    for (j = 0; j < rangelen; j++) {
+        ele = ln->obj;
+        addReplyBulk(c,ele);
+        if (withscores)
+            addReplyDouble(c,ln->score);
+        ln = reverse ? ln->backward : ln->forward[0];
+    }
+}
+
+static void zrangeCommand(redisClient *c) {
+    zrangeGenericCommand(c,0);
+}
+
+static void zrevrangeCommand(redisClient *c) {
+    zrangeGenericCommand(c,1);
+}
+
+/* This command implements both ZRANGEBYSCORE and ZCOUNT.
+ * If justcount is non-zero, just the count is returned. */
+static void genericZrangebyscoreCommand(redisClient *c, int justcount) {
+    robj *o;
+    double min, max;
+    int minex = 0, maxex = 0; /* are min or max exclusive? */
+    int offset = 0, limit = -1;
+    int withscores = 0;
+    int badsyntax = 0;
+
+    /* Parse the min-max interval. If one of the values is prefixed
+     * by the "(" character, it's considered "open". For instance
+     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max
+     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */
+    if (((char*)c->argv[2]->ptr)[0] == '(') {
+        min = strtod((char*)c->argv[2]->ptr+1,NULL);
+        minex = 1;
+    } else {
+        min = strtod(c->argv[2]->ptr,NULL);
+    }
+    if (((char*)c->argv[3]->ptr)[0] == '(') {
+        max = strtod((char*)c->argv[3]->ptr+1,NULL);
+        maxex = 1;
+    } else {
+        max = strtod(c->argv[3]->ptr,NULL);
+    }
+
+    /* Parse "WITHSCORES": note that if the command was called with
+     * the name ZCOUNT then we are sure that c->argc == 4, so we'll never
+     * enter the following paths to parse WITHSCORES and LIMIT. */
+    if (c->argc == 5 || c->argc == 8) {
+        if (strcasecmp(c->argv[c->argc-1]->ptr,"withscores") == 0)
+            withscores = 1;
+        else
+            badsyntax = 1;
+    }
+    if (c->argc != (4 + withscores) && c->argc != (7 + withscores))
+        badsyntax = 1;
+    if (badsyntax) {
+        addReplySds(c,
+            sdsnew("-ERR wrong number of arguments for ZRANGEBYSCORE\r\n"));
+        return;
+    }
+
+    /* Parse "LIMIT" */
+    if (c->argc == (7 + withscores) && strcasecmp(c->argv[4]->ptr,"limit")) {
+        addReply(c,shared.syntaxerr);
+        return;
+    } else if (c->argc == (7 + withscores)) {
+        offset = atoi(c->argv[5]->ptr);
+        limit = atoi(c->argv[6]->ptr);
+        if (offset < 0) offset = 0;
+    }
+
+    /* Ok, lookup the key and get the range */
+    o = lookupKeyRead(c->db,c->argv[1]);
+    if (o == NULL) {
+        addReply(c,justcount ? shared.czero : shared.emptymultibulk);
+    } else {
+        if (o->type != REDIS_ZSET) {
+            addReply(c,shared.wrongtypeerr);
+        } else {
+            zset *zsetobj = o->ptr;
+            zskiplist *zsl = zsetobj->zsl;
+            zskiplistNode *ln;
+            robj *ele, *lenobj = NULL;
+            unsigned long rangelen = 0;
+
+            /* Get the first node with the score >= min, or with
+             * score > min if 'minex' is true. */
+            ln = zslFirstWithScore(zsl,min);
+            while (minex && ln && ln->score == min) ln = ln->forward[0];
+
+            if (ln == NULL) {
+                /* No element matching the speciifed interval */
+                addReply(c,justcount ? shared.czero : shared.emptymultibulk);
+                return;
+            }
+
+            /* We don't know in advance how many matching elements there
+             * are in the list, so we push this object that will represent
+             * the multi-bulk length in the output buffer, and will "fix"
+             * it later */
+            if (!justcount) {
+                lenobj = createObject(REDIS_STRING,NULL);
+                addReply(c,lenobj);
+                decrRefCount(lenobj);
+            }
+
+            while(ln && (maxex ? (ln->score < max) : (ln->score <= max))) {
+                if (offset) {
+                    offset--;
+                    ln = ln->forward[0];
+                    continue;
+                }
+                if (limit == 0) break;
+                if (!justcount) {
+                    ele = ln->obj;
+                    addReplyBulk(c,ele);
+                    if (withscores)
+                        addReplyDouble(c,ln->score);
+                }
+                ln = ln->forward[0];
+                rangelen++;
+                if (limit > 0) limit--;
+            }
+            if (justcount) {
+                addReplyLongLong(c,(long)rangelen);
+            } else {
+                lenobj->ptr = sdscatprintf(sdsempty(),"*%lu\r\n",
+                     withscores ? (rangelen*2) : rangelen);
+            }
+        }
+    }
+}
+
+static void zrangebyscoreCommand(redisClient *c) {
+    genericZrangebyscoreCommand(c,0);
+}
+
+static void zcountCommand(redisClient *c) {
+    genericZrangebyscoreCommand(c,1);
+}
+
+static void zcardCommand(redisClient *c) {
+    robj *o;
+    zset *zs;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,REDIS_ZSET)) return;
+
+    zs = o->ptr;
+    addReplyUlong(c,zs->zsl->length);
+}
+
+static void zscoreCommand(redisClient *c) {
+    robj *o;
+    zset *zs;
+    dictEntry *de;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,o,REDIS_ZSET)) return;
+
+    zs = o->ptr;
+    de = dictFind(zs->dict,c->argv[2]);
+    if (!de) {
+        addReply(c,shared.nullbulk);
+    } else {
+        double *score = dictGetEntryVal(de);
+
+        addReplyDouble(c,*score);
+    }
+}
+
+static void zrankGenericCommand(redisClient *c, int reverse) {
+    robj *o;
+    zset *zs;
+    zskiplist *zsl;
+    dictEntry *de;
+    unsigned long rank;
+    double *score;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,o,REDIS_ZSET)) return;
+
+    zs = o->ptr;
+    zsl = zs->zsl;
+    de = dictFind(zs->dict,c->argv[2]);
+    if (!de) {
+        addReply(c,shared.nullbulk);
+        return;
+    }
+
+    score = dictGetEntryVal(de);
+    rank = zslGetRank(zsl, *score, c->argv[2]);
+    if (rank) {
+        if (reverse) {
+            addReplyLongLong(c, zsl->length - rank);
+        } else {
+            addReplyLongLong(c, rank-1);
+        }
+    } else {
+        addReply(c,shared.nullbulk);
+    }
+}
+
+static void zrankCommand(redisClient *c) {
+    zrankGenericCommand(c, 0);
+}
+
+static void zrevrankCommand(redisClient *c) {
+    zrankGenericCommand(c, 1);
+}
+
+/* ========================= Hashes utility functions ======================= */
+#define REDIS_HASH_KEY 1
+#define REDIS_HASH_VALUE 2
+
+/* Check the length of a number of objects to see if we need to convert a
+ * zipmap to a real hash. Note that we only check string encoded objects
+ * as their string length can be queried in constant time. */
+static void hashTryConversion(robj *subject, robj **argv, int start, int end) {
+    int i;
+    if (subject->encoding != REDIS_ENCODING_ZIPMAP) return;
+
+    for (i = start; i <= end; i++) {
+        if (argv[i]->encoding == REDIS_ENCODING_RAW &&
+            sdslen(argv[i]->ptr) > server.hash_max_zipmap_value)
+        {
+            convertToRealHash(subject);
+            return;
+        }
+    }
+}
+
+/* Encode given objects in-place when the hash uses a dict. */
+static void hashTryObjectEncoding(robj *subject, robj **o1, robj **o2) {
+    if (subject->encoding == REDIS_ENCODING_HT) {
+        if (o1) *o1 = tryObjectEncoding(*o1);
+        if (o2) *o2 = tryObjectEncoding(*o2);
+    }
+}
+
+/* Get the value from a hash identified by key. Returns either a string
+ * object or NULL if the value cannot be found. The refcount of the object
+ * is always increased by 1 when the value was found. */
+static robj *hashGet(robj *o, robj *key) {
+    robj *value = NULL;
+    if (o->encoding == REDIS_ENCODING_ZIPMAP) {
+        unsigned char *v;
+        unsigned int vlen;
+        key = getDecodedObject(key);
+        if (zipmapGet(o->ptr,key->ptr,sdslen(key->ptr),&v,&vlen)) {
+            value = createStringObject((char*)v,vlen);
+        }
+        decrRefCount(key);
+    } else {
+        dictEntry *de = dictFind(o->ptr,key);
+        if (de != NULL) {
+            value = dictGetEntryVal(de);
+            incrRefCount(value);
+        }
+    }
+    return value;
+}
+
+/* Test if the key exists in the given hash. Returns 1 if the key
+ * exists and 0 when it doesn't. */
+static int hashExists(robj *o, robj *key) {
+    if (o->encoding == REDIS_ENCODING_ZIPMAP) {
+        key = getDecodedObject(key);
+        if (zipmapExists(o->ptr,key->ptr,sdslen(key->ptr))) {
+            decrRefCount(key);
+            return 1;
+        }
+        decrRefCount(key);
+    } else {
+        if (dictFind(o->ptr,key) != NULL) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+/* Add an element, discard the old if the key already exists.
+ * Return 0 on insert and 1 on update. */
+static int hashSet(robj *o, robj *key, robj *value) {
+    int update = 0;
+    if (o->encoding == REDIS_ENCODING_ZIPMAP) {
+        key = getDecodedObject(key);
+        value = getDecodedObject(value);
+        o->ptr = zipmapSet(o->ptr,
+            key->ptr,sdslen(key->ptr),
+            value->ptr,sdslen(value->ptr), &update);
+        decrRefCount(key);
+        decrRefCount(value);
+
+        /* Check if the zipmap needs to be upgraded to a real hash table */
+        if (zipmapLen(o->ptr) > server.hash_max_zipmap_entries)
+            convertToRealHash(o);
+    } else {
+        if (dictReplace(o->ptr,key,value)) {
+            /* Insert */
+            incrRefCount(key);
+        } else {
+            /* Update */
+            update = 1;
+        }
+        incrRefCount(value);
+    }
+    return update;
+}
+
+/* Delete an element from a hash.
+ * Return 1 on deleted and 0 on not found. */
+static int hashDelete(robj *o, robj *key) {
+    int deleted = 0;
+    if (o->encoding == REDIS_ENCODING_ZIPMAP) {
+        key = getDecodedObject(key);
+        o->ptr = zipmapDel(o->ptr,key->ptr,sdslen(key->ptr), &deleted);
+        decrRefCount(key);
+    } else {
+        deleted = dictDelete((dict*)o->ptr,key) == DICT_OK;
+        /* Always check if the dictionary needs a resize after a delete. */
+        if (deleted && htNeedsResize(o->ptr)) dictResize(o->ptr);
+    }
+    return deleted;
+}
+
+/* Return the number of elements in a hash. */
+static unsigned long hashLength(robj *o) {
+    return (o->encoding == REDIS_ENCODING_ZIPMAP) ?
+        zipmapLen((unsigned char*)o->ptr) : dictSize((dict*)o->ptr);
+}
+
+/* Structure to hold hash iteration abstration. Note that iteration over
+ * hashes involves both fields and values. Because it is possible that
+ * not both are required, store pointers in the iterator to avoid
+ * unnecessary memory allocation for fields/values. */
+typedef struct {
+    int encoding;
+    unsigned char *zi;
+    unsigned char *zk, *zv;
+    unsigned int zklen, zvlen;
+
+    dictIterator *di;
+    dictEntry *de;
+} hashIterator;
+
+static hashIterator *hashInitIterator(robj *subject) {
+    hashIterator *hi = zmalloc(sizeof(hashIterator));
+    hi->encoding = subject->encoding;
+    if (hi->encoding == REDIS_ENCODING_ZIPMAP) {
+        hi->zi = zipmapRewind(subject->ptr);
+    } else if (hi->encoding == REDIS_ENCODING_HT) {
+        hi->di = dictGetIterator(subject->ptr);
+    } else {
+        redisAssert(NULL);
+    }
+    return hi;
+}
+
+static void hashReleaseIterator(hashIterator *hi) {
+    if (hi->encoding == REDIS_ENCODING_HT) {
+        dictReleaseIterator(hi->di);
+    }
+    zfree(hi);
+}
+
+/* Move to the next entry in the hash. Return REDIS_OK when the next entry
+ * could be found and REDIS_ERR when the iterator reaches the end. */
+static int hashNext(hashIterator *hi) {
+    if (hi->encoding == REDIS_ENCODING_ZIPMAP) {
+        if ((hi->zi = zipmapNext(hi->zi, &hi->zk, &hi->zklen,
+            &hi->zv, &hi->zvlen)) == NULL) return REDIS_ERR;
+    } else {
+        if ((hi->de = dictNext(hi->di)) == NULL) return REDIS_ERR;
+    }
+    return REDIS_OK;
+}
+
+/* Get key or value object at current iteration position.
+ * This increases the refcount of the field object by 1. */
+static robj *hashCurrent(hashIterator *hi, int what) {
+    robj *o;
+    if (hi->encoding == REDIS_ENCODING_ZIPMAP) {
+        if (what & REDIS_HASH_KEY) {
+            o = createStringObject((char*)hi->zk,hi->zklen);
+        } else {
+            o = createStringObject((char*)hi->zv,hi->zvlen);
+        }
+    } else {
+        if (what & REDIS_HASH_KEY) {
+            o = dictGetEntryKey(hi->de);
+        } else {
+            o = dictGetEntryVal(hi->de);
+        }
+        incrRefCount(o);
+    }
+    return o;
+}
+
+static robj *hashLookupWriteOrCreate(redisClient *c, robj *key) {
+    robj *o = lookupKeyWrite(c->db,key);
+    if (o == NULL) {
+        o = createHashObject();
+        dictAdd(c->db->dict,key,o);
+        incrRefCount(key);
+    } else {
+        if (o->type != REDIS_HASH) {
+            addReply(c,shared.wrongtypeerr);
+            return NULL;
+        }
+    }
+    return o;
+}
+
+/* ============================= Hash commands ============================== */
+static void hsetCommand(redisClient *c) {
+    int update;
+    robj *o;
+
+    if ((o = hashLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    hashTryConversion(o,c->argv,2,3);
+    hashTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
+    update = hashSet(o,c->argv[2],c->argv[3]);
+    addReply(c, update ? shared.czero : shared.cone);
+    server.dirty++;
+}
+
+static void hsetnxCommand(redisClient *c) {
+    robj *o;
+    if ((o = hashLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    hashTryConversion(o,c->argv,2,3);
+
+    if (hashExists(o, c->argv[2])) {
+        addReply(c, shared.czero);
+    } else {
+        hashTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
+        hashSet(o,c->argv[2],c->argv[3]);
+        addReply(c, shared.cone);
+        server.dirty++;
+    }
+}
+
+static void hmsetCommand(redisClient *c) {
+    int i;
+    robj *o;
+
+    if ((c->argc % 2) == 1) {
+        addReplySds(c,sdsnew("-ERR wrong number of arguments for HMSET\r\n"));
+        return;
+    }
+
+    if ((o = hashLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    hashTryConversion(o,c->argv,2,c->argc-1);
+    for (i = 2; i < c->argc; i += 2) {
+        hashTryObjectEncoding(o,&c->argv[i], &c->argv[i+1]);
+        hashSet(o,c->argv[i],c->argv[i+1]);
+    }
+    addReply(c, shared.ok);
+    server.dirty++;
+}
+
+static void hincrbyCommand(redisClient *c) {
+    long long value, incr;
+    robj *o, *current, *new;
+
+    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != REDIS_OK) return;
+    if ((o = hashLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    if ((current = hashGet(o,c->argv[2])) != NULL) {
+        if (getLongLongFromObjectOrReply(c,current,&value,
+            "hash value is not an integer") != REDIS_OK) {
+            decrRefCount(current);
+            return;
+        }
+        decrRefCount(current);
+    } else {
+        value = 0;
+    }
+
+    value += incr;
+    new = createStringObjectFromLongLong(value);
+    hashTryObjectEncoding(o,&c->argv[2],NULL);
+    hashSet(o,c->argv[2],new);
+    decrRefCount(new);
+    addReplyLongLong(c,value);
+    server.dirty++;
+}
+
+static void hgetCommand(redisClient *c) {
+    robj *o, *value;
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
+        checkType(c,o,REDIS_HASH)) return;
+
+    if ((value = hashGet(o,c->argv[2])) != NULL) {
+        addReplyBulk(c,value);
+        decrRefCount(value);
+    } else {
+        addReply(c,shared.nullbulk);
+    }
+}
+
+static void hmgetCommand(redisClient *c) {
+    int i;
+    robj *o, *value;
+    o = lookupKeyRead(c->db,c->argv[1]);
+    if (o != NULL && o->type != REDIS_HASH) {
+        addReply(c,shared.wrongtypeerr);
+        return;
+    }
+
+    /* Note the check for o != NULL happens inside the loop. This is
+     * done because objects that cannot be found are considered to be
+     * an empty hash. The reply should then be a series of NULLs. */
+    addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",c->argc-2));
+    for (i = 2; i < c->argc; i++) {
+        if (o != NULL && (value = hashGet(o,c->argv[i])) != NULL) {
+            addReplyBulk(c,value);
+            decrRefCount(value);
+        } else {
+            addReply(c,shared.nullbulk);
+        }
+    }
+}
+
+static void hdelCommand(redisClient *c) {
+    robj *o;
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,REDIS_HASH)) return;
+
+    if (hashDelete(o,c->argv[2])) {
+        if (hashLength(o) == 0) deleteKey(c->db,c->argv[1]);
+        addReply(c,shared.cone);
+        server.dirty++;
+    } else {
+        addReply(c,shared.czero);
+    }
+}
+
+static void hlenCommand(redisClient *c) {
+    robj *o;
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,REDIS_HASH)) return;
+
+    addReplyUlong(c,hashLength(o));
+}
+
+static void genericHgetallCommand(redisClient *c, int flags) {
+    robj *o, *lenobj, *obj;
+    unsigned long count = 0;
+    hashIterator *hi;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
+        || checkType(c,o,REDIS_HASH)) return;
+
+    lenobj = createObject(REDIS_STRING,NULL);
+    addReply(c,lenobj);
+    decrRefCount(lenobj);
+
+    hi = hashInitIterator(o);
+    while (hashNext(hi) != REDIS_ERR) {
+        if (flags & REDIS_HASH_KEY) {
+            obj = hashCurrent(hi,REDIS_HASH_KEY);
+            addReplyBulk(c,obj);
+            decrRefCount(obj);
+            count++;
+        }
+        if (flags & REDIS_HASH_VALUE) {
+            obj = hashCurrent(hi,REDIS_HASH_VALUE);
+            addReplyBulk(c,obj);
+            decrRefCount(obj);
+            count++;
+        }
+    }
+    hashReleaseIterator(hi);
+
+    lenobj->ptr = sdscatprintf(sdsempty(),"*%lu\r\n",count);
+}
+
+static void hkeysCommand(redisClient *c) {
+    genericHgetallCommand(c,REDIS_HASH_KEY);
+}
+
+static void hvalsCommand(redisClient *c) {
+    genericHgetallCommand(c,REDIS_HASH_VALUE);
+}
+
+static void hgetallCommand(redisClient *c) {
+    genericHgetallCommand(c,REDIS_HASH_KEY|REDIS_HASH_VALUE);
+}
+
+static void hexistsCommand(redisClient *c) {
+    robj *o;
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,REDIS_HASH)) return;
+
+    addReply(c, hashExists(o,c->argv[2]) ? shared.cone : shared.czero);
+}
+
+static void convertToRealHash(robj *o) {
+    unsigned char *key, *val, *p, *zm = o->ptr;
+    unsigned int klen, vlen;
+    dict *dict = dictCreate(&hashDictType,NULL);
+
+    assert(o->type == REDIS_HASH && o->encoding != REDIS_ENCODING_HT);
+    p = zipmapRewind(zm);
+    while((p = zipmapNext(p,&key,&klen,&val,&vlen)) != NULL) {
+        robj *keyobj, *valobj;
+
+        keyobj = createStringObject((char*)key,klen);
+        valobj = createStringObject((char*)val,vlen);
+        keyobj = tryObjectEncoding(keyobj);
+        valobj = tryObjectEncoding(valobj);
+        dictAdd(dict,keyobj,valobj);
+    }
+    o->encoding = REDIS_ENCODING_HT;
+    o->ptr = dict;
+    zfree(zm);
+}
+
+/* ========================= Non type-specific commands  ==================== */
+
+static void flushdbCommand(redisClient *c) {
+    server.dirty += dictSize(c->db->dict);
+    dictEmpty(c->db->dict);
+    dictEmpty(c->db->expires);
+    addReply(c,shared.ok);
+}
+
+static redisSortOperation *createSortOperation(int type, robj *pattern) {
+    redisSortOperation *so = zmalloc(sizeof(*so));
+    so->type = type;
+    so->pattern = pattern;
+    return so;
+}
+
+/* Return the value associated to the key with a name obtained
+ * substituting the first occurence of '*' in 'pattern' with 'subst'.
+ * The returned object will always have its refcount increased by 1
+ * when it is non-NULL. */
+static robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
+    char *p, *f;
+    sds spat, ssub;
+    robj keyobj, fieldobj, *o;
+    int prefixlen, sublen, postfixlen, fieldlen;
+    /* Expoit the internal sds representation to create a sds string allocated on the stack in order to make this function faster */
+    struct {
+        long len;
+        long free;
+        char buf[REDIS_SORTKEY_MAX+1];
+    } keyname, fieldname;
+
+    /* If the pattern is "#" return the substitution object itself in order
+     * to implement the "SORT ... GET #" feature. */
+    spat = pattern->ptr;
+    if (spat[0] == '#' && spat[1] == '\0') {
+        incrRefCount(subst);
+        return subst;
+    }
+
+    /* The substitution object may be specially encoded. If so we create
+     * a decoded object on the fly. Otherwise getDecodedObject will just
+     * increment the ref count, that we'll decrement later. */
+    subst = getDecodedObject(subst);
+
+    ssub = subst->ptr;
+    if (sdslen(spat)+sdslen(ssub)-1 > REDIS_SORTKEY_MAX) return NULL;
+    p = strchr(spat,'*');
+    if (!p) {
+        decrRefCount(subst);
+        return NULL;
+    }
+
+    /* Find out if we're dealing with a hash dereference. */
+    if ((f = strstr(p+1, "->")) != NULL) {
+        fieldlen = sdslen(spat)-(f-spat);
+        /* this also copies \0 character */
+        memcpy(fieldname.buf,f+2,fieldlen-1);
+        fieldname.len = fieldlen-2;
+    } else {
+        fieldlen = 0;
+    }
+
+    prefixlen = p-spat;
+    sublen = sdslen(ssub);
+    postfixlen = sdslen(spat)-(prefixlen+1)-fieldlen;
+    memcpy(keyname.buf,spat,prefixlen);
+    memcpy(keyname.buf+prefixlen,ssub,sublen);
+    memcpy(keyname.buf+prefixlen+sublen,p+1,postfixlen);
+    keyname.buf[prefixlen+sublen+postfixlen] = '\0';
+    keyname.len = prefixlen+sublen+postfixlen;
+    decrRefCount(subst);
+
+    /* Lookup substituted key */
+    initStaticStringObject(keyobj,((char*)&keyname)+(sizeof(long)*2));
+    o = lookupKeyRead(db,&keyobj);
+    if (o == NULL) return NULL;
+
+    if (fieldlen > 0) {
+        if (o->type != REDIS_HASH || fieldname.len < 1) return NULL;
+
+        /* Retrieve value from hash by the field name. This operation
+         * already increases the refcount of the returned object. */
+        initStaticStringObject(fieldobj,((char*)&fieldname)+(sizeof(long)*2));
+        o = hashGet(o, &fieldobj);
+    } else {
+        if (o->type != REDIS_STRING) return NULL;
+
+        /* Every object that this function returns needs to have its refcount
+         * increased. sortCommand decreases it again. */
+        incrRefCount(o);
+    }
+
+    return o;
+}
+
+/* sortCompare() is used by qsort in sortCommand(). Given that qsort_r with
+ * the additional parameter is not standard but a BSD-specific we have to
+ * pass sorting parameters via the global 'server' structure */
+static int sortCompare(const void *s1, const void *s2) {
+    const redisSortObject *so1 = s1, *so2 = s2;
+    int cmp;
+
+    if (!server.sort_alpha) {
+        /* Numeric sorting. Here it's trivial as we precomputed scores */
+        if (so1->u.score > so2->u.score) {
+            cmp = 1;
+        } else if (so1->u.score < so2->u.score) {
+            cmp = -1;
+        } else {
+            cmp = 0;
+        }
+    } else {
+        /* Alphanumeric sorting */
+        if (server.sort_bypattern) {
+            if (!so1->u.cmpobj || !so2->u.cmpobj) {
+                /* At least one compare object is NULL */
+                if (so1->u.cmpobj == so2->u.cmpobj)
+                    cmp = 0;
+                else if (so1->u.cmpobj == NULL)
+                    cmp = -1;
+                else
+                    cmp = 1;
+            } else {
+                /* We have both the objects, use strcoll */
+                cmp = strcoll(so1->u.cmpobj->ptr,so2->u.cmpobj->ptr);
+            }
+        } else {
+            /* Compare elements directly. */
+            cmp = compareStringObjects(so1->obj,so2->obj);
+        }
+    }
+    return server.sort_desc ? -cmp : cmp;
+}
+
+/* The SORT command is the most complex command in Redis. Warning: this code
+ * is optimized for speed and a bit less for readability */
+static void sortCommand(redisClient *c) {
+    list *operations;
+    int outputlen = 0;
+    int desc = 0, alpha = 0;
+    int limit_start = 0, limit_count = -1, start, end;
+    int j, dontsort = 0, vectorlen;
+    int getop = 0; /* GET operation counter */
+    robj *sortval, *sortby = NULL, *storekey = NULL;
+    redisSortObject *vector; /* Resulting vector to sort */
+
+    /* Lookup the key to sort. It must be of the right types */
+    sortval = lookupKeyRead(c->db,c->argv[1]);
+    if (sortval == NULL) {
+        addReply(c,shared.emptymultibulk);
+        return;
+    }
+    if (sortval->type != REDIS_SET && sortval->type != REDIS_LIST &&
+        sortval->type != REDIS_ZSET)
+    {
+        addReply(c,shared.wrongtypeerr);
+        return;
+    }
+
+    /* Create a list of operations to perform for every sorted element.
+     * Operations can be GET/DEL/INCR/DECR */
+    operations = listCreate();
+    listSetFreeMethod(operations,zfree);
+    j = 2;
+
+    /* Now we need to protect sortval incrementing its count, in the future
+     * SORT may have options able to overwrite/delete keys during the sorting
+     * and the sorted key itself may get destroied */
+    incrRefCount(sortval);
+
+    /* The SORT command has an SQL-alike syntax, parse it */
+    while(j < c->argc) {
+        int leftargs = c->argc-j-1;
+        if (!strcasecmp(c->argv[j]->ptr,"asc")) {
+            desc = 0;
+        } else if (!strcasecmp(c->argv[j]->ptr,"desc")) {
+            desc = 1;
+        } else if (!strcasecmp(c->argv[j]->ptr,"alpha")) {
+            alpha = 1;
+        } else if (!strcasecmp(c->argv[j]->ptr,"limit") && leftargs >= 2) {
+            limit_start = atoi(c->argv[j+1]->ptr);
+            limit_count = atoi(c->argv[j+2]->ptr);
+            j+=2;
+        } else if (!strcasecmp(c->argv[j]->ptr,"store") && leftargs >= 1) {
+            storekey = c->argv[j+1];
+            j++;
+        } else if (!strcasecmp(c->argv[j]->ptr,"by") && leftargs >= 1) {
+            sortby = c->argv[j+1];
+            /* If the BY pattern does not contain '*', i.e. it is constant,
+             * we don't need to sort nor to lookup the weight keys. */
+            if (strchr(c->argv[j+1]->ptr,'*') == NULL) dontsort = 1;
+            j++;
+        } else if (!strcasecmp(c->argv[j]->ptr,"get") && leftargs >= 1) {
+            listAddNodeTail(operations,createSortOperation(
+                REDIS_SORT_GET,c->argv[j+1]));
+            getop++;
+            j++;
+        } else {
+            decrRefCount(sortval);
+            listRelease(operations);
+            addReply(c,shared.syntaxerr);
+            return;
+        }
+        j++;
+    }
+
+    /* Load the sorting vector with all the objects to sort */
+    switch(sortval->type) {
+    case REDIS_LIST: vectorlen = listLength((list*)sortval->ptr); break;
+    case REDIS_SET: vectorlen =  dictSize((dict*)sortval->ptr); break;
+    case REDIS_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;
+    default: vectorlen = 0; redisPanic("Bad SORT type"); /* Avoid GCC warning */
+    }
+    vector = zmalloc(sizeof(redisSortObject)*vectorlen);
+    j = 0;
+
+    if (sortval->type == REDIS_LIST) {
+        list *list = sortval->ptr;
+        listNode *ln;
+        listIter li;
+
+        listRewind(list,&li);
+        while((ln = listNext(&li))) {
+            robj *ele = ln->value;
+            vector[j].obj = ele;
+            vector[j].u.score = 0;
+            vector[j].u.cmpobj = NULL;
+            j++;
+        }
+    } else {
+        dict *set;
+        dictIterator *di;
+        dictEntry *setele;
+
+        if (sortval->type == REDIS_SET) {
+            set = sortval->ptr;
+        } else {
+            zset *zs = sortval->ptr;
+            set = zs->dict;
+        }
+
+        di = dictGetIterator(set);
+        while((setele = dictNext(di)) != NULL) {
+            vector[j].obj = dictGetEntryKey(setele);
+            vector[j].u.score = 0;
+            vector[j].u.cmpobj = NULL;
+            j++;
+        }
+        dictReleaseIterator(di);
+    }
+    redisAssert(j == vectorlen);
+
+    /* Now it's time to load the right scores in the sorting vector */
+    if (dontsort == 0) {
+        for (j = 0; j < vectorlen; j++) {
+            robj *byval;
+            if (sortby) {
+                /* lookup value to sort by */
+                byval = lookupKeyByPattern(c->db,sortby,vector[j].obj);
+                if (!byval) continue;
+            } else {
+                /* use object itself to sort by */
+                byval = vector[j].obj;
+            }
+
+            if (alpha) {
+                if (sortby) vector[j].u.cmpobj = getDecodedObject(byval);
+            } else {
+                if (byval->encoding == REDIS_ENCODING_RAW) {
+                    vector[j].u.score = strtod(byval->ptr,NULL);
+                } else if (byval->encoding == REDIS_ENCODING_INT) {
+                    /* Don't need to decode the object if it's
+                     * integer-encoded (the only encoding supported) so
+                     * far. We can just cast it */
+                    vector[j].u.score = (long)byval->ptr;
+                } else {
+                    redisAssert(1 != 1);
+                }
+            }
+
+            /* when the object was retrieved using lookupKeyByPattern,
+             * its refcount needs to be decreased. */
+            if (sortby) {
+                decrRefCount(byval);
+            }
+        }
+    }
+
+    /* We are ready to sort the vector... perform a bit of sanity check
+     * on the LIMIT option too. We'll use a partial version of quicksort. */
+    start = (limit_start < 0) ? 0 : limit_start;
+    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;
+    if (start >= vectorlen) {
+        start = vectorlen-1;
+        end = vectorlen-2;
+    }
+    if (end >= vectorlen) end = vectorlen-1;
+
+    if (dontsort == 0) {
+        server.sort_desc = desc;
+        server.sort_alpha = alpha;
+        server.sort_bypattern = sortby ? 1 : 0;
+        if (sortby && (start != 0 || end != vectorlen-1))
+            pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);
+        else
+            qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);
+    }
+
+    /* Send command output to the output buffer, performing the specified
+     * GET/DEL/INCR/DECR operations if any. */
+    outputlen = getop ? getop*(end-start+1) : end-start+1;
+    if (storekey == NULL) {
+        /* STORE option not specified, sent the sorting result to client */
+        addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",outputlen));
+        for (j = start; j <= end; j++) {
+            listNode *ln;
+            listIter li;
+
+            if (!getop) addReplyBulk(c,vector[j].obj);
+            listRewind(operations,&li);
+            while((ln = listNext(&li))) {
+                redisSortOperation *sop = ln->value;
+                robj *val = lookupKeyByPattern(c->db,sop->pattern,
+                    vector[j].obj);
+
+                if (sop->type == REDIS_SORT_GET) {
+                    if (!val) {
+                        addReply(c,shared.nullbulk);
+                    } else {
+                        addReplyBulk(c,val);
+                        decrRefCount(val);
+                    }
+                } else {
+                    redisAssert(sop->type == REDIS_SORT_GET); /* always fails */
+                }
+            }
+        }
+    } else {
+        robj *listObject = createListObject();
+        list *listPtr = (list*) listObject->ptr;
+
+        /* STORE option specified, set the sorting result as a List object */
+        for (j = start; j <= end; j++) {
+            listNode *ln;
+            listIter li;
+
+            if (!getop) {
+                listAddNodeTail(listPtr,vector[j].obj);
+                incrRefCount(vector[j].obj);
+            }
+            listRewind(operations,&li);
+            while((ln = listNext(&li))) {
+                redisSortOperation *sop = ln->value;
+                robj *val = lookupKeyByPattern(c->db,sop->pattern,
+                    vector[j].obj);
+
+                if (sop->type == REDIS_SORT_GET) {
+                    if (!val) {
+                        listAddNodeTail(listPtr,createStringObject("",0));
+                    } else {
+                        /* We should do a incrRefCount on val because it is
+                         * added to the list, but also a decrRefCount because
+                         * it is returned by lookupKeyByPattern. This results
+                         * in doing nothing at all. */
+                        listAddNodeTail(listPtr,val);
+                    }
+                } else {
+                    redisAssert(sop->type == REDIS_SORT_GET); /* always fails */
+                }
+            }
+        }
+        if (dictReplace(c->db->dict,storekey,listObject)) {
+            incrRefCount(storekey);
+        }
+        /* Note: we add 1 because the DB is dirty anyway since even if the
+         * SORT result is empty a new key is set and maybe the old content
+         * replaced. */
+        server.dirty += 1+outputlen;
+        addReplySds(c,sdscatprintf(sdsempty(),":%d\r\n",outputlen));
+    }
+
+    /* Cleanup */
+    decrRefCount(sortval);
+    listRelease(operations);
+    for (j = 0; j < vectorlen; j++) {
+        if (alpha && vector[j].u.cmpobj)
+            decrRefCount(vector[j].u.cmpobj);
+    }
+    zfree(vector);
+}
+
+/* Convert an amount of bytes into a human readable string in the form
+ * of 100B, 2G, 100M, 4K, and so forth. */
+static void bytesToHuman(char *s, unsigned long long n) {
+    double d;
+
+    if (n < 1024) {
+        /* Bytes */
+        sprintf(s,"%lluB",n);
+        return;
+    } else if (n < (1024*1024)) {
+        d = (double)n/(1024);
+        sprintf(s,"%.2fK",d);
+    } else if (n < (1024LL*1024*1024)) {
+        d = (double)n/(1024*1024);
+        sprintf(s,"%.2fM",d);
+    } else if (n < (1024LL*1024*1024*1024)) {
+        d = (double)n/(1024LL*1024*1024);
+        sprintf(s,"%.2fG",d);
+    }
+}
+
+/* Create the string returned by the INFO command. This is decoupled
+ * by the INFO command itself as we need to report the same information
+ * on memory corruption problems. */
+static sds genRedisInfoString(void) {
+    sds info;
+    time_t uptime = time(NULL)-server.stat_starttime;
+    int j;
+    char hmem[64];
+
+    bytesToHuman(hmem,zmalloc_used_memory());
+    info = sdscatprintf(sdsempty(),
+        "redis_version:%s\r\n"
+        "redis_git_sha1:%s\r\n"
+        "redis_git_dirty:%d\r\n"
+        "arch_bits:%s\r\n"
+        "multiplexing_api:%s\r\n"
+        "process_id:%ld\r\n"
+        "uptime_in_seconds:%ld\r\n"
+        "uptime_in_days:%ld\r\n"
+        "connected_clients:%d\r\n"
+        "connected_slaves:%d\r\n"
+        "blocked_clients:%d\r\n"
+        "used_memory:%zu\r\n"
+        "used_memory_human:%s\r\n"
+		"changes_since_last_save:%lld\r\n"
+		"last_save_time:%ld\r\n"
+        "total_connections_received:%lld\r\n"
+        "total_commands_processed:%lld\r\n"
+        "expired_keys:%lld\r\n"
+        "hash_max_zipmap_entries:%zu\r\n"
+        "hash_max_zipmap_value:%zu\r\n"
+        "pubsub_channels:%ld\r\n"
+        "pubsub_patterns:%u\r\n"
+        "role:%s\r\n"
+        ,REDIS_VERSION,
+        REDIS_GIT_SHA1,
+        strtol(REDIS_GIT_DIRTY,NULL,10) > 0,
+        (sizeof(long) == 8) ? "64" : "32",
+        aeGetApiName(),
+		(long) getpid(),
+        uptime,
+        uptime/(3600*24),
+        listLength(server.clients)-listLength(server.slaves),
+        listLength(server.slaves),
+        server.blpop_blocked_clients,
+        zmalloc_used_memory(),
+        hmem,
+        server.dirty,
+        server.lastsave,
+        server.stat_numconnections,
+        server.stat_numcommands,
+        server.stat_expiredkeys,
+        server.hash_max_zipmap_entries,
+        server.hash_max_zipmap_value,
+        dictSize(server.pubsub_channels),
+        listLength(server.pubsub_patterns),
+        server.masterhost == NULL ? "master" : "slave"
+    );
+    if (server.masterhost) {
+        info = sdscatprintf(info,
+            "master_host:%s\r\n"
+            "master_port:%d\r\n"
+            "master_link_status:%s\r\n"
+            "master_last_io_seconds_ago:%d\r\n"
+            ,server.masterhost,
+            server.masterport,
+            (server.replstate == REDIS_REPL_CONNECTED) ?
+                "up" : "down",
+            server.master ? ((int)(time(NULL)-server.master->lastinteraction)) : -1
+        );
+    }
+    for (j = 0; j < server.dbnum; j++) {
+        long long keys, vkeys;
+
+        keys = dictSize(server.db[j].dict);
+        vkeys = dictSize(server.db[j].expires);
+        if (keys || vkeys) {
+            info = sdscatprintf(info, "db%d:keys=%lld,expires=%lld\r\n",
+                j, keys, vkeys);
+        }
+    }
+    return info;
+}
+
+static void infoCommand(redisClient *c) {
+    sds info = genRedisInfoString();
+    addReplySds(c,sdscatprintf(sdsempty(),"$%lu\r\n",
+        (unsigned long)sdslen(info)));
+    addReplySds(c,info);
+    addReply(c,shared.crlf);
+}
+
+static void monitorCommand(redisClient *c) {
+    /* ignore MONITOR if aleady slave or in monitor mode */
+    if (c->flags & REDIS_SLAVE) return;
+
+    c->flags |= (REDIS_SLAVE|REDIS_MONITOR);
+    c->slaveseldb = 0;
+    listAddNodeTail(server.monitors,c);
+    addReply(c,shared.ok);
+}
+
+/* ================================= Expire ================================= */
+static int removeExpire(redisDb *db, robj *key) {
+    if (dictDelete(db->expires,key) == DICT_OK) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+static int setExpire(redisDb *db, robj *key, time_t when) {
+    if (dictAdd(db->expires,key,(void*)when) == DICT_ERR) {
+        return 0;
+    } else {
+        incrRefCount(key);
+        return 1;
+    }
+}
+
+/* Return the expire time of the specified key, or -1 if no expire
+ * is associated with this key (i.e. the key is non volatile) */
+static time_t getExpire(redisDb *db, robj *key) {
+    dictEntry *de;
+
+    /* No expire? return ASAP */
+    if (dictSize(db->expires) == 0 ||
+       (de = dictFind(db->expires,key)) == NULL) return -1;
+
+    return (time_t) dictGetEntryVal(de);
+}
+
+static int expireIfNeeded(redisDb *db, robj *key) {
+    time_t when;
+    dictEntry *de;
+
+    /* No expire? return ASAP */
+    if (dictSize(db->expires) == 0 ||
+       (de = dictFind(db->expires,key)) == NULL) return 0;
+
+    /* Lookup the expire */
+    when = (time_t) dictGetEntryVal(de);
+    if (time(NULL) <= when) return 0;
+
+    /* Delete the key */
+    dictDelete(db->expires,key);
+    server.stat_expiredkeys++;
+    return dictDelete(db->dict,key) == DICT_OK;
+}
+
+static int deleteIfVolatile(redisDb *db, robj *key) {
+    dictEntry *de;
+
+    /* No expire? return ASAP */
+    if (dictSize(db->expires) == 0 ||
+       (de = dictFind(db->expires,key)) == NULL) return 0;
+
+    /* Delete the key */
+    server.dirty++;
+    server.stat_expiredkeys++;
+    dictDelete(db->expires,key);
+    return dictDelete(db->dict,key) == DICT_OK;
+}
+
+static void expireGenericCommand(redisClient *c, robj *key, robj *param, long offset) {
+    dictEntry *de;
+    time_t seconds;
+
+    if (getLongFromObjectOrReply(c, param, &seconds, NULL) != REDIS_OK) return;
+
+    seconds -= offset;
+
+    de = dictFind(c->db->dict,key);
+    if (de == NULL) {
+        addReply(c,shared.czero);
+        return;
+    }
+    if (seconds <= 0) {
+        if (deleteKey(c->db,key)) server.dirty++;
+        addReply(c, shared.cone);
+        return;
+    } else {
+        time_t when = time(NULL)+seconds;
+        if (setExpire(c->db,key,when)) {
+            addReply(c,shared.cone);
+            server.dirty++;
+        } else {
+            addReply(c,shared.czero);
+        }
+        return;
+    }
+}
+
+static void expireCommand(redisClient *c) {
+    expireGenericCommand(c,c->argv[1],c->argv[2],0);
+}
+
+static void expireatCommand(redisClient *c) {
+    expireGenericCommand(c,c->argv[1],c->argv[2],time(NULL));
+}
+
+static void ttlCommand(redisClient *c) {
+    time_t expire;
+    int ttl = -1;
+
+    expire = getExpire(c->db,c->argv[1]);
+    if (expire != -1) {
+        ttl = (int) (expire-time(NULL));
+        if (ttl < 0) ttl = -1;
+    }
+    addReplySds(c,sdscatprintf(sdsempty(),":%d\r\n",ttl));
+}
+
+/* ================================ MULTI/EXEC ============================== */
+
+/* Client state initialization for MULTI/EXEC */
+static void initClientMultiState(redisClient *c) {
+    c->mstate.commands = NULL;
+    c->mstate.count = 0;
+}
+
+/* Release all the resources associated with MULTI/EXEC state */
+static void freeClientMultiState(redisClient *c) {
+    int j;
+
+    for (j = 0; j < c->mstate.count; j++) {
+        int i;
+        multiCmd *mc = c->mstate.commands+j;
+
+        for (i = 0; i < mc->argc; i++)
+            decrRefCount(mc->argv[i]);
+        zfree(mc->argv);
+    }
+    zfree(c->mstate.commands);
+}
+
+/* Add a new command into the MULTI commands queue */
+static void queueMultiCommand(redisClient *c, struct redisCommand *cmd) {
+    multiCmd *mc;
+    int j;
+
+    c->mstate.commands = zrealloc(c->mstate.commands,
+            sizeof(multiCmd)*(c->mstate.count+1));
+    mc = c->mstate.commands+c->mstate.count;
+    mc->cmd = cmd;
+    mc->argc = c->argc;
+    mc->argv = zmalloc(sizeof(robj*)*c->argc);
+    memcpy(mc->argv,c->argv,sizeof(robj*)*c->argc);
+    for (j = 0; j < c->argc; j++)
+        incrRefCount(mc->argv[j]);
+    c->mstate.count++;
+}
+
+static void multiCommand(redisClient *c) {
+    c->flags |= REDIS_MULTI;
+    addReply(c,shared.ok);
+}
+
+static void discardCommand(redisClient *c) {
+    if (!(c->flags & REDIS_MULTI)) {
+        addReplySds(c,sdsnew("-ERR DISCARD without MULTI\r\n"));
+        return;
+    }
+
+    freeClientMultiState(c);
+    initClientMultiState(c);
+    c->flags &= (~REDIS_MULTI);
+    addReply(c,shared.ok);
+}
+
+/* Send a MULTI command to all the slaves and AOF file. Check the execCommand
+ * implememntation for more information. */
+static void execCommandReplicateMulti(redisClient *c) {
+    struct redisCommand *cmd;
+    robj *multistring = createStringObject("MULTI",5);
+
+    cmd = lookupCommand("multi");
+    if (listLength(server.slaves))
+        replicationFeedSlaves(server.slaves,c->db->id,&multistring,1);
+    decrRefCount(multistring);
+}
+
+static void execCommand(redisClient *c) {
+    int j;
+    robj **orig_argv;
+    int orig_argc;
+
+    if (!(c->flags & REDIS_MULTI)) {
+        addReplySds(c,sdsnew("-ERR EXEC without MULTI\r\n"));
+        return;
+    }
+
+    /* Replicate a MULTI request now that we are sure the block is executed.
+     * This way we'll deliver the MULTI/..../EXEC block as a whole and
+     * both the AOF and the replication link will have the same consistency
+     * and atomicity guarantees. */
+    execCommandReplicateMulti(c);
+
+    /* Exec all the queued commands */
+    orig_argv = c->argv;
+    orig_argc = c->argc;
+    addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",c->mstate.count));
+    for (j = 0; j < c->mstate.count; j++) {
+        c->argc = c->mstate.commands[j].argc;
+        c->argv = c->mstate.commands[j].argv;
+        call(c,c->mstate.commands[j].cmd);
+    }
+    c->argv = orig_argv;
+    c->argc = orig_argc;
+    freeClientMultiState(c);
+    initClientMultiState(c);
+    c->flags &= (~REDIS_MULTI);
+    /* Make sure the EXEC command is always replicated / AOF, since we
+     * always send the MULTI command (we can't know beforehand if the
+     * next operations will contain at least a modification to the DB). */
+    server.dirty++;
+}
+
+/* =========================== Blocking Operations  ========================= */
+
+/* Currently Redis blocking operations support is limited to list POP ops,
+ * so the current implementation is not fully generic, but it is also not
+ * completely specific so it will not require a rewrite to support new
+ * kind of blocking operations in the future.
+ *
+ * Still it's important to note that list blocking operations can be already
+ * used as a notification mechanism in order to implement other blocking
+ * operations at application level, so there must be a very strong evidence
+ * of usefulness and generality before new blocking operations are implemented.
+ *
+ * This is how the current blocking POP works, we use BLPOP as example:
+ * - If the user calls BLPOP and the key exists and contains a non empty list
+ *   then LPOP is called instead. So BLPOP is semantically the same as LPOP
+ *   if there is not to block.
+ * - If instead BLPOP is called and the key does not exists or the list is
+ *   empty we need to block. In order to do so we remove the notification for
+ *   new data to read in the client socket (so that we'll not serve new
+ *   requests if the blocking request is not served). Also we put the client
+ *   in a dictionary (db->blockingkeys) mapping keys to a list of clients
+ *   blocking for this keys.
+ * - If a PUSH operation against a key with blocked clients waiting is
+ *   performed, we serve the first in the list: basically instead to push
+ *   the new element inside the list we return it to the (first / oldest)
+ *   blocking client, unblock the client, and remove it form the list.
+ *
+ * The above comment and the source code should be enough in order to understand
+ * the implementation and modify / fix it later.
+ */
+
+/* Set a client in blocking mode for the specified key, with the specified
+ * timeout */
+static void blockForKeys(redisClient *c, robj **keys, int numkeys, time_t timeout) {
+    dictEntry *de;
+    list *l;
+    int j;
+
+    /* Never block for keys when the AOF is being replayed.
+     *
+     * When a BPOP is issued against an expiring list, the list is expired
+     * by means of the delete-on-write semantic, which causes the BPOP
+     * command to be written to the AOF. Then, the BPOP ends up in a blocking
+     * state and waits for a PUSH on any given key from another client.
+     *
+     * On replay, the expiring list will also be expired (if it isn't already),
+     * and the fake AOF client will block for a push. When multiple BPOPs
+     * (issued by multiple clients) are written to the AOF, this can cause the
+     * same blocking code to be executed against the single fake AOF client,
+     * which in turn can place the client in the list(s) of blocking clients
+     * *multiple times*. This state should be prevented, so simply skip
+     * blocking for the fake AOF client. */
+    if (c->fd < 0) return;
+
+    c->blockingkeys = zmalloc(sizeof(robj*)*numkeys);
+    c->blockingkeysnum = numkeys;
+    c->blockingto = timeout;
+    for (j = 0; j < numkeys; j++) {
+        /* Add the key in the client structure, to map clients -> keys */
+        c->blockingkeys[j] = keys[j];
+        incrRefCount(keys[j]);
+
+        /* And in the other "side", to map keys -> clients */
+        de = dictFind(c->db->blockingkeys,keys[j]);
+        if (de == NULL) {
+            int retval;
+
+            /* For every key we take a list of clients blocked for it */
+            l = listCreate();
+            retval = dictAdd(c->db->blockingkeys,keys[j],l);
+            incrRefCount(keys[j]);
+            assert(retval == DICT_OK);
+        } else {
+            l = dictGetEntryVal(de);
+        }
+        listAddNodeTail(l,c);
+    }
+    /* Mark the client as a blocked client */
+    c->flags |= REDIS_BLOCKED;
+    server.blpop_blocked_clients++;
+}
+
+/* Unblock a client that's waiting in a blocking operation such as BLPOP */
+static void unblockClientWaitingData(redisClient *c) {
+    dictEntry *de;
+    list *l;
+    int j;
+
+    assert(c->blockingkeys != NULL);
+    /* The client may wait for multiple keys, so unblock it for every key. */
+    for (j = 0; j < c->blockingkeysnum; j++) {
+        /* Remove this client from the list of clients waiting for this key. */
+        de = dictFind(c->db->blockingkeys,c->blockingkeys[j]);
+        assert(de != NULL);
+        l = dictGetEntryVal(de);
+        listDelNode(l,listSearchKey(l,c));
+        /* If the list is empty we need to remove it to avoid wasting memory */
+        if (listLength(l) == 0)
+            dictDelete(c->db->blockingkeys,c->blockingkeys[j]);
+        decrRefCount(c->blockingkeys[j]);
+    }
+    /* Cleanup the client structure */
+    zfree(c->blockingkeys);
+    c->blockingkeys = NULL;
+    c->flags &= (~REDIS_BLOCKED);
+    server.blpop_blocked_clients--;
+    /* We want to process data if there is some command waiting
+     * in the input buffer. Note that this is safe even if
+     * unblockClientWaitingData() gets called from freeClient() because
+     * freeClient() will be smart enough to call this function
+     * *after* c->querybuf was set to NULL. */
+    if (c->querybuf && sdslen(c->querybuf) > 0) processInputBuffer(c);
+}
+
+/* This should be called from any function PUSHing into lists.
+ * 'c' is the "pushing client", 'key' is the key it is pushing data against,
+ * 'ele' is the element pushed.
+ *
+ * If the function returns 0 there was no client waiting for a list push
+ * against this key.
+ *
+ * If the function returns 1 there was a client waiting for a list push
+ * against this key, the element was passed to this client thus it's not
+ * needed to actually add it to the list and the caller should return asap. */
+static int handleClientsWaitingListPush(redisClient *c, robj *key, robj *ele) {
+    struct dictEntry *de;
+    redisClient *receiver;
+    list *l;
+    listNode *ln;
+
+    de = dictFind(c->db->blockingkeys,key);
+    if (de == NULL) return 0;
+    l = dictGetEntryVal(de);
+    ln = listFirst(l);
+    assert(ln != NULL);
+    receiver = ln->value;
+
+    addReplySds(receiver,sdsnew("*2\r\n"));
+    addReplyBulk(receiver,key);
+    addReplyBulk(receiver,ele);
+    unblockClientWaitingData(receiver);
+    return 1;
+}
+
+/* Blocking RPOP/LPOP */
+static void blockingPopGenericCommand(redisClient *c, int where) {
+    robj *o;
+    long long lltimeout;
+    time_t timeout;
+    int j;
+
+    /* Make sure timeout is an integer value */
+    if (getLongLongFromObjectOrReply(c,c->argv[c->argc-1],&lltimeout,
+            "timeout is not an integer") != REDIS_OK) return;
+
+    /* Make sure the timeout is not negative */
+    if (lltimeout < 0) {
+        addReplySds(c,sdsnew("-ERR timeout is negative\r\n"));
+        return;
+    }
+
+    for (j = 1; j < c->argc-1; j++) {
+        o = lookupKeyWrite(c->db,c->argv[j]);
+        if (o != NULL) {
+            if (o->type != REDIS_LIST) {
+                addReply(c,shared.wrongtypeerr);
+                return;
+            } else {
+                list *list = o->ptr;
+                if (listLength(list) != 0) {
+                    /* If the list contains elements fall back to the usual
+                     * non-blocking POP operation */
+                    robj *argv[2], **orig_argv;
+                    int orig_argc;
+
+                    /* We need to alter the command arguments before to call
+                     * popGenericCommand() as the command takes a single key. */
+                    orig_argv = c->argv;
+                    orig_argc = c->argc;
+                    argv[1] = c->argv[j];
+                    c->argv = argv;
+                    c->argc = 2;
+
+                    /* Also the return value is different, we need to output
+                     * the multi bulk reply header and the key name. The
+                     * "real" command will add the last element (the value)
+                     * for us. If this souds like an hack to you it's just
+                     * because it is... */
+                    addReplySds(c,sdsnew("*2\r\n"));
+                    addReplyBulk(c,argv[1]);
+                    popGenericCommand(c,where);
+
+                    /* Fix the client structure with the original stuff */
+                    c->argv = orig_argv;
+                    c->argc = orig_argc;
+                    return;
+                }
+            }
+        }
+    }
+
+    /* If we are inside a MULTI/EXEC and the list is empty the only thing
+     * we can do is treating it as a timeout (even with timeout 0). */
+    if (c->flags & REDIS_MULTI) {
+        addReply(c,shared.nullmultibulk);
+        return;
+    }
+
+    /* If the list is empty or the key does not exists we must block */
+    timeout = lltimeout;
+    if (timeout > 0) timeout += time(NULL);
+    blockForKeys(c,c->argv+1,c->argc-2,timeout);
+}
+
+static void blpopCommand(redisClient *c) {
+    blockingPopGenericCommand(c,REDIS_HEAD);
+}
+
+static void brpopCommand(redisClient *c) {
+    blockingPopGenericCommand(c,REDIS_TAIL);
+}
+
+/* =============================== Replication  ============================= */
+
+static int syncWrite(int fd, char *ptr, ssize_t size, int timeout) {
+    ssize_t nwritten, ret = size;
+    time_t start = time(NULL);
+
+    timeout++;
+    while(size) {
+        if (aeWait(fd,AE_WRITABLE,1000) & AE_WRITABLE) {
+            nwritten = write(fd,ptr,size);
+            if (nwritten == -1) return -1;
+            ptr += nwritten;
+            size -= nwritten;
+        }
+        if ((time(NULL)-start) > timeout) {
+            errno = ETIMEDOUT;
+            return -1;
+        }
+    }
+    return ret;
+}
+
+static int syncRead(int fd, char *ptr, ssize_t size, int timeout) {
+    ssize_t nread, totread = 0;
+    time_t start = time(NULL);
+
+    timeout++;
+    while(size) {
+        if (aeWait(fd,AE_READABLE,1000) & AE_READABLE) {
+            nread = read(fd,ptr,size);
+            if (nread <= 0) return -1;
+            ptr += nread;
+            size -= nread;
+            totread += nread;
+        }
+        if ((time(NULL)-start) > timeout) {
+            errno = ETIMEDOUT;
+            return -1;
+        }
+    }
+    return totread;
+}
+
+static int syncReadLine(int fd, char *ptr, ssize_t size, int timeout) {
+    ssize_t nread = 0;
+
+    size--;
+    while(size) {
+        char c;
+
+        if (syncRead(fd,&c,1,timeout) == -1) return -1;
+        if (c == '\n') {
+            *ptr = '\0';
+            if (nread && *(ptr-1) == '\r') *(ptr-1) = '\0';
+            return nread;
+        } else {
+            *ptr++ = c;
+            *ptr = '\0';
+            nread++;
+        }
+    }
+    return nread;
+}
+
+static void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
+    redisClient *slave = privdata;
+    REDIS_NOTUSED(el);
+    REDIS_NOTUSED(mask);
+    char buf[REDIS_IOBUF_LEN];
+    ssize_t nwritten, buflen;
+
+    if (slave->repldboff == 0) {
+        /* Write the bulk write count before to transfer the DB. In theory here
+         * we don't know how much room there is in the output buffer of the
+         * socket, but in pratice SO_SNDLOWAT (the minimum count for output
+         * operations) will never be smaller than the few bytes we need. */
+        sds bulkcount;
+
+        bulkcount = sdscatprintf(sdsempty(),"$%lld\r\n",(unsigned long long)
+            slave->repldbsize);
+        if (write(fd,bulkcount,sdslen(bulkcount)) != (signed)sdslen(bulkcount))
+        {
+            sdsfree(bulkcount);
+            freeClient(slave);
+            return;
+        }
+        sdsfree(bulkcount);
+    }
+    lseek(slave->repldbfd,slave->repldboff,SEEK_SET);
+    buflen = read(slave->repldbfd,buf,REDIS_IOBUF_LEN);
+    if (buflen <= 0) {
+        redisLog(REDIS_WARNING,"Read error sending DB to slave: %s",
+            (buflen == 0) ? "premature EOF" : strerror(errno));
+        freeClient(slave);
+        return;
+    }
+    if ((nwritten = write(fd,buf,buflen)) == -1) {
+        redisLog(REDIS_VERBOSE,"Write error sending DB to slave: %s",
+            strerror(errno));
+        freeClient(slave);
+        return;
+    }
+    slave->repldboff += nwritten;
+    if (slave->repldboff == slave->repldbsize) {
+        close(slave->repldbfd);
+        slave->repldbfd = -1;
+        aeDeleteFileEvent(server.el,slave->fd,AE_WRITABLE);
+        slave->replstate = REDIS_REPL_ONLINE;
+        if (aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE,
+            sendReplyToClient, slave) == AE_ERR) {
+            freeClient(slave);
+            return;
+        }
+        addReplySds(slave,sdsempty());
+        redisLog(REDIS_NOTICE,"Synchronization with slave succeeded");
+    }
+}
+
+static void slaveofCommand(redisClient *c) {
+    if (!strcasecmp(c->argv[1]->ptr,"no") &&
+        !strcasecmp(c->argv[2]->ptr,"one")) {
+        if (server.masterhost) {
+            sdsfree(server.masterhost);
+            server.masterhost = NULL;
+            if (server.master) freeClient(server.master);
+            server.replstate = REDIS_REPL_NONE;
+            redisLog(REDIS_NOTICE,"MASTER MODE enabled (user request)");
+        }
+    } else {
+        sdsfree(server.masterhost);
+        server.masterhost = sdsdup(c->argv[1]->ptr);
+        server.masterport = atoi(c->argv[2]->ptr);
+        if (server.master) freeClient(server.master);
+        server.replstate = REDIS_REPL_CONNECT;
+        redisLog(REDIS_NOTICE,"SLAVE OF %s:%d enabled (user request)",
+            server.masterhost, server.masterport);
+    }
+    addReply(c,shared.ok);
+}
+
+/* ============================ Maxmemory directive  ======================== */
+
+/* Try to free one object form the pre-allocated objects free list.
+ * This is useful under low mem conditions as by default we take 1 million
+ * free objects allocated. On success REDIS_OK is returned, otherwise
+ * REDIS_ERR. */
+static int tryFreeOneObjectFromFreelist(void) {
+    robj *o;
+
+    if (listLength(server.objfreelist)) {
+        listNode *head = listFirst(server.objfreelist);
+        o = listNodeValue(head);
+        listDelNode(server.objfreelist,head);
+        zfree(o);
+        return REDIS_OK;
+    } else {
+        return REDIS_ERR;
+    }
+}
+
+/* This function gets called when 'maxmemory' is set on the config file to limit
+ * the max memory used by the server, and we are out of memory.
+ * This function will try to, in order:
+ *
+ * - Free objects from the free list
+ * - Try to remove keys with an EXPIRE set
+ *
+ * It is not possible to free enough memory to reach used-memory < maxmemory
+ * the server will start refusing commands that will enlarge even more the
+ * memory usage.
+ */
+static void freeMemoryIfNeeded(void) {
+    while (server.maxmemory && zmalloc_used_memory() > server.maxmemory) {
+        int j, k, freed = 0;
+
+        if (tryFreeOneObjectFromFreelist() == REDIS_OK) continue;
+        for (j = 0; j < server.dbnum; j++) {
+            int minttl = -1;
+            robj *minkey = NULL;
+            struct dictEntry *de;
+
+            if (dictSize(server.db[j].expires)) {
+                freed = 1;
+                /* From a sample of three keys drop the one nearest to
+                 * the natural expire */
+                for (k = 0; k < 3; k++) {
+                    time_t t;
+
+                    de = dictGetRandomKey(server.db[j].expires);
+                    t = (time_t) dictGetEntryVal(de);
+                    if (minttl == -1 || t < minttl) {
+                        minkey = dictGetEntryKey(de);
+                        minttl = t;
+                    }
+                }
+                deleteKey(server.db+j,minkey);
+                server.stat_expiredkeys++;
+            }
+        }
+        if (!freed) return; /* nothing to free... */
+    }
+}
+
+/* ============================== Append Only file ========================== */
+
+/* =================== Virtual Memory - Blocking Side  ====================== */
+
+/* =================== Virtual Memory - Threaded I/O  ======================= */
+/* ============ Virtual Memory - Blocking clients on missing keys =========== */
+/* =========================== Remote Configuration ========================= */
+
+static void configSetCommand(redisClient *c) {
+    robj *o = getDecodedObject(c->argv[3]);
+    long long ll;
+
+    if (!strcasecmp(c->argv[2]->ptr,"dbfilename")) {
+        zfree(server.dbfilename);
+        server.dbfilename = zstrdup(o->ptr);
+    } else if (!strcasecmp(c->argv[2]->ptr,"requirepass")) {
+        zfree(server.requirepass);
+        server.requirepass = zstrdup(o->ptr);
+    } else if (!strcasecmp(c->argv[2]->ptr,"masterauth")) {
+        zfree(server.masterauth);
+        server.masterauth = zstrdup(o->ptr);
+    } else if (!strcasecmp(c->argv[2]->ptr,"maxmemory")) {
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
+            ll < 0) goto badfmt;
+        server.maxmemory = ll;
+    } else if (!strcasecmp(c->argv[2]->ptr,"timeout")) {
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
+            ll < 0 || ll > LONG_MAX) goto badfmt;
+        server.maxidletime = ll;
+    } else {
+        addReplySds(c,sdscatprintf(sdsempty(),
+            "-ERR not supported CONFIG parameter %s\r\n",
+            (char*)c->argv[2]->ptr));
+        decrRefCount(o);
+        return;
+    }
+    decrRefCount(o);
+    addReply(c,shared.ok);
+    return;
+
+badfmt: /* Bad format errors */
+    addReplySds(c,sdscatprintf(sdsempty(),
+        "-ERR invalid argument '%s' for CONFIG SET '%s'\r\n",
+            (char*)o->ptr,
+            (char*)c->argv[2]->ptr));
+    decrRefCount(o);
+}
+
+static void configGetCommand(redisClient *c) {
+    robj *o = getDecodedObject(c->argv[2]);
+    robj *lenobj = createObject(REDIS_STRING,NULL);
+    char *pattern = o->ptr;
+    int matches = 0;
+
+    addReply(c,lenobj);
+    decrRefCount(lenobj);
+
+    if (stringmatch(pattern,"dbfilename",0)) {
+        addReplyBulkCString(c,"dbfilename");
+        addReplyBulkCString(c,server.dbfilename);
+        matches++;
+    }
+    if (stringmatch(pattern,"requirepass",0)) {
+        addReplyBulkCString(c,"requirepass");
+        addReplyBulkCString(c,server.requirepass);
+        matches++;
+    }
+    if (stringmatch(pattern,"masterauth",0)) {
+        addReplyBulkCString(c,"masterauth");
+        addReplyBulkCString(c,server.masterauth);
+        matches++;
+    }
+    if (stringmatch(pattern,"maxmemory",0)) {
+        char buf[128];
+
+        ll2string(buf,128,server.maxmemory);
+        addReplyBulkCString(c,"maxmemory");
+        addReplyBulkCString(c,buf);
+        matches++;
+    }
+    if (stringmatch(pattern,"timeout",0)) {
+        char buf[128];
+
+        ll2string(buf,128,server.maxidletime);
+        addReplyBulkCString(c,"timeout");
+        addReplyBulkCString(c,buf);
+        matches++;
+    }
+    decrRefCount(o);
+    lenobj->ptr = sdscatprintf(sdsempty(),"*%d\r\n",matches*2);
+}
+
+static void configCommand(redisClient *c) {
+    if (!strcasecmp(c->argv[1]->ptr,"set")) {
+        if (c->argc != 4) goto badarity;
+        configSetCommand(c);
+    } else if (!strcasecmp(c->argv[1]->ptr,"get")) {
+        if (c->argc != 3) goto badarity;
+        configGetCommand(c);
+    } else if (!strcasecmp(c->argv[1]->ptr,"resetstat")) {
+        if (c->argc != 2) goto badarity;
+        server.stat_numcommands = 0;
+        server.stat_numconnections = 0;
+        server.stat_expiredkeys = 0;
+        server.stat_starttime = time(NULL);
+        addReply(c,shared.ok);
+    } else {
+        addReplySds(c,sdscatprintf(sdsempty(),
+            "-ERR CONFIG subcommand must be one of GET, SET, RESETSTAT\r\n"));
+    }
+    return;
+
+badarity:
+    addReplySds(c,sdscatprintf(sdsempty(),
+        "-ERR Wrong number of arguments for CONFIG %s\r\n",
+        (char*) c->argv[1]->ptr));
+}
+
+/* =========================== Pubsub implementation ======================== */
+
+static void freePubsubPattern(void *p) {
+    pubsubPattern *pat = p;
+
+    decrRefCount(pat->pattern);
+    zfree(pat);
+}
+
+static int listMatchPubsubPattern(void *a, void *b) {
+    pubsubPattern *pa = a, *pb = b;
+
+    return (pa->client == pb->client) &&
+           (equalStringObjects(pa->pattern,pb->pattern));
+}
+
+/* Subscribe a client to a channel. Returns 1 if the operation succeeded, or
+ * 0 if the client was already subscribed to that channel. */
+static int pubsubSubscribeChannel(redisClient *c, robj *channel) {
+    struct dictEntry *de;
+    list *clients = NULL;
+    int retval = 0;
+
+    /* Add the channel to the client -> channels hash table */
+    if (dictAdd(c->pubsub_channels,channel,NULL) == DICT_OK) {
+        retval = 1;
+        incrRefCount(channel);
+        /* Add the client to the channel -> list of clients hash table */
+        de = dictFind(server.pubsub_channels,channel);
+        if (de == NULL) {
+            clients = listCreate();
+            dictAdd(server.pubsub_channels,channel,clients);
+            incrRefCount(channel);
+        } else {
+            clients = dictGetEntryVal(de);
+        }
+        listAddNodeTail(clients,c);
+    }
+    /* Notify the client */
+    addReply(c,shared.mbulk3);
+    addReply(c,shared.subscribebulk);
+    addReplyBulk(c,channel);
+    addReplyLongLong(c,dictSize(c->pubsub_channels)+listLength(c->pubsub_patterns));
+    return retval;
+}
+
+/* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
+ * 0 if the client was not subscribed to the specified channel. */
+static int pubsubUnsubscribeChannel(redisClient *c, robj *channel, int notify) {
+    struct dictEntry *de;
+    list *clients;
+    listNode *ln;
+    int retval = 0;
+
+    /* Remove the channel from the client -> channels hash table */
+    incrRefCount(channel); /* channel may be just a pointer to the same object
+                            we have in the hash tables. Protect it... */
+    if (dictDelete(c->pubsub_channels,channel) == DICT_OK) {
+        retval = 1;
+        /* Remove the client from the channel -> clients list hash table */
+        de = dictFind(server.pubsub_channels,channel);
+        assert(de != NULL);
+        clients = dictGetEntryVal(de);
+        ln = listSearchKey(clients,c);
+        assert(ln != NULL);
+        listDelNode(clients,ln);
+        if (listLength(clients) == 0) {
+            /* Free the list and associated hash entry at all if this was
+             * the latest client, so that it will be possible to abuse
+             * Redis PUBSUB creating millions of channels. */
+            dictDelete(server.pubsub_channels,channel);
+        }
+    }
+    /* Notify the client */
+    if (notify) {
+        addReply(c,shared.mbulk3);
+        addReply(c,shared.unsubscribebulk);
+        addReplyBulk(c,channel);
+        addReplyLongLong(c,dictSize(c->pubsub_channels)+
+                       listLength(c->pubsub_patterns));
+
+    }
+    decrRefCount(channel); /* it is finally safe to release it */
+    return retval;
+}
+
+/* Subscribe a client to a pattern. Returns 1 if the operation succeeded, or 0 if the clinet was already subscribed to that pattern. */
+static int pubsubSubscribePattern(redisClient *c, robj *pattern) {
+    int retval = 0;
+
+    if (listSearchKey(c->pubsub_patterns,pattern) == NULL) {
+        retval = 1;
+        pubsubPattern *pat;
+        listAddNodeTail(c->pubsub_patterns,pattern);
+        incrRefCount(pattern);
+        pat = zmalloc(sizeof(*pat));
+        pat->pattern = getDecodedObject(pattern);
+        pat->client = c;
+        listAddNodeTail(server.pubsub_patterns,pat);
+    }
+    /* Notify the client */
+    addReply(c,shared.mbulk3);
+    addReply(c,shared.psubscribebulk);
+    addReplyBulk(c,pattern);
+    addReplyLongLong(c,dictSize(c->pubsub_channels)+listLength(c->pubsub_patterns));
+    return retval;
+}
+
+/* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
+ * 0 if the client was not subscribed to the specified channel. */
+static int pubsubUnsubscribePattern(redisClient *c, robj *pattern, int notify) {
+    listNode *ln;
+    pubsubPattern pat;
+    int retval = 0;
+
+    incrRefCount(pattern); /* Protect the object. May be the same we remove */
+    if ((ln = listSearchKey(c->pubsub_patterns,pattern)) != NULL) {
+        retval = 1;
+        listDelNode(c->pubsub_patterns,ln);
+        pat.client = c;
+        pat.pattern = pattern;
+        ln = listSearchKey(server.pubsub_patterns,&pat);
+        listDelNode(server.pubsub_patterns,ln);
+    }
+    /* Notify the client */
+    if (notify) {
+        addReply(c,shared.mbulk3);
+        addReply(c,shared.punsubscribebulk);
+        addReplyBulk(c,pattern);
+        addReplyLongLong(c,dictSize(c->pubsub_channels)+
+                       listLength(c->pubsub_patterns));
+    }
+    decrRefCount(pattern);
+    return retval;
+}
+
+/* Unsubscribe from all the channels. Return the number of channels the
+ * client was subscribed from. */
+static int pubsubUnsubscribeAllChannels(redisClient *c, int notify) {
+    dictIterator *di = dictGetIterator(c->pubsub_channels);
+    dictEntry *de;
+    int count = 0;
+
+    while((de = dictNext(di)) != NULL) {
+        robj *channel = dictGetEntryKey(de);
+
+        count += pubsubUnsubscribeChannel(c,channel,notify);
+    }
+    dictReleaseIterator(di);
+    return count;
+}
+
+/* Unsubscribe from all the patterns. Return the number of patterns the
+ * client was subscribed from. */
+static int pubsubUnsubscribeAllPatterns(redisClient *c, int notify) {
+    listNode *ln;
+    listIter li;
+    int count = 0;
+
+    listRewind(c->pubsub_patterns,&li);
+    while ((ln = listNext(&li)) != NULL) {
+        robj *pattern = ln->value;
+
+        count += pubsubUnsubscribePattern(c,pattern,notify);
+    }
+    return count;
+}
+
+/* Publish a message */
+static int pubsubPublishMessage(robj *channel, robj *message) {
+    int receivers = 0;
+    struct dictEntry *de;
+    listNode *ln;
+    listIter li;
+
+    /* Send to clients listening for that channel */
+    de = dictFind(server.pubsub_channels,channel);
+    if (de) {
+        list *list = dictGetEntryVal(de);
+        listNode *ln;
+        listIter li;
+
+        listRewind(list,&li);
+        while ((ln = listNext(&li)) != NULL) {
+            redisClient *c = ln->value;
+
+            addReply(c,shared.mbulk3);
+            addReply(c,shared.messagebulk);
+            addReplyBulk(c,channel);
+            addReplyBulk(c,message);
+            receivers++;
+        }
+    }
+    /* Send to clients listening to matching channels */
+    if (listLength(server.pubsub_patterns)) {
+        listRewind(server.pubsub_patterns,&li);
+        channel = getDecodedObject(channel);
+        while ((ln = listNext(&li)) != NULL) {
+            pubsubPattern *pat = ln->value;
+
+            if (stringmatchlen((char*)pat->pattern->ptr,
+                                sdslen(pat->pattern->ptr),
+                                (char*)channel->ptr,
+                                sdslen(channel->ptr),0)) {
+                addReply(pat->client,shared.mbulk4);
+                addReply(pat->client,shared.pmessagebulk);
+                addReplyBulk(pat->client,pat->pattern);
+                addReplyBulk(pat->client,channel);
+                addReplyBulk(pat->client,message);
+                receivers++;
+            }
+        }
+        decrRefCount(channel);
+    }
+    return receivers;
+}
+
+static void subscribeCommand(redisClient *c) {
+    int j;
+
+    for (j = 1; j < c->argc; j++)
+        pubsubSubscribeChannel(c,c->argv[j]);
+}
+
+static void unsubscribeCommand(redisClient *c) {
+    if (c->argc == 1) {
+        pubsubUnsubscribeAllChannels(c,1);
+        return;
+    } else {
+        int j;
+
+        for (j = 1; j < c->argc; j++)
+            pubsubUnsubscribeChannel(c,c->argv[j],1);
+    }
+}
+
+static void psubscribeCommand(redisClient *c) {
+    int j;
+
+    for (j = 1; j < c->argc; j++)
+        pubsubSubscribePattern(c,c->argv[j]);
+}
+
+static void punsubscribeCommand(redisClient *c) {
+    if (c->argc == 1) {
+        pubsubUnsubscribeAllPatterns(c,1);
+        return;
+    } else {
+        int j;
+
+        for (j = 1; j < c->argc; j++)
+            pubsubUnsubscribePattern(c,c->argv[j],1);
+    }
+}
+
+static void publishCommand(redisClient *c) {
+    int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);
+    addReplyLongLong(c,receivers);
+}
+
+/* ================================= Debugging ============================== */
+
+/* Compute the sha1 of string at 's' with 'len' bytes long.
+ * The SHA1 is then xored againt the string pointed by digest.
+ * Since xor is commutative, this operation is used in order to
+ * "add" digests relative to unordered elements.
+ *
+ * So digest(a,b,c,d) will be the same of digest(b,a,c,d) */
+static void xorDigest(unsigned char *digest, void *ptr, size_t len) {
+    SHA1_CTX ctx;
+    unsigned char hash[20], *s = ptr;
+    int j;
+
+    SHA1Init(&ctx);
+    SHA1Update(&ctx,s,len);
+    SHA1Final(hash,&ctx);
+
+    for (j = 0; j < 20; j++)
+        digest[j] ^= hash[j];
+}
+
+static void xorObjectDigest(unsigned char *digest, robj *o) {
+    o = getDecodedObject(o);
+    xorDigest(digest,o->ptr,sdslen(o->ptr));
+    decrRefCount(o);
+}
+
+/* This function instead of just computing the SHA1 and xoring it
+ * against diget, also perform the digest of "digest" itself and
+ * replace the old value with the new one.
+ *
+ * So the final digest will be:
+ *
+ * digest = SHA1(digest xor SHA1(data))
+ *
+ * This function is used every time we want to preserve the order so
+ * that digest(a,b,c,d) will be different than digest(b,c,d,a)
+ *
+ * Also note that mixdigest("foo") followed by mixdigest("bar")
+ * will lead to a different digest compared to "fo", "obar".
+ */
+static void mixDigest(unsigned char *digest, void *ptr, size_t len) {
+    SHA1_CTX ctx;
+    char *s = ptr;
+
+    xorDigest(digest,s,len);
+    SHA1Init(&ctx);
+    SHA1Update(&ctx,digest,20);
+    SHA1Final(digest,&ctx);
+}
+
+static void mixObjectDigest(unsigned char *digest, robj *o) {
+    o = getDecodedObject(o);
+    mixDigest(digest,o->ptr,sdslen(o->ptr));
+    decrRefCount(o);
+}
+
+/* Compute the dataset digest. Since keys, sets elements, hashes elements
+ * are not ordered, we use a trick: every aggregate digest is the xor
+ * of the digests of their elements. This way the order will not change
+ * the result. For list instead we use a feedback entering the output digest
+ * as input in order to ensure that a different ordered list will result in
+ * a different digest. */
+static void computeDatasetDigest(unsigned char *final) {
+    unsigned char digest[20];
+    char buf[128];
+    dictIterator *di = NULL;
+    dictEntry *de;
+    int j;
+    uint32_t aux;
+
+    memset(final,0,20); /* Start with a clean result */
+
+    for (j = 0; j < server.dbnum; j++) {
+        redisDb *db = server.db+j;
+
+        if (dictSize(db->dict) == 0) continue;
+        di = dictGetIterator(db->dict);
+
+        /* hash the DB id, so the same dataset moved in a different
+         * DB will lead to a different digest */
+        aux = htonl(j);
+        mixDigest(final,&aux,sizeof(aux));
+
+        /* Iterate this DB writing every entry */
+        while((de = dictNext(di)) != NULL) {
+            robj *key, *o, *kcopy;
+            time_t expiretime;
+
+            memset(digest,0,20); /* This key-val digest */
+            key = dictGetEntryKey(de);
+
+            
+            mixObjectDigest(digest,key);
+            o = dictGetEntryVal(de);
+            aux = htonl(o->type);
+            mixDigest(digest,&aux,sizeof(aux));
+            expiretime = getExpire(db,key);
+
+            /* Save the key and associated value */
+            if (o->type == REDIS_STRING) {
+                mixObjectDigest(digest,o);
+            } else if (o->type == REDIS_LIST) {
+                list *list = o->ptr;
+                listNode *ln;
+                listIter li;
+
+                listRewind(list,&li);
+                while((ln = listNext(&li))) {
+                    robj *eleobj = listNodeValue(ln);
+
+                    mixObjectDigest(digest,eleobj);
+                }
+            } else if (o->type == REDIS_SET) {
+                dict *set = o->ptr;
+                dictIterator *di = dictGetIterator(set);
+                dictEntry *de;
+
+                while((de = dictNext(di)) != NULL) {
+                    robj *eleobj = dictGetEntryKey(de);
+
+                    xorObjectDigest(digest,eleobj);
+                }
+                dictReleaseIterator(di);
+            } else if (o->type == REDIS_ZSET) {
+                zset *zs = o->ptr;
+                dictIterator *di = dictGetIterator(zs->dict);
+                dictEntry *de;
+
+                while((de = dictNext(di)) != NULL) {
+                    robj *eleobj = dictGetEntryKey(de);
+                    double *score = dictGetEntryVal(de);
+                    unsigned char eledigest[20];
+
+                    snprintf(buf,sizeof(buf),"%.17g",*score);
+                    memset(eledigest,0,20);
+                    mixObjectDigest(eledigest,eleobj);
+                    mixDigest(eledigest,buf,strlen(buf));
+                    xorDigest(digest,eledigest,20);
+                }
+                dictReleaseIterator(di);
+            } else if (o->type == REDIS_HASH) {
+                hashIterator *hi;
+                robj *obj;
+
+                hi = hashInitIterator(o);
+                while (hashNext(hi) != REDIS_ERR) {
+                    unsigned char eledigest[20];
+
+                    memset(eledigest,0,20);
+                    obj = hashCurrent(hi,REDIS_HASH_KEY);
+                    mixObjectDigest(eledigest,obj);
+                    decrRefCount(obj);
+                    obj = hashCurrent(hi,REDIS_HASH_VALUE);
+                    mixObjectDigest(eledigest,obj);
+                    decrRefCount(obj);
+                    xorDigest(digest,eledigest,20);
+                }
+                hashReleaseIterator(hi);
+            } else {
+                redisPanic("Unknown object type");
+            }
+            /* If the key has an expire, add it to the mix */
+            if (expiretime != -1) xorDigest(digest,"!!expire!!",10);
+            /* We can finally xor the key-val digest to the final digest */
+            xorDigest(final,digest,20);
+        }
+        dictReleaseIterator(di);
+    }
+}
+
+
+static void _redisAssert(char *estr, char *file, int line) {
+    redisLog(REDIS_WARNING,"=== ASSERTION FAILED ===");
+    redisLog(REDIS_WARNING,"==> %s:%d '%s' is not true",file,line,estr);
+#ifdef HAVE_BACKTRACE
+    redisLog(REDIS_WARNING,"(forcing SIGSEGV in order to print the stack trace)");
+    *((char*)-1) = 'x';
+#endif
+}
+
+static void _redisPanic(char *msg, char *file, int line) {
+    redisLog(REDIS_WARNING,"!!! Software Failure. Press left mouse button to continue");
+    redisLog(REDIS_WARNING,"Guru Meditation: %s #%s:%d",msg,file,line);
+#ifdef HAVE_BACKTRACE
+    redisLog(REDIS_WARNING,"(forcing SIGSEGV in order to print the stack trace)");
+    *((char*)-1) = 'x';
+#endif
+}
+
+/* =================================== Main! ================================ */
+
+#ifdef __linux__
+int linuxOvercommitMemoryValue(void) {
+    FILE *fp = fopen("/proc/sys/vm/overcommit_memory","r");
+    char buf[64];
+
+    if (!fp) return -1;
+    if (fgets(buf,64,fp) == NULL) {
+        fclose(fp);
+        return -1;
+    }
+    fclose(fp);
+
+    return atoi(buf);
+}
+
+void linuxOvercommitMemoryWarning(void) {
+    if (linuxOvercommitMemoryValue() == 0) {
+        redisLog(REDIS_WARNING,"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.");
+    }
+}
+#endif /* __linux__ */
+
+static void version() {
+    printf("Redis server version %s\n", REDIS_VERSION);
+    exit(0);
+}
+
+static void usage() {
+    fprintf(stderr,"Usage: ./redis-server [/path/to/redis.conf]\n");
+    fprintf(stderr,"       ./redis-server - (read config from stdin)\n");
+    exit(1);
+}
+
+int main(int argc, char **argv) {
+    sleep(1);
+    time_t start;
+
+    initServerConfig();
+    if (argc == 2) {
+        if (strcmp(argv[1], "-v") == 0 ||
+            strcmp(argv[1], "--version") == 0) version();
+        if (strcmp(argv[1], "--help") == 0) usage();
+        loadServerConfig(argv[1]);
+    } else if ((argc > 2)) {
+        usage();
+    } else {
+        redisLog(REDIS_WARNING,"Warning: no config file specified, using the default config. In order to specify a config file use 'redis-server /path/to/redis.conf'");
+    }
+    initServer();
+    redisLog(REDIS_NOTICE,"Server started, Redis version " REDIS_VERSION);
+#ifdef __linux__
+    linuxOvercommitMemoryWarning();
+#endif
+    redisLog(REDIS_NOTICE,"The server is now ready to accept connections on port %d", server.port);
+    aeSetBeforeSleepProc(server.el,beforeSleep);
+    aeMain(server.el);
+    aeDeleteEventLoop(server.el);
+    return 0;
+}
+
+/* ============================= Backtrace support ========================= */
+
+#ifdef HAVE_BACKTRACE
+static char *findFuncName(void *pointer, unsigned long *offset);
+
+static void *getMcontextEip(ucontext_t *uc) {
+#if defined(__FreeBSD__)
+    return (void*) uc->uc_mcontext.mc_eip;
+#elif defined(__dietlibc__)
+    return (void*) uc->uc_mcontext.eip;
+#elif defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_6)
+  #if __x86_64__
+    return (void*) uc->uc_mcontext->__ss.__rip;
+  #else
+    return (void*) uc->uc_mcontext->__ss.__eip;
+  #endif
+#elif defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)
+  #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)
+    return (void*) uc->uc_mcontext->__ss.__rip;
+  #else
+    return (void*) uc->uc_mcontext->__ss.__eip;
+  #endif
+#elif defined(__i386__) || defined(__X86_64__) || defined(__x86_64__)
+    return (void*) uc->uc_mcontext.gregs[REG_EIP]; /* Linux 32/64 bit */
+#elif defined(__ia64__) /* Linux IA64 */
+    return (void*) uc->uc_mcontext.sc_ip;
+#else
+    return NULL;
+#endif
+}
+
+static void segvHandler(int sig, siginfo_t *info, void *secret) {
+    void *trace[100];
+    char **messages = NULL;
+    int i, trace_size = 0;
+    unsigned long offset=0;
+    ucontext_t *uc = (ucontext_t*) secret;
+    sds infostring;
+    REDIS_NOTUSED(info);
+
+    redisLog(REDIS_WARNING,
+        "======= Ooops! Redis %s got signal: -%d- =======", REDIS_VERSION, sig);
+    infostring = genRedisInfoString();
+    redisLog(REDIS_WARNING, "%s",infostring);
+    /* It's not safe to sdsfree() the returned string under memory
+     * corruption conditions. Let it leak as we are going to abort */
+
+    trace_size = backtrace(trace, 100);
+    /* overwrite sigaction with caller's address */
+    if (getMcontextEip(uc) != NULL) {
+        trace[1] = getMcontextEip(uc);
+    }
+    messages = backtrace_symbols(trace, trace_size);
+
+    for (i=1; i<trace_size; ++i) {
+        char *fn = findFuncName(trace[i], &offset), *p;
+
+        p = strchr(messages[i],'+');
+        if (!fn || (p && ((unsigned long)strtol(p+1,NULL,10)) < offset)) {
+            redisLog(REDIS_WARNING,"%s", messages[i]);
+        } else {
+            redisLog(REDIS_WARNING,"%d redis-server %p %s + %d", i, trace[i], fn, (unsigned int)offset);
+        }
+    }
+    /* free(messages); Don't call free() with possibly corrupted memory. */
+    _exit(0);
+}
+
+static void sigtermHandler(int sig) {
+    REDIS_NOTUSED(sig);
+
+    redisLog(REDIS_WARNING,"SIGTERM received, scheduling shutting down...");
+    server.shutdown_asap = 1;
+}
+
+static void setupSigSegvAction(void) {
+    struct sigaction act;
+
+    sigemptyset (&act.sa_mask);
+    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
+     * is used. Otherwise, sa_handler is used */
+    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
+    act.sa_sigaction = segvHandler;
+    sigaction (SIGSEGV, &act, NULL);
+    sigaction (SIGBUS, &act, NULL);
+    sigaction (SIGFPE, &act, NULL);
+    sigaction (SIGILL, &act, NULL);
+    sigaction (SIGBUS, &act, NULL);
+
+    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
+    act.sa_handler = sigtermHandler;
+    sigaction (SIGTERM, &act, NULL);
+    return;
+}
+
+#include "staticsymbols.h"
+/* This function try to convert a pointer into a function name. It's used in
+ * oreder to provide a backtrace under segmentation fault that's able to
+ * display functions declared as static (otherwise the backtrace is useless). */
+static char *findFuncName(void *pointer, unsigned long *offset){
+    int i, ret = -1;
+    unsigned long off, minoff = 0;
+
+    /* Try to match against the Symbol with the smallest offset */
+    for (i=0; symsTable[i].pointer; i++) {
+        unsigned long lp = (unsigned long) pointer;
+
+        if (lp != (unsigned long)-1 && lp >= symsTable[i].pointer) {
+            off=lp-symsTable[i].pointer;
+            if (ret < 0 || off < minoff) {
+                minoff=off;
+                ret=i;
+            }
+        }
+    }
+    if (ret == -1) return NULL;
+    *offset = minoff;
+    return symsTable[ret].name;
+}
+#else /* HAVE_BACKTRACE */
+static void setupSigSegvAction(void) {
+}
+#endif /* HAVE_BACKTRACE */
+
+/* The End */
+
+
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/redis.h xen-4.2.1-merge/stubdom/c_httpd_redis/redis.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/redis.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/redis.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __REDIS_H__
+#define __REDIS_H__
+
+enum
+{
+  REG_GS = 0,
+# define REG_GS		REG_GS
+  REG_FS,
+# define REG_FS		REG_FS
+  REG_ES,
+# define REG_ES		REG_ES
+  REG_DS,
+# define REG_DS		REG_DS
+  REG_EDI,
+# define REG_EDI	REG_EDI
+  REG_ESI,
+# define REG_ESI	REG_ESI
+  REG_EBP,
+# define REG_EBP	REG_EBP
+  REG_ESP,
+# define REG_ESP	REG_ESP
+  REG_EBX,
+# define REG_EBX	REG_EBX
+  REG_EDX,
+# define REG_EDX	REG_EDX
+  REG_ECX,
+# define REG_ECX	REG_ECX
+  REG_EAX,
+# define REG_EAX	REG_EAX
+  REG_TRAPNO,
+# define REG_TRAPNO	REG_TRAPNO
+  REG_ERR,
+# define REG_ERR	REG_ERR
+  REG_EIP,
+# define REG_EIP	REG_EIP
+  REG_CS,
+# define REG_CS		REG_CS
+  REG_EFL,
+# define REG_EFL	REG_EFL
+  REG_UESP,
+# define REG_UESP	REG_UESP
+  REG_SS
+# define REG_SS	REG_SS
+};
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/release.h xen-4.2.1-merge/stubdom/c_httpd_redis/release.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/release.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/release.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,2 @@
+#define REDIS_GIT_SHA1 "00000000"
+#define REDIS_GIT_DIRTY "0"
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/sds.c xen-4.2.1-merge/stubdom/c_httpd_redis/sds.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/sds.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/sds.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,448 @@
+/* SDSLib, A C dynamic strings library
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define SDS_ABORT_ON_OOM
+
+#include "sds.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+#include "zmalloc.h"
+
+static void sdsOomAbort(void) {
+    fprintf(stderr,"SDS: Out Of Memory (SDS_ABORT_ON_OOM defined)\n");
+    abort();
+}
+
+sds sdsnewlen(const void *init, size_t initlen) {
+    struct sdshdr *sh;
+
+    sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
+#ifdef SDS_ABORT_ON_OOM
+    if (sh == NULL) sdsOomAbort();
+#else
+    if (sh == NULL) return NULL;
+#endif
+    sh->len = initlen;
+    sh->free = 0;
+    if (initlen) {
+        if (init) memcpy(sh->buf, init, initlen);
+        else memset(sh->buf,0,initlen);
+    }
+    sh->buf[initlen] = '\0';
+    return (char*)sh->buf;
+}
+
+sds sdsempty(void) {
+    return sdsnewlen("",0);
+}
+
+sds sdsnew(const char *init) {
+    size_t initlen = (init == NULL) ? 0 : strlen(init);
+    return sdsnewlen(init, initlen);
+}
+
+size_t sdslen(const sds s) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    return sh->len;
+}
+
+sds sdsdup(const sds s) {
+    return sdsnewlen(s, sdslen(s));
+}
+
+void sdsfree(sds s) {
+    if (s == NULL) return;
+    zfree(s-sizeof(struct sdshdr));
+}
+
+size_t sdsavail(sds s) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    return sh->free;
+}
+
+void sdsupdatelen(sds s) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    int reallen = strlen(s);
+    sh->free += (sh->len-reallen);
+    sh->len = reallen;
+}
+
+static sds sdsMakeRoomFor(sds s, size_t addlen) {
+    struct sdshdr *sh, *newsh;
+    size_t free = sdsavail(s);
+    size_t len, newlen;
+
+    if (free >= addlen) return s;
+    len = sdslen(s);
+    sh = (void*) (s-(sizeof(struct sdshdr)));
+    newlen = (len+addlen)*2;
+    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);
+#ifdef SDS_ABORT_ON_OOM
+    if (newsh == NULL) sdsOomAbort();
+#else
+    if (newsh == NULL) return NULL;
+#endif
+
+    newsh->free = newlen - len;
+    return newsh->buf;
+}
+
+sds sdscatlen(sds s, void *t, size_t len) {
+    struct sdshdr *sh;
+    size_t curlen = sdslen(s);
+
+    s = sdsMakeRoomFor(s,len);
+    if (s == NULL) return NULL;
+    sh = (void*) (s-(sizeof(struct sdshdr)));
+    memcpy(s+curlen, t, len);
+    sh->len = curlen+len;
+    sh->free = sh->free-len;
+    s[curlen+len] = '\0';
+    return s;
+}
+
+sds sdscat(sds s, char *t) {
+    return sdscatlen(s, t, strlen(t));
+}
+
+sds sdscpylen(sds s, char *t, size_t len) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    size_t totlen = sh->free+sh->len;
+
+    if (totlen < len) {
+        s = sdsMakeRoomFor(s,len-sh->len);
+        if (s == NULL) return NULL;
+        sh = (void*) (s-(sizeof(struct sdshdr)));
+        totlen = sh->free+sh->len;
+    }
+    memcpy(s, t, len);
+    s[len] = '\0';
+    sh->len = len;
+    sh->free = totlen-len;
+    return s;
+}
+
+sds sdscpy(sds s, char *t) {
+    return sdscpylen(s, t, strlen(t));
+}
+
+sds sdscatprintf(sds s, const char *fmt, ...) {
+    va_list ap;
+    char *buf, *t;
+    size_t buflen = 16;
+
+    while(1) {
+        buf = zmalloc(buflen);
+#ifdef SDS_ABORT_ON_OOM
+        if (buf == NULL) sdsOomAbort();
+#else
+        if (buf == NULL) return NULL;
+#endif
+        buf[buflen-2] = '\0';
+        va_start(ap, fmt);
+        vsnprintf(buf, buflen, fmt, ap);
+        va_end(ap);
+        if (buf[buflen-2] != '\0') {
+            zfree(buf);
+            buflen *= 2;
+            continue;
+        }
+        break;
+    }
+    t = sdscat(s, buf);
+    zfree(buf);
+    return t;
+}
+
+sds sdstrim(sds s, const char *cset) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    char *start, *end, *sp, *ep;
+    size_t len;
+
+    sp = start = s;
+    ep = end = s+sdslen(s)-1;
+    while(sp <= end && strchr(cset, *sp)) sp++;
+    while(ep > start && strchr(cset, *ep)) ep--;
+    len = (sp > ep) ? 0 : ((ep-sp)+1);
+    if (sh->buf != sp) memmove(sh->buf, sp, len);
+    sh->buf[len] = '\0';
+    sh->free = sh->free+(sh->len-len);
+    sh->len = len;
+    return s;
+}
+
+sds sdsrange(sds s, long start, long end) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    size_t newlen, len = sdslen(s);
+
+    if (len == 0) return s;
+    if (start < 0) {
+        start = len+start;
+        if (start < 0) start = 0;
+    }
+    if (end < 0) {
+        end = len+end;
+        if (end < 0) end = 0;
+    }
+    newlen = (start > end) ? 0 : (end-start)+1;
+    if (newlen != 0) {
+        if (start >= (signed)len) start = len-1;
+        if (end >= (signed)len) end = len-1;
+        newlen = (start > end) ? 0 : (end-start)+1;
+    } else {
+        start = 0;
+    }
+    if (start != 0) memmove(sh->buf, sh->buf+start, newlen);
+    sh->buf[newlen] = 0;
+    sh->free = sh->free+(sh->len-newlen);
+    sh->len = newlen;
+    return s;
+}
+
+void sdstolower(sds s) {
+    int len = sdslen(s), j;
+
+    for (j = 0; j < len; j++) s[j] = tolower(s[j]);
+}
+
+void sdstoupper(sds s) {
+    int len = sdslen(s), j;
+
+    for (j = 0; j < len; j++) s[j] = toupper(s[j]);
+}
+
+int sdscmp(sds s1, sds s2) {
+    size_t l1, l2, minlen;
+    int cmp;
+
+    l1 = sdslen(s1);
+    l2 = sdslen(s2);
+    minlen = (l1 < l2) ? l1 : l2;
+    cmp = memcmp(s1,s2,minlen);
+    if (cmp == 0) return l1-l2;
+    return cmp;
+}
+
+/* Split 's' with separator in 'sep'. An array
+ * of sds strings is returned. *count will be set
+ * by reference to the number of tokens returned.
+ *
+ * On out of memory, zero length string, zero length
+ * separator, NULL is returned.
+ *
+ * Note that 'sep' is able to split a string using
+ * a multi-character separator. For example
+ * sdssplit("foo_-_bar","_-_"); will return two
+ * elements "foo" and "bar".
+ *
+ * This version of the function is binary-safe but
+ * requires length arguments. sdssplit() is just the
+ * same function but for zero-terminated strings.
+ */
+sds *sdssplitlen(char *s, int len, char *sep, int seplen, int *count) {
+    int elements = 0, slots = 5, start = 0, j;
+
+    sds *tokens = zmalloc(sizeof(sds)*slots);
+#ifdef SDS_ABORT_ON_OOM
+    if (tokens == NULL) sdsOomAbort();
+#endif
+    if (seplen < 1 || len < 0 || tokens == NULL) return NULL;
+    if (len == 0) {
+        *count = 0;
+        return tokens;
+    }
+    for (j = 0; j < (len-(seplen-1)); j++) {
+        /* make sure there is room for the next element and the final one */
+        if (slots < elements+2) {
+            sds *newtokens;
+
+            slots *= 2;
+            newtokens = zrealloc(tokens,sizeof(sds)*slots);
+            if (newtokens == NULL) {
+#ifdef SDS_ABORT_ON_OOM
+                sdsOomAbort();
+#else
+                goto cleanup;
+#endif
+            }
+            tokens = newtokens;
+        }
+        /* search the separator */
+        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
+            tokens[elements] = sdsnewlen(s+start,j-start);
+            if (tokens[elements] == NULL) {
+#ifdef SDS_ABORT_ON_OOM
+                sdsOomAbort();
+#else
+                goto cleanup;
+#endif
+            }
+            elements++;
+            start = j+seplen;
+            j = j+seplen-1; /* skip the separator */
+        }
+    }
+    /* Add the final element. We are sure there is room in the tokens array. */
+    tokens[elements] = sdsnewlen(s+start,len-start);
+    if (tokens[elements] == NULL) {
+#ifdef SDS_ABORT_ON_OOM
+                sdsOomAbort();
+#else
+                goto cleanup;
+#endif
+    }
+    elements++;
+    *count = elements;
+    return tokens;
+
+#ifndef SDS_ABORT_ON_OOM
+cleanup:
+    {
+        int i;
+        for (i = 0; i < elements; i++) sdsfree(tokens[i]);
+        zfree(tokens);
+        return NULL;
+    }
+#endif
+}
+
+void sdsfreesplitres(sds *tokens, int count) {
+    if (!tokens) return;
+    while(count--)
+        sdsfree(tokens[count]);
+    zfree(tokens);
+}
+
+sds sdsfromlonglong(long long value) {
+    char buf[32], *p;
+    unsigned long long v;
+
+    v = (value < 0) ? -value : value;
+    p = buf+31; /* point to the last character */
+    do {
+        *p-- = '0'+(v%10);
+        v /= 10;
+    } while(v);
+    if (value < 0) *p-- = '-';
+    p++;
+    return sdsnewlen(p,32-(p-buf));
+}
+
+/* Split a line into arguments, where every argument can be in the
+ * following programming-language REPL-alike form:
+ *
+ * foo bar "newline are supported\n" and "\xff\x00otherstuff"
+ *
+ * The number of arguments is stored into *argc, and an array
+ * of sds is returned. The caller should sdsfree() all the returned
+ * strings and finally zfree() the array itself.
+ *
+ * Note that sdscatrepr() is able to convert back a string into
+ * a quoted string in the same format sdssplitargs() is able to parse.
+ */
+sds *sdssplitargs(char *line, int *argc) {
+    char *p = line;
+    char *current = NULL;
+    char **vector = NULL;
+
+    *argc = 0;
+    while(1) {
+        /* skip blanks */
+        while(*p && isspace(*p)) p++;
+        if (*p) {
+            /* get a token */
+            int inq=0; /* set to 1 if we are in "quotes" */
+            int done=0;
+
+            if (current == NULL) current = sdsempty();
+            while(!done) {
+                if (inq) {
+                    if (*p == '\\' && *(p+1)) {
+                        char c;
+
+                        p++;
+                        switch(*p) {
+                        case 'n': c = '\n'; break;
+                        case 'r': c = '\r'; break;
+                        case 't': c = '\t'; break;
+                        case 'b': c = '\b'; break;
+                        case 'a': c = '\a'; break;
+                        default: c = *p; break;
+                        }
+                        current = sdscatlen(current,&c,1);
+                    } else if (*p == '"') {
+                        /* closing quote must be followed by a space */
+                        if (*(p+1) && !isspace(*(p+1))) goto err;
+                        done=1;
+                    } else if (!*p) {
+                        /* unterminated quotes */
+                        goto err;
+                    } else {
+                        current = sdscatlen(current,p,1);
+                    }
+                } else {
+                    switch(*p) {
+                    case ' ':
+                    case '\n':
+                    case '\r':
+                    case '\t':
+                    case '\0':
+                        done=1;
+                        break;
+                    case '"':
+                        inq=1;
+                        break;
+                    default:
+                        current = sdscatlen(current,p,1);
+                        break;
+                    }
+                }
+                if (*p) p++;
+            }
+            /* add the token to the vector */
+            vector = zrealloc(vector,((*argc)+1)*sizeof(char*));
+            vector[*argc] = current;
+            (*argc)++;
+            current = NULL;
+        } else {
+            return vector;
+        }
+    }
+
+err:
+    while((*argc)--)
+        sdsfree(vector[*argc]);
+    zfree(vector);
+    if (current) sdsfree(current);
+    return NULL;
+}
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/sds.h xen-4.2.1-merge/stubdom/c_httpd_redis/sds.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/sds.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/sds.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,74 @@
+/* SDSLib, A C dynamic strings library
+ *
+ * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SDS_H
+#define __SDS_H
+
+#include <sys/types.h>
+
+typedef char *sds;
+
+struct sdshdr {
+    long len;
+    long free;
+    char buf[];
+};
+
+sds sdsnewlen(const void *init, size_t initlen);
+sds sdsnew(const char *init);
+sds sdsempty();
+size_t sdslen(const sds s);
+sds sdsdup(const sds s);
+void sdsfree(sds s);
+size_t sdsavail(sds s);
+sds sdscatlen(sds s, void *t, size_t len);
+sds sdscat(sds s, char *t);
+sds sdscpylen(sds s, char *t, size_t len);
+sds sdscpy(sds s, char *t);
+
+#ifdef __GNUC__
+sds sdscatprintf(sds s, const char *fmt, ...)
+    __attribute__((format(printf, 2, 3)));
+#else
+sds sdscatprintf(sds s, const char *fmt, ...);
+#endif
+
+sds sdstrim(sds s, const char *cset);
+sds sdsrange(sds s, long start, long end);
+void sdsupdatelen(sds s);
+int sdscmp(sds s1, sds s2);
+sds *sdssplitlen(char *s, int len, char *sep, int seplen, int *count);
+void sdsfreesplitres(sds *tokens, int count);
+void sdstolower(sds s);
+void sdstoupper(sds s);
+sds sdsfromlonglong(long long value);
+sds *sdssplitargs(char *line, int *argc);
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/server.c xen-4.2.1-merge/stubdom/c_httpd_redis/server.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/server.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/server.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,156 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#define MYPORT 6379    // the port users will be connecting to
+#define BACKLOG 200// how many pending connections queue will hold
+#define BUF_SIZE 1024
+int fd_A[BACKLOG];    // accepted connection fd
+int conn_amount;      // current connection amount
+void showclient()
+{
+	int i;
+	printf("-----> client amount: %d\n", conn_amount);
+	/*for (i = 0; i < BACKLOG; i++) {
+		printf("BACKLOG%d ---> fd = %d\n", i, fd_A[i]);
+	}*/
+	printf("\n\n");
+}
+int main(void)
+{
+    sleep(1);
+    printf("start server\n");
+	int sock_fd, new_fd;             // listen on sock_fd, new connection on new_fd
+	struct sockaddr_in server_addr;  // server address information
+	struct sockaddr_in client_addr;  // connector's address information
+	socklen_t sin_size;
+	int yes = 1;
+	char buf[BUF_SIZE];
+	int ret;
+	int i;
+	if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
+		perror("socket");
+		exit(1);
+	}
+	//if (setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
+	/*if (setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
+		//perror("setsockopt");
+		//exit(1);
+	}
+    if (fcntl(sock_fd, F_SETFL, O_NONBLOCK) == -1) {
+        printf("Set server socket nonblock failed\n");
+        exit(1);
+    }*/
+    memset(&server_addr, 0, sizeof(server_addr));
+	server_addr.sin_family = AF_INET;         // host byte order
+	server_addr.sin_port = htons(MYPORT);     // short, network byte order
+	server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // automatically fill with my IP
+	//memset(server_addr.sin_zero, '0', sizeof(server_addr.sin_zero));
+	if (bind(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
+		perror("bind");
+		exit(1);
+	}
+    printf("listen...\n");
+	if (listen(sock_fd, BACKLOG) == -1) {
+		perror("listen");
+		exit(1);
+	}
+	printf("listen port %d\n", MYPORT);
+	fd_set fdsr, wfds, efds;
+	int maxsock;
+	struct timeval tv;
+	conn_amount = 0;
+	sin_size = sizeof(client_addr);
+	maxsock = sock_fd;
+	while (1) 
+	{
+        sleep(1);  // it's necessary
+		// initialize file descriptor set
+		FD_ZERO(&fdsr);
+        FD_ZERO(&wfds);
+		//FD_ZERO(&efds);
+		FD_SET(sock_fd, &fdsr);  // add fd
+		FD_SET(sock_fd, &wfds);  // add fd
+		//FD_SET(sock_fd, &efds);  // add fd
+		// timeout setting
+		tv.tv_sec = 30;
+		tv.tv_usec = 0;
+		// add active connection to fd set
+		for (i = 0; i < BACKLOG; i++) {
+			if (fd_A[i] != 0) {
+				FD_SET(fd_A[i], &fdsr);
+			}
+		}
+        //printf("before select!!!!!!!!!!!! ret = %d\n", ret);
+        if ((select(maxsock + 1, &fdsr, &wfds, (fd_set*) 0, (struct timeval*) 0)) < 0) {
+			perror("select");
+			break;
+		} 
+
+		// check every fd in the set
+		for (i = 0; i < conn_amount; i++) 
+		{
+			if (FD_ISSET(fd_A[i], &fdsr)) // check which fd is ready
+			{
+				ret = recv(fd_A[i], buf, sizeof(buf), 0);
+				if (ret <= 0) 
+				{        // client close
+					printf("ret : %d and client[%d] close\n", ret, i);
+					close(fd_A[i]);
+					FD_CLR(fd_A[i], &fdsr);  // delete fd 
+					fd_A[i] = 0;
+					conn_amount--;
+				}
+				else 
+				{        // receive data
+					if (ret < BUF_SIZE)
+						memset(&buf[ret], '\0', 1); // add NULL('/0')
+					printf("client[%d] send:%s\n", i, buf);
+				}
+			}
+		}
+        // check whether a new connection comes
+		if (FD_ISSET(sock_fd, &fdsr))  // accept new connection 
+		{
+			new_fd = accept(sock_fd, (struct sockaddr *)&client_addr, &sin_size);
+			if (new_fd <= 0) 
+			{
+				perror("accept");
+				continue;
+			}
+			// add to fd queue
+			if (conn_amount < BACKLOG) 
+			{
+				fd_A[conn_amount++] = new_fd;
+				printf("------> new connection client[%d] %s:%d\n", conn_amount,
+						inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
+				if (new_fd > maxsock)  // update the maxsock fd for select function
+					maxsock = new_fd;
+		        showclient();
+			}
+			else 
+			{
+				printf("max connections arrive, exit\n");
+				send(new_fd, "bye", 4, 0);
+				close(new_fd);
+				break;   
+			}
+		}
+		// showclient();
+	}
+	// close other connections
+	for (i = 0; i < BACKLOG; i++) 
+	{
+		if (fd_A[i] != 0) 
+		{
+			close(fd_A[i]);
+		}
+	}
+	exit(0);
+}
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/sha1.c xen-4.2.1-merge/stubdom/c_httpd_redis/sha1.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/sha1.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/sha1.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,276 @@
+
+/* from valgrind tests */
+
+/* ================ sha1.c ================ */
+/*
+SHA-1 in C
+By Steve Reid <steve@edmweb.com>
+100% Public Domain
+
+Test Vectors (from FIPS PUB 180-1)
+"abc"
+  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
+"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
+  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
+A million repetitions of "a"
+  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
+*/
+
+/* #define LITTLE_ENDIAN * This should be #define'd already, if true. */
+/* #define SHA1HANDSOFF * Copies data before messing with it. */
+
+#define SHA1HANDSOFF
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>	/* for u_int*_t */
+#if defined(__sun)
+#include "solarisfixes.h"
+#endif
+#include "sha1.h"
+
+#ifndef BYTE_ORDER
+#if (BSD >= 199103)
+# include <machine/endian.h>
+#else
+#if defined(linux) || defined(__linux__)
+#include "endian.h"
+#else
+#define	LITTLE_ENDIAN	1234	/* least-significant byte first (vax, pc) */
+#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
+#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp)*/
+
+#if defined(vax) || defined(ns32000) || defined(sun386) || defined(__i386__) || \
+    defined(MIPSEL) || defined(_MIPSEL) || defined(BIT_ZERO_ON_RIGHT) || \
+    defined(__alpha__) || defined(__alpha)
+#define BYTE_ORDER	LITTLE_ENDIAN
+#endif
+
+#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
+    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
+    defined(MIPSEB) || defined(_MIPSEB) || defined(_IBMR2) || defined(DGUX) ||\
+    defined(apollo) || defined(__convex__) || defined(_CRAY) || \
+    defined(__hppa) || defined(__hp9000) || \
+    defined(__hp9000s300) || defined(__hp9000s700) || \
+    defined (BIT_ZERO_ON_LEFT) || defined(m68k) || defined(__sparc)
+#define BYTE_ORDER	BIG_ENDIAN
+#endif
+#endif /* linux */
+#endif /* BSD */
+#endif /* BYTE_ORDER */
+
+#if defined(__BYTE_ORDER) && !defined(BYTE_ORDER)
+#if (__BYTE_ORDER == __LITTLE_ENDIAN)
+#define BYTE_ORDER LITTLE_ENDIAN
+#else
+#define BYTE_ORDER BIG_ENDIAN
+#endif
+#endif
+
+#if !defined(BYTE_ORDER) || \
+    (BYTE_ORDER != BIG_ENDIAN && BYTE_ORDER != LITTLE_ENDIAN && \
+    BYTE_ORDER != PDP_ENDIAN)
+	/* you must determine what the correct bit order is for
+	 * your compiler - the next line is an intentional error
+	 * which will force your compiles to bomb until you fix
+	 * the above macros.
+	 */
+#error "Undefined or invalid BYTE_ORDER"
+#endif
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+/* blk0() and blk() perform the initial expand. */
+/* I got the idea of expanding during the round function from SSLeay */
+#if BYTE_ORDER == LITTLE_ENDIAN
+#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
+    |(rol(block->l[i],8)&0x00FF00FF))
+#elif BYTE_ORDER == BIG_ENDIAN
+#define blk0(i) block->l[i]
+#else
+#error "Endianness not defined!"
+#endif
+#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
+    ^block->l[(i+2)&15]^block->l[i&15],1))
+
+/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
+#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
+#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
+
+
+/* Hash a single 512-bit block. This is the core of the algorithm. */
+
+void SHA1Transform(u_int32_t state[5], const unsigned char buffer[64])
+{
+u_int32_t a, b, c, d, e;
+typedef union {
+    unsigned char c[64];
+    u_int32_t l[16];
+} CHAR64LONG16;
+#ifdef SHA1HANDSOFF
+CHAR64LONG16 block[1];  /* use array to appear as a pointer */
+    memcpy(block, buffer, 64);
+#else
+    /* The following had better never be used because it causes the
+     * pointer-to-const buffer to be cast into a pointer to non-const.
+     * And the result is written through.  I threw a "const" in, hoping
+     * this will cause a diagnostic.
+     */
+CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
+#endif
+    /* Copy context->state[] to working vars */
+    a = state[0];
+    b = state[1];
+    c = state[2];
+    d = state[3];
+    e = state[4];
+    /* 4 rounds of 20 operations each. Loop unrolled. */
+    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
+    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
+    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
+    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
+    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
+    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
+    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
+    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
+    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
+    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
+    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
+    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
+    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
+    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
+    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
+    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
+    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
+    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
+    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
+    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
+    /* Add the working vars back into context.state[] */
+    state[0] += a;
+    state[1] += b;
+    state[2] += c;
+    state[3] += d;
+    state[4] += e;
+    /* Wipe variables */
+    a = b = c = d = e = 0;
+#ifdef SHA1HANDSOFF
+    memset(block, '\0', sizeof(block));
+#endif
+}
+
+
+/* SHA1Init - Initialize new context */
+
+void SHA1Init(SHA1_CTX* context)
+{
+    /* SHA1 initialization constants */
+    context->state[0] = 0x67452301;
+    context->state[1] = 0xEFCDAB89;
+    context->state[2] = 0x98BADCFE;
+    context->state[3] = 0x10325476;
+    context->state[4] = 0xC3D2E1F0;
+    context->count[0] = context->count[1] = 0;
+}
+
+
+/* Run your data through this. */
+
+void SHA1Update(SHA1_CTX* context, const unsigned char* data, u_int32_t len)
+{
+u_int32_t i;
+u_int32_t j;
+
+    j = context->count[0];
+    if ((context->count[0] += len << 3) < j)
+	context->count[1]++;
+    context->count[1] += (len>>29);
+    j = (j >> 3) & 63;
+    if ((j + len) > 63) {
+        memcpy(&context->buffer[j], data, (i = 64-j));
+        SHA1Transform(context->state, context->buffer);
+        for ( ; i + 63 < len; i += 64) {
+            SHA1Transform(context->state, &data[i]);
+        }
+        j = 0;
+    }
+    else i = 0;
+    memcpy(&context->buffer[j], &data[i], len - i);
+}
+
+
+/* Add padding and return the message digest. */
+
+void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
+{
+unsigned i;
+unsigned char finalcount[8];
+unsigned char c;
+
+#if 0	/* untested "improvement" by DHR */
+    /* Convert context->count to a sequence of bytes
+     * in finalcount.  Second element first, but
+     * big-endian order within element.
+     * But we do it all backwards.
+     */
+    unsigned char *fcp = &finalcount[8];
+
+    for (i = 0; i < 2; i++)
+    {
+	u_int32_t t = context->count[i];
+	int j;
+
+	for (j = 0; j < 4; t >>= 8, j++)
+	    *--fcp = (unsigned char) t
+    }
+#else
+    for (i = 0; i < 8; i++) {
+        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
+         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
+    }
+#endif
+    c = 0200;
+    SHA1Update(context, &c, 1);
+    while ((context->count[0] & 504) != 448) {
+	c = 0000;
+        SHA1Update(context, &c, 1);
+    }
+    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
+    for (i = 0; i < 20; i++) {
+        digest[i] = (unsigned char)
+         ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
+    }
+    /* Wipe variables */
+    memset(context, '\0', sizeof(*context));
+    memset(&finalcount, '\0', sizeof(finalcount));
+}
+/* ================ end of sha1.c ================ */
+
+#if 0
+#define BUFSIZE 4096
+
+int
+main(int argc, char **argv)
+{
+    SHA1_CTX ctx;
+    unsigned char hash[20], buf[BUFSIZE];
+    int i;
+
+    for(i=0;i<BUFSIZE;i++)
+        buf[i] = i;
+
+    SHA1Init(&ctx);
+    for(i=0;i<1000;i++)
+        SHA1Update(&ctx, buf, BUFSIZE);
+    SHA1Final(hash, &ctx);
+
+    printf("SHA1=");
+    for(i=0;i<20;i++)
+        printf("%02x", hash[i]);
+    printf("\n");
+    return 0;
+}
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/sha1.h xen-4.2.1-merge/stubdom/c_httpd_redis/sha1.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/sha1.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/sha1.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,17 @@
+/* ================ sha1.h ================ */
+/*
+SHA-1 in C
+By Steve Reid <steve@edmweb.com>
+100% Public Domain
+*/
+typedef unsigned int u_int32_t;
+typedef struct {
+    u_int32_t state[5];
+    u_int32_t count[2];
+    unsigned char buffer[64];
+} SHA1_CTX;
+
+void SHA1Transform(u_int32_t state[5], const unsigned char buffer[64]);
+void SHA1Init(SHA1_CTX* context);
+void SHA1Update(SHA1_CTX* context, const unsigned char* data, u_int32_t len);
+void SHA1Final(unsigned char digest[20], SHA1_CTX* context);
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/staticsymbols.h xen-4.2.1-merge/stubdom/c_httpd_redis/staticsymbols.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/staticsymbols.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/staticsymbols.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,360 @@
+static struct redisFunctionSym symsTable[] = {
+//{"IOThreadEntryPoint",(unsigned long)IOThreadEntryPoint},
+{"_redisAssert",(unsigned long)_redisAssert},
+{"_redisPanic",(unsigned long)_redisPanic},
+{"acceptHandler",(unsigned long)acceptHandler},
+{"addReply",(unsigned long)addReply},
+{"addReplyBulk",(unsigned long)addReplyBulk},
+{"addReplyBulkCString",(unsigned long)addReplyBulkCString},
+{"addReplyBulkLen",(unsigned long)addReplyBulkLen},
+{"addReplyDouble",(unsigned long)addReplyDouble},
+{"addReplyLongLong",(unsigned long)addReplyLongLong},
+{"addReplySds",(unsigned long)addReplySds},
+{"addReplyUlong",(unsigned long)addReplyUlong},
+//{"aofRemoveTempFile",(unsigned long)aofRemoveTempFile},
+//{"appendCommand",(unsigned long)appendCommand},
+//{"appendServerSaveParams",(unsigned long)appendServerSaveParams},
+{"authCommand",(unsigned long)authCommand},
+{"beforeSleep",(unsigned long)beforeSleep},
+//{"bgrewriteaofCommand",(unsigned long)bgrewriteaofCommand},
+//{"bgsaveCommand",(unsigned long)bgsaveCommand},
+//{"blockClientOnSwappedKeys",(unsigned long)blockClientOnSwappedKeys},
+{"blockForKeys",(unsigned long)blockForKeys},
+{"blockingPopGenericCommand",(unsigned long)blockingPopGenericCommand},
+{"blpopCommand",(unsigned long)blpopCommand},
+{"brpopCommand",(unsigned long)brpopCommand},
+{"bytesToHuman",(unsigned long)bytesToHuman},
+{"call",(unsigned long)call},
+//{"catAppendOnlyExpireAtCommand",(unsigned long)catAppendOnlyExpireAtCommand},
+//{"catAppendOnlyGenericCommand",(unsigned long)catAppendOnlyGenericCommand},
+{"checkType",(unsigned long)checkType},
+{"closeTimedoutClients",(unsigned long)closeTimedoutClients},
+{"compareStringObjects",(unsigned long)compareStringObjects},
+{"computeDatasetDigest",(unsigned long)computeDatasetDigest},
+//{"computeObjectSwappability",(unsigned long)computeObjectSwappability},
+{"configCommand",(unsigned long)configCommand},
+{"configGetCommand",(unsigned long)configGetCommand},
+{"configSetCommand",(unsigned long)configSetCommand},
+{"convertToRealHash",(unsigned long)convertToRealHash},
+{"createClient",(unsigned long)createClient},
+{"createHashObject",(unsigned long)createHashObject},
+{"createListObject",(unsigned long)createListObject},
+{"createObject",(unsigned long)createObject},
+{"createSetObject",(unsigned long)createSetObject},
+{"createSharedObjects",(unsigned long)createSharedObjects},
+{"createSortOperation",(unsigned long)createSortOperation},
+{"createStringObject",(unsigned long)createStringObject},
+{"createStringObjectFromLongLong",(unsigned long)createStringObjectFromLongLong},
+{"createZsetObject",(unsigned long)createZsetObject},
+//{"daemonize",(unsigned long)daemonize},
+{"dbsizeCommand",(unsigned long)dbsizeCommand},
+//{"debugCommand",(unsigned long)debugCommand},
+{"decrCommand",(unsigned long)decrCommand},
+{"decrRefCount",(unsigned long)decrRefCount},
+{"decrbyCommand",(unsigned long)decrbyCommand},
+{"delCommand",(unsigned long)delCommand},
+//{"deleteIfSwapped",(unsigned long)deleteIfSwapped},
+{"deleteIfVolatile",(unsigned long)deleteIfVolatile},
+{"deleteKey",(unsigned long)deleteKey},
+{"dictEncObjKeyCompare",(unsigned long)dictEncObjKeyCompare},
+{"dictListDestructor",(unsigned long)dictListDestructor},
+{"dictObjKeyCompare",(unsigned long)dictObjKeyCompare},
+{"dictRedisObjectDestructor",(unsigned long)dictRedisObjectDestructor},
+{"dictVanillaFree",(unsigned long)dictVanillaFree},
+{"discardCommand",(unsigned long)discardCommand},
+//{"dontWaitForSwappedKey",(unsigned long)dontWaitForSwappedKey},
+{"dupClientReplyValue",(unsigned long)dupClientReplyValue},
+{"dupStringObject",(unsigned long)dupStringObject},
+{"echoCommand",(unsigned long)echoCommand},
+{"equalStringObjects",(unsigned long)equalStringObjects},
+//{"execBlockClientOnSwappedKeys",(unsigned long)execBlockClientOnSwappedKeys},
+{"execCommand",(unsigned long)execCommand},
+{"execCommandReplicateMulti",(unsigned long)execCommandReplicateMulti},
+{"existsCommand",(unsigned long)existsCommand},
+{"expireCommand",(unsigned long)expireCommand},
+{"expireGenericCommand",(unsigned long)expireGenericCommand},
+{"expireIfNeeded",(unsigned long)expireIfNeeded},
+{"expireatCommand",(unsigned long)expireatCommand},
+//{"feedAppendOnlyFile",(unsigned long)feedAppendOnlyFile},
+{"findFuncName",(unsigned long)findFuncName},
+//{"flushAppendOnlyFile",(unsigned long)flushAppendOnlyFile},
+//{"flushallCommand",(unsigned long)flushallCommand},
+{"flushdbCommand",(unsigned long)flushdbCommand},
+{"freeClient",(unsigned long)freeClient},
+{"freeClientArgv",(unsigned long)freeClientArgv},
+{"freeClientMultiState",(unsigned long)freeClientMultiState},
+//{"freeFakeClient",(unsigned long)freeFakeClient},
+{"freeHashObject",(unsigned long)freeHashObject},
+//{"freeIOJob",(unsigned long)freeIOJob},
+{"freeListObject",(unsigned long)freeListObject},
+{"freeMemoryIfNeeded",(unsigned long)freeMemoryIfNeeded},
+{"freePubsubPattern",(unsigned long)freePubsubPattern},
+{"freeSetObject",(unsigned long)freeSetObject},
+{"freeStringObject",(unsigned long)freeStringObject},
+{"freeZsetObject",(unsigned long)freeZsetObject},
+//{"fwriteBulkDouble",(unsigned long)fwriteBulkDouble},
+//{"fwriteBulkLong",(unsigned long)fwriteBulkLong},
+//{"fwriteBulkObject",(unsigned long)fwriteBulkObject},
+//{"fwriteBulkString",(unsigned long)fwriteBulkString},
+{"genRedisInfoString",(unsigned long)genRedisInfoString},
+{"genericHgetallCommand",(unsigned long)genericHgetallCommand},
+{"genericZrangebyscoreCommand",(unsigned long)genericZrangebyscoreCommand},
+{"getCommand",(unsigned long)getCommand},
+{"getDecodedObject",(unsigned long)getDecodedObject},
+{"getDoubleFromObject",(unsigned long)getDoubleFromObject},
+{"getDoubleFromObjectOrReply",(unsigned long)getDoubleFromObjectOrReply},
+{"getExpire",(unsigned long)getExpire},
+{"getGenericCommand",(unsigned long)getGenericCommand},
+{"getLongFromObjectOrReply",(unsigned long)getLongFromObjectOrReply},
+{"getLongLongFromObject",(unsigned long)getLongLongFromObject},
+{"getLongLongFromObjectOrReply",(unsigned long)getLongLongFromObjectOrReply},
+{"getMcontextEip",(unsigned long)getMcontextEip},
+{"getsetCommand",(unsigned long)getsetCommand},
+{"glueReplyBuffersIfNeeded",(unsigned long)glueReplyBuffersIfNeeded},
+//{"handleClientsBlockedOnSwappedKey",(unsigned long)handleClientsBlockedOnSwappedKey},
+{"handleClientsWaitingListPush",(unsigned long)handleClientsWaitingListPush},
+{"hashCurrent",(unsigned long)hashCurrent},
+{"hashDelete",(unsigned long)hashDelete},
+{"hashExists",(unsigned long)hashExists},
+{"hashGet",(unsigned long)hashGet},
+{"hashInitIterator",(unsigned long)hashInitIterator},
+{"hashLookupWriteOrCreate",(unsigned long)hashLookupWriteOrCreate},
+{"hashNext",(unsigned long)hashNext},
+{"hashReleaseIterator",(unsigned long)hashReleaseIterator},
+{"hashSet",(unsigned long)hashSet},
+{"hashTryConversion",(unsigned long)hashTryConversion},
+{"hashTryObjectEncoding",(unsigned long)hashTryObjectEncoding},
+{"hdelCommand",(unsigned long)hdelCommand},
+{"hexistsCommand",(unsigned long)hexistsCommand},
+{"hgetCommand",(unsigned long)hgetCommand},
+{"hgetallCommand",(unsigned long)hgetallCommand},
+{"hincrbyCommand",(unsigned long)hincrbyCommand},
+{"hkeysCommand",(unsigned long)hkeysCommand},
+{"hlenCommand",(unsigned long)hlenCommand},
+{"hmgetCommand",(unsigned long)hmgetCommand},
+{"hmsetCommand",(unsigned long)hmsetCommand},
+{"hsetCommand",(unsigned long)hsetCommand},
+{"hsetnxCommand",(unsigned long)hsetnxCommand},
+{"htNeedsResize",(unsigned long)htNeedsResize},
+{"hvalsCommand",(unsigned long)hvalsCommand},
+{"incrCommand",(unsigned long)incrCommand},
+{"incrDecrCommand",(unsigned long)incrDecrCommand},
+{"incrRefCount",(unsigned long)incrRefCount},
+{"incrbyCommand",(unsigned long)incrbyCommand},
+{"incrementallyRehash",(unsigned long)incrementallyRehash},
+{"infoCommand",(unsigned long)infoCommand},
+{"initClientMultiState",(unsigned long)initClientMultiState},
+{"initServer",(unsigned long)initServer},
+{"initServerConfig",(unsigned long)initServerConfig},
+{"isStringRepresentableAsLong",(unsigned long)isStringRepresentableAsLong},
+{"keysCommand",(unsigned long)keysCommand},
+{"lastsaveCommand",(unsigned long)lastsaveCommand},
+{"lindexCommand",(unsigned long)lindexCommand},
+{"listMatchObjects",(unsigned long)listMatchObjects},
+{"listMatchPubsubPattern",(unsigned long)listMatchPubsubPattern},
+{"ll2string",(unsigned long)ll2string},
+{"llenCommand",(unsigned long)llenCommand},
+{"loadServerConfig",(unsigned long)loadServerConfig},
+//{"lockThreadedIO",(unsigned long)lockThreadedIO},
+{"lookupKey",(unsigned long)lookupKey},
+{"lookupKeyByPattern",(unsigned long)lookupKeyByPattern},
+{"lookupKeyRead",(unsigned long)lookupKeyRead},
+{"lookupKeyReadOrReply",(unsigned long)lookupKeyReadOrReply},
+{"lookupKeyWrite",(unsigned long)lookupKeyWrite},
+{"lookupKeyWriteOrReply",(unsigned long)lookupKeyWriteOrReply},
+{"lpopCommand",(unsigned long)lpopCommand},
+{"lpushCommand",(unsigned long)lpushCommand},
+{"lrangeCommand",(unsigned long)lrangeCommand},
+{"lremCommand",(unsigned long)lremCommand},
+{"lsetCommand",(unsigned long)lsetCommand},
+{"ltrimCommand",(unsigned long)ltrimCommand},
+{"mgetCommand",(unsigned long)mgetCommand},
+{"mixDigest",(unsigned long)mixDigest},
+{"mixObjectDigest",(unsigned long)mixObjectDigest},
+{"monitorCommand",(unsigned long)monitorCommand},
+{"moveCommand",(unsigned long)moveCommand},
+{"msetCommand",(unsigned long)msetCommand},
+{"msetGenericCommand",(unsigned long)msetGenericCommand},
+{"msetnxCommand",(unsigned long)msetnxCommand},
+{"multiCommand",(unsigned long)multiCommand},
+{"oom",(unsigned long)oom},
+{"pingCommand",(unsigned long)pingCommand},
+{"popGenericCommand",(unsigned long)popGenericCommand},
+{"prepareForShutdown",(unsigned long)prepareForShutdown},
+{"processCommand",(unsigned long)processCommand},
+{"processInputBuffer",(unsigned long)processInputBuffer},
+{"psubscribeCommand",(unsigned long)psubscribeCommand},
+{"publishCommand",(unsigned long)publishCommand},
+{"pubsubPublishMessage",(unsigned long)pubsubPublishMessage},
+{"pubsubSubscribeChannel",(unsigned long)pubsubSubscribeChannel},
+{"pubsubSubscribePattern",(unsigned long)pubsubSubscribePattern},
+{"pubsubUnsubscribeAllChannels",(unsigned long)pubsubUnsubscribeAllChannels},
+{"pubsubUnsubscribeAllPatterns",(unsigned long)pubsubUnsubscribeAllPatterns},
+{"pubsubUnsubscribeChannel",(unsigned long)pubsubUnsubscribeChannel},
+{"pubsubUnsubscribePattern",(unsigned long)pubsubUnsubscribePattern},
+{"punsubscribeCommand",(unsigned long)punsubscribeCommand},
+{"pushGenericCommand",(unsigned long)pushGenericCommand},
+{"qsortCompareSetsByCardinality",(unsigned long)qsortCompareSetsByCardinality},
+{"qsortCompareZsetopsrcByCardinality",(unsigned long)qsortCompareZsetopsrcByCardinality},
+//{"queueIOJob",(unsigned long)queueIOJob},
+{"queueMultiCommand",(unsigned long)queueMultiCommand},
+{"randomkeyCommand",(unsigned long)randomkeyCommand},
+//{"rdbEncodeInteger",(unsigned long)rdbEncodeInteger},
+//{"rdbGenericLoadStringObject",(unsigned long)rdbGenericLoadStringObject},
+//{"rdbLoad",(unsigned long)rdbLoad},
+//{"rdbLoadDoubleValue",(unsigned long)rdbLoadDoubleValue},
+//{"rdbLoadEncodedStringObject",(unsigned long)rdbLoadEncodedStringObject},
+//{"rdbLoadIntegerObject",(unsigned long)rdbLoadIntegerObject},
+//{"rdbLoadLen",(unsigned long)rdbLoadLen},
+//{"rdbLoadLzfStringObject",(unsigned long)rdbLoadLzfStringObject},
+//{"rdbLoadObject",(unsigned long)rdbLoadObject},
+//{"rdbLoadStringObject",(unsigned long)rdbLoadStringObject},
+//{"rdbLoadTime",(unsigned long)rdbLoadTime},
+//{"rdbLoadType",(unsigned long)rdbLoadType},
+//{"rdbRemoveTempFile",(unsigned long)rdbRemoveTempFile},
+//{"rdbSave",(unsigned long)rdbSave},
+//{"rdbSaveBackground",(unsigned long)rdbSaveBackground},
+//{"rdbSaveDoubleValue",(unsigned long)rdbSaveDoubleValue},
+//{"rdbSaveLen",(unsigned long)rdbSaveLen},
+//{"rdbSaveLzfStringObject",(unsigned long)rdbSaveLzfStringObject},
+//{"rdbSaveObject",(unsigned long)rdbSaveObject},
+//{"rdbSaveRawString",(unsigned long)rdbSaveRawString},
+//{"rdbSaveStringObject",(unsigned long)rdbSaveStringObject},
+//{"rdbSaveTime",(unsigned long)rdbSaveTime},
+//{"rdbSaveType",(unsigned long)rdbSaveType},
+//{"rdbSavedObjectLen",(unsigned long)rdbSavedObjectLen},
+//{"rdbSavedObjectPages",(unsigned long)rdbSavedObjectPages},
+//{"rdbTryIntegerEncoding",(unsigned long)rdbTryIntegerEncoding},
+{"readQueryFromClient",(unsigned long)readQueryFromClient},
+{"redisLog",(unsigned long)redisLog},
+{"removeExpire",(unsigned long)removeExpire},
+{"renameCommand",(unsigned long)renameCommand},
+{"renameGenericCommand",(unsigned long)renameGenericCommand},
+{"renamenxCommand",(unsigned long)renamenxCommand},
+{"replicationFeedMonitors",(unsigned long)replicationFeedMonitors},
+{"replicationFeedSlaves",(unsigned long)replicationFeedSlaves},
+{"resetClient",(unsigned long)resetClient},
+//{"resetServerSaveParams",(unsigned long)resetServerSaveParams},
+//{"rewriteAppendOnlyFile",(unsigned long)rewriteAppendOnlyFile},
+//{"rewriteAppendOnlyFileBackground",(unsigned long)rewriteAppendOnlyFileBackground},
+{"rpopCommand",(unsigned long)rpopCommand},
+{"rpoplpushcommand",(unsigned long)rpoplpushcommand},
+{"rpushCommand",(unsigned long)rpushCommand},
+{"saddCommand",(unsigned long)saddCommand},
+//{"saveCommand",(unsigned long)saveCommand},
+{"scardCommand",(unsigned long)scardCommand},
+{"sdiffCommand",(unsigned long)sdiffCommand},
+{"sdiffstoreCommand",(unsigned long)sdiffstoreCommand},
+{"sdsDictKeyCompare",(unsigned long)sdsDictKeyCompare},
+{"sdscatrepr",(unsigned long)sdscatrepr},
+{"segvHandler",(unsigned long)segvHandler},
+{"selectCommand",(unsigned long)selectCommand},
+{"selectDb",(unsigned long)selectDb},
+{"sendBulkToSlave",(unsigned long)sendBulkToSlave},
+{"sendReplyToClient",(unsigned long)sendReplyToClient},
+//{"sendReplyToClientWritev",(unsigned long)sendReplyToClientWritev},
+{"serverCron",(unsigned long)serverCron},
+{"setCommand",(unsigned long)setCommand},
+{"setExpire",(unsigned long)setExpire},
+{"setGenericCommand",(unsigned long)setGenericCommand},
+{"setexCommand",(unsigned long)setexCommand},
+{"setnxCommand",(unsigned long)setnxCommand},
+{"setupSigSegvAction",(unsigned long)setupSigSegvAction},
+{"shutdownCommand",(unsigned long)shutdownCommand},
+{"sigtermHandler",(unsigned long)sigtermHandler},
+{"sinterCommand",(unsigned long)sinterCommand},
+{"sinterGenericCommand",(unsigned long)sinterGenericCommand},
+{"sinterstoreCommand",(unsigned long)sinterstoreCommand},
+{"sismemberCommand",(unsigned long)sismemberCommand},
+{"slaveofCommand",(unsigned long)slaveofCommand},
+{"smoveCommand",(unsigned long)smoveCommand},
+{"sortCommand",(unsigned long)sortCommand},
+{"sortCompare",(unsigned long)sortCompare},
+//{"spawnIOThread",(unsigned long)spawnIOThread},
+{"spopCommand",(unsigned long)spopCommand},
+{"srandmemberCommand",(unsigned long)srandmemberCommand},
+{"sremCommand",(unsigned long)sremCommand},
+//{"startAppendOnly",(unsigned long)startAppendOnly},
+//{"stopAppendOnly",(unsigned long)stopAppendOnly},
+{"stringObjectLen",(unsigned long)stringObjectLen},
+{"stringmatch",(unsigned long)stringmatch},
+{"stringmatchlen",(unsigned long)stringmatchlen},
+{"subscribeCommand",(unsigned long)subscribeCommand},
+{"substrCommand",(unsigned long)substrCommand},
+{"sunionCommand",(unsigned long)sunionCommand},
+{"sunionDiffGenericCommand",(unsigned long)sunionDiffGenericCommand},
+{"sunionstoreCommand",(unsigned long)sunionstoreCommand},
+//{"syncCommand",(unsigned long)syncCommand},
+{"syncRead",(unsigned long)syncRead},
+{"syncReadLine",(unsigned long)syncReadLine},
+//{"syncWithMaster",(unsigned long)syncWithMaster},
+{"syncWrite",(unsigned long)syncWrite},
+{"tryFreeOneObjectFromFreelist",(unsigned long)tryFreeOneObjectFromFreelist},
+{"tryObjectEncoding",(unsigned long)tryObjectEncoding},
+{"tryResizeHashTables",(unsigned long)tryResizeHashTables},
+{"ttlCommand",(unsigned long)ttlCommand},
+{"typeCommand",(unsigned long)typeCommand},
+{"unblockClientWaitingData",(unsigned long)unblockClientWaitingData},
+//{"unlockThreadedIO",(unsigned long)unlockThreadedIO},
+{"unsubscribeCommand",(unsigned long)unsubscribeCommand},
+{"updateDictResizePolicy",(unsigned long)updateDictResizePolicy},
+//{"updateSlavesWaitingBgsave",(unsigned long)updateSlavesWaitingBgsave},
+{"usage",(unsigned long)usage},
+{"version",(unsigned long)version},
+//{"vmCanSwapOut",(unsigned long)vmCanSwapOut},
+//{"vmCancelThreadedIOJob",(unsigned long)vmCancelThreadedIOJob},
+//{"vmFindContiguousPages",(unsigned long)vmFindContiguousPages},
+//{"vmFreePage",(unsigned long)vmFreePage},
+//{"vmGenericLoadObject",(unsigned long)vmGenericLoadObject},
+//{"vmInit",(unsigned long)vmInit},
+//{"vmLoadObject",(unsigned long)vmLoadObject},
+//{"vmMarkPageFree",(unsigned long)vmMarkPageFree},
+//{"vmMarkPageUsed",(unsigned long)vmMarkPageUsed},
+//{"vmMarkPagesFree",(unsigned long)vmMarkPagesFree},
+//{"vmMarkPagesUsed",(unsigned long)vmMarkPagesUsed},
+//{"vmPreviewObject",(unsigned long)vmPreviewObject},
+//{"vmReadObjectFromSwap",(unsigned long)vmReadObjectFromSwap},
+//{"vmReopenSwapFile",(unsigned long)vmReopenSwapFile},
+//{"vmSwapObjectBlocking",(unsigned long)vmSwapObjectBlocking},
+//{"vmSwapObjectThreaded",(unsigned long)vmSwapObjectThreaded},
+//{"vmSwapOneObject",(unsigned long)vmSwapOneObject},
+//{"vmSwapOneObjectBlocking",(unsigned long)vmSwapOneObjectBlocking},
+//{"vmSwapOneObjectThreaded",(unsigned long)vmSwapOneObjectThreaded},
+//{"vmThreadedIOCompletedJob",(unsigned long)vmThreadedIOCompletedJob},
+//{"vmWriteObjectOnSwap",(unsigned long)vmWriteObjectOnSwap},
+//{"waitEmptyIOJobsQueue",(unsigned long)waitEmptyIOJobsQueue},
+//{"waitForMultipleSwappedKeys",(unsigned long)waitForMultipleSwappedKeys},
+//{"waitForSwappedKey",(unsigned long)waitForSwappedKey},
+{"xorDigest",(unsigned long)xorDigest},
+{"xorObjectDigest",(unsigned long)xorObjectDigest},
+{"yesnotoi",(unsigned long)yesnotoi},
+{"zaddCommand",(unsigned long)zaddCommand},
+{"zaddGenericCommand",(unsigned long)zaddGenericCommand},
+{"zcardCommand",(unsigned long)zcardCommand},
+{"zcountCommand",(unsigned long)zcountCommand},
+{"zincrbyCommand",(unsigned long)zincrbyCommand},
+{"zinterstoreCommand",(unsigned long)zinterstoreCommand},
+{"zrangeCommand",(unsigned long)zrangeCommand},
+{"zrangeGenericCommand",(unsigned long)zrangeGenericCommand},
+{"zrangebyscoreCommand",(unsigned long)zrangebyscoreCommand},
+{"zrankCommand",(unsigned long)zrankCommand},
+{"zrankGenericCommand",(unsigned long)zrankGenericCommand},
+{"zremCommand",(unsigned long)zremCommand},
+{"zremrangebyrankCommand",(unsigned long)zremrangebyrankCommand},
+{"zremrangebyscoreCommand",(unsigned long)zremrangebyscoreCommand},
+{"zrevrangeCommand",(unsigned long)zrevrangeCommand},
+{"zrevrankCommand",(unsigned long)zrevrankCommand},
+{"zscoreCommand",(unsigned long)zscoreCommand},
+{"zslCreate",(unsigned long)zslCreate},
+{"zslCreateNode",(unsigned long)zslCreateNode},
+{"zslDelete",(unsigned long)zslDelete},
+{"zslFirstWithScore",(unsigned long)zslFirstWithScore},
+{"zslFree",(unsigned long)zslFree},
+{"zslFreeNode",(unsigned long)zslFreeNode},
+{"zslInsert",(unsigned long)zslInsert},
+{"zslRandomLevel",(unsigned long)zslRandomLevel},
+//{"zunionInterBlockClientOnSwappedKeys",(unsigned long)zunionInterBlockClientOnSwappedKeys},
+{"zunionInterGenericCommand",(unsigned long)zunionInterGenericCommand},
+{"zunionstoreCommand",(unsigned long)zunionstoreCommand},
+{NULL,0}
+};
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/uio.h xen-4.2.1-merge/stubdom/c_httpd_redis/uio.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/uio.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/uio.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,26 @@
+#ifndef _SYS_UIO_H
+#define _SYS_UIO_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Per POSIX
+ */
+
+struct iovec {
+  void   *iov_base;
+  size_t  iov_len;
+};
+
+ssize_t readv(int, const struct iovec *, int);
+ssize_t writev(int, const struct iovec *, int);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
Binary files xen-4.2.1-origin/stubdom/c_httpd_redis/web-server.a and xen-4.2.1-merge/stubdom/c_httpd_redis/web-server.a differ
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/zipmap.c xen-4.2.1-merge/stubdom/c_httpd_redis/zipmap.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/zipmap.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/zipmap.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,456 @@
+/* String -> String Map data structure optimized for size.
+ * This file implements a data structure mapping strings to other strings
+ * implementing an O(n) lookup data structure designed to be very memory
+ * efficient.
+ *
+ * The Redis Hash type uses this data structure for hashes composed of a small
+ * number of elements, to switch to an hash table once a given number of
+ * elements is reached.
+ *
+ * Given that many times Redis Hashes are used to represent objects composed
+ * of few fields, this is a very big win in terms of used memory.
+ *
+ * --------------------------------------------------------------------------
+ *
+ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Memory layout of a zipmap, for the map "foo" => "bar", "hello" => "world":
+ *
+ * <zmlen><len>"foo"<len><free>"bar"<len>"hello"<len><free>"world"
+ *
+ * <zmlen> is 1 byte length that holds the current size of the zipmap.
+ * When the zipmap length is greater than or equal to 254, this value
+ * is not used and the zipmap needs to be traversed to find out the length.
+ *
+ * <len> is the length of the following string (key or value).
+ * <len> lengths are encoded in a single value or in a 5 bytes value.
+ * If the first byte value (as an unsigned 8 bit value) is between 0 and
+ * 252, it's a single-byte length. If it is 253 then a four bytes unsigned
+ * integer follows (in the host byte ordering). A value fo 255 is used to
+ * signal the end of the hash. The special value 254 is used to mark
+ * empty space that can be used to add new key/value pairs.
+ *
+ * <free> is the number of free unused bytes
+ * after the string, resulting from modification of values associated to a
+ * key (for instance if "foo" is set to "bar', and later "foo" will be se to
+ * "hi", I'll have a free byte to use if the value will enlarge again later,
+ * or even in order to add a key/value pair if it fits.
+ *
+ * <free> is always an unsigned 8 bit number, because if after an
+ * update operation there are more than a few free bytes, the zipmap will be
+ * reallocated to make sure it is as small as possible.
+ *
+ * The most compact representation of the above two elements hash is actually:
+ *
+ * "\x02\x03foo\x03\x00bar\x05hello\x05\x00world\xff"
+ *
+ * Note that because keys and values are prefixed length "objects",
+ * the lookup will take O(N) where N is the number of elements
+ * in the zipmap and *not* the number of bytes needed to represent the zipmap.
+ * This lowers the constant times considerably.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include "zmalloc.h"
+
+#define ZIPMAP_BIGLEN 254
+#define ZIPMAP_END 255
+
+/* The following defines the max value for the <free> field described in the
+ * comments above, that is, the max number of trailing bytes in a value. */
+#define ZIPMAP_VALUE_MAX_FREE 4
+
+/* The following macro returns the number of bytes needed to encode the length
+ * for the integer value _l, that is, 1 byte for lengths < ZIPMAP_BIGLEN and
+ * 5 bytes for all the other lengths. */
+#define ZIPMAP_LEN_BYTES(_l) (((_l) < ZIPMAP_BIGLEN) ? 1 : sizeof(unsigned int)+1)
+
+/* Create a new empty zipmap. */
+unsigned char *zipmapNew(void) {
+    unsigned char *zm = zmalloc(2);
+
+    zm[0] = 0; /* Length */
+    zm[1] = ZIPMAP_END;
+    return zm;
+}
+
+/* Decode the encoded length pointed by 'p' */
+static unsigned int zipmapDecodeLength(unsigned char *p) {
+    unsigned int len = *p;
+
+    if (len < ZIPMAP_BIGLEN) return len;
+    memcpy(&len,p+1,sizeof(unsigned int));
+    return len;
+}
+
+/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns
+ * the amount of bytes required to encode such a length. */
+static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {
+    if (p == NULL) {
+        return ZIPMAP_LEN_BYTES(len);
+    } else {
+        if (len < ZIPMAP_BIGLEN) {
+            p[0] = len;
+            return 1;
+        } else {
+            p[0] = ZIPMAP_BIGLEN;
+            memcpy(p+1,&len,sizeof(len));
+            return 1+sizeof(len);
+        }
+    }
+}
+
+/* Search for a matching key, returning a pointer to the entry inside the
+ * zipmap. Returns NULL if the key is not found.
+ *
+ * If NULL is returned, and totlen is not NULL, it is set to the entire
+ * size of the zimap, so that the calling function will be able to
+ * reallocate the original zipmap to make room for more entries. */
+static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {
+    unsigned char *p = zm+1, *k = NULL;
+    unsigned int l,llen;
+
+    while(*p != ZIPMAP_END) {
+        unsigned char free;
+
+        /* Match or skip the key */
+        l = zipmapDecodeLength(p);
+        llen = zipmapEncodeLength(NULL,l);
+        if (k == NULL && l == klen && !memcmp(p+llen,key,l)) {
+            /* Only return when the user doesn't care
+             * for the total length of the zipmap. */
+            if (totlen != NULL) {
+                k = p;
+            } else {
+                return p;
+            }
+        }
+        p += llen+l;
+        /* Skip the value as well */
+        l = zipmapDecodeLength(p);
+        p += zipmapEncodeLength(NULL,l);
+        free = p[0];
+        p += l+1+free; /* +1 to skip the free byte */
+    }
+    if (totlen != NULL) *totlen = (unsigned int)(p-zm)+1;
+    return k;
+}
+
+static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {
+    unsigned int l;
+
+    l = klen+vlen+3;
+    if (klen >= ZIPMAP_BIGLEN) l += 4;
+    if (vlen >= ZIPMAP_BIGLEN) l += 4;
+    return l;
+}
+
+/* Return the total amount used by a key (encoded length + payload) */
+static unsigned int zipmapRawKeyLength(unsigned char *p) {
+    unsigned int l = zipmapDecodeLength(p);
+    
+    return zipmapEncodeLength(NULL,l) + l;
+}
+
+/* Return the total amount used by a value
+ * (encoded length + single byte free count + payload) */
+static unsigned int zipmapRawValueLength(unsigned char *p) {
+    unsigned int l = zipmapDecodeLength(p);
+    unsigned int used;
+    
+    used = zipmapEncodeLength(NULL,l);
+    used += p[used] + 1 + l;
+    return used;
+}
+
+/* If 'p' points to a key, this function returns the total amount of
+ * bytes used to store this entry (entry = key + associated value + trailing
+ * free space if any). */
+static unsigned int zipmapRawEntryLength(unsigned char *p) {
+    unsigned int l = zipmapRawKeyLength(p);
+    return l + zipmapRawValueLength(p+l);
+}
+
+static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {
+    zm = zrealloc(zm, len);
+    zm[len-1] = ZIPMAP_END;
+    return zm;
+}
+
+/* Set key to value, creating the key if it does not already exist.
+ * If 'update' is not NULL, *update is set to 1 if the key was
+ * already preset, otherwise to 0. */
+unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {
+    unsigned int zmlen, offset;
+    unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen);
+    unsigned int empty, vempty;
+    unsigned char *p;
+   
+    freelen = reqlen;
+    if (update) *update = 0;
+    p = zipmapLookupRaw(zm,key,klen,&zmlen);
+    if (p == NULL) {
+        /* Key not found: enlarge */
+        zm = zipmapResize(zm, zmlen+reqlen);
+        p = zm+zmlen-1;
+        zmlen = zmlen+reqlen;
+
+        /* Increase zipmap length (this is an insert) */
+        if (zm[0] < ZIPMAP_BIGLEN) zm[0]++;
+    } else {
+        /* Key found. Is there enough space for the new value? */
+        /* Compute the total length: */
+        if (update) *update = 1;
+        freelen = zipmapRawEntryLength(p);
+        if (freelen < reqlen) {
+            /* Store the offset of this key within the current zipmap, so
+             * it can be resized. Then, move the tail backwards so this
+             * pair fits at the current position. */
+            offset = p-zm;
+            zm = zipmapResize(zm, zmlen-freelen+reqlen);
+            p = zm+offset;
+
+            /* The +1 in the number of bytes to be moved is caused by the
+             * end-of-zipmap byte. Note: the *original* zmlen is used. */
+            memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1));
+            zmlen = zmlen-freelen+reqlen;
+            freelen = reqlen;
+        }
+    }
+
+    /* We now have a suitable block where the key/value entry can
+     * be written. If there is too much free space, move the tail
+     * of the zipmap a few bytes to the front and shrink the zipmap,
+     * as we want zipmaps to be very space efficient. */
+    empty = freelen-reqlen;
+    if (empty >= ZIPMAP_VALUE_MAX_FREE) {
+        /* First, move the tail <empty> bytes to the front, then resize
+         * the zipmap to be <empty> bytes smaller. */
+        offset = p-zm;
+        memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+1));
+        zmlen -= empty;
+        zm = zipmapResize(zm, zmlen);
+        p = zm+offset;
+        vempty = 0;
+    } else {
+        vempty = empty;
+    }
+
+    /* Just write the key + value and we are done. */
+    /* Key: */
+    p += zipmapEncodeLength(p,klen);
+    memcpy(p,key,klen);
+    p += klen;
+    /* Value: */
+    p += zipmapEncodeLength(p,vlen);
+    *p++ = vempty;
+    memcpy(p,val,vlen);
+    return zm;
+}
+
+/* Remove the specified key. If 'deleted' is not NULL the pointed integer is
+ * set to 0 if the key was not found, to 1 if it was found and deleted. */
+unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {
+    unsigned int zmlen, freelen;
+    unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen);
+    if (p) {
+        freelen = zipmapRawEntryLength(p);
+        memmove(p, p+freelen, zmlen-((p-zm)+freelen+1));
+        zm = zipmapResize(zm, zmlen-freelen);
+
+        /* Decrease zipmap length */
+        if (zm[0] < ZIPMAP_BIGLEN) zm[0]--;
+
+        if (deleted) *deleted = 1;
+    } else {
+        if (deleted) *deleted = 0;
+    }
+    return zm;
+}
+
+/* Call it before to iterate trought elements via zipmapNext() */
+unsigned char *zipmapRewind(unsigned char *zm) {
+    return zm+1;
+}
+
+/* This function is used to iterate through all the zipmap elements.
+ * In the first call the first argument is the pointer to the zipmap + 1.
+ * In the next calls what zipmapNext returns is used as first argument.
+ * Example:
+ *
+ * unsigned char *i = zipmapRewind(my_zipmap);
+ * while((i = zipmapNext(i,&key,&klen,&value,&vlen)) != NULL) {
+ *     printf("%d bytes key at $p\n", klen, key);
+ *     printf("%d bytes value at $p\n", vlen, value);
+ * }
+ */
+unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {
+    if (zm[0] == ZIPMAP_END) return NULL;
+    if (key) {
+        *key = zm;
+        *klen = zipmapDecodeLength(zm);
+        *key += ZIPMAP_LEN_BYTES(*klen);
+    }
+    zm += zipmapRawKeyLength(zm);
+    if (value) {
+        *value = zm+1;
+        *vlen = zipmapDecodeLength(zm);
+        *value += ZIPMAP_LEN_BYTES(*vlen);
+    }
+    zm += zipmapRawValueLength(zm);
+    return zm;
+}
+
+/* Search a key and retrieve the pointer and len of the associated value.
+ * If the key is found the function returns 1, otherwise 0. */
+int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {
+    unsigned char *p;
+
+    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) return 0;
+    p += zipmapRawKeyLength(p);
+    *vlen = zipmapDecodeLength(p);
+    *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1;
+    return 1;
+}
+
+/* Return 1 if the key exists, otherwise 0 is returned. */
+int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {
+    return zipmapLookupRaw(zm,key,klen,NULL) != NULL;
+}
+
+/* Return the number of entries inside a zipmap */
+unsigned int zipmapLen(unsigned char *zm) {
+    unsigned int len = 0;
+    if (zm[0] < ZIPMAP_BIGLEN) {
+        len = zm[0];
+    } else {
+        unsigned char *p = zipmapRewind(zm);
+        while((p = zipmapNext(p,NULL,NULL,NULL,NULL)) != NULL) len++;
+
+        /* Re-store length if small enough */
+        if (len < ZIPMAP_BIGLEN) zm[0] = len;
+    }
+    return len;
+}
+
+void zipmapRepr(unsigned char *p) {
+    unsigned int l;
+
+    printf("{status %u}",*p++);
+    while(1) {
+        if (p[0] == ZIPMAP_END) {
+            printf("{end}");
+            break;
+        } else {
+            unsigned char e;
+
+            l = zipmapDecodeLength(p);
+            printf("{key %u}",l);
+            p += zipmapEncodeLength(NULL,l);
+            fwrite(p,l,1,stdout);
+            p += l;
+
+            l = zipmapDecodeLength(p);
+            printf("{value %u}",l);
+            p += zipmapEncodeLength(NULL,l);
+            e = *p++;
+            fwrite(p,l,1,stdout);
+            p += l+e;
+            if (e) {
+                printf("[");
+                while(e--) printf(".");
+                printf("]");
+            }
+        }
+    }
+    printf("\n");
+}
+
+#ifdef ZIPMAP_TEST_MAIN
+int main(void) {
+    unsigned char *zm;
+
+    zm = zipmapNew();
+
+    zm = zipmapSet(zm,(unsigned char*) "name",4, (unsigned char*) "foo",3,NULL);
+    zm = zipmapSet(zm,(unsigned char*) "surname",7, (unsigned char*) "foo",3,NULL);
+    zm = zipmapSet(zm,(unsigned char*) "age",3, (unsigned char*) "foo",3,NULL);
+    zipmapRepr(zm);
+
+    zm = zipmapSet(zm,(unsigned char*) "hello",5, (unsigned char*) "world!",6,NULL);
+    zm = zipmapSet(zm,(unsigned char*) "foo",3, (unsigned char*) "bar",3,NULL);
+    zm = zipmapSet(zm,(unsigned char*) "foo",3, (unsigned char*) "!",1,NULL);
+    zipmapRepr(zm);
+    zm = zipmapSet(zm,(unsigned char*) "foo",3, (unsigned char*) "12345",5,NULL);
+    zipmapRepr(zm);
+    zm = zipmapSet(zm,(unsigned char*) "new",3, (unsigned char*) "xx",2,NULL);
+    zm = zipmapSet(zm,(unsigned char*) "noval",5, (unsigned char*) "",0,NULL);
+    zipmapRepr(zm);
+    zm = zipmapDel(zm,(unsigned char*) "new",3,NULL);
+    zipmapRepr(zm);
+
+    printf("\nLook up large key:\n");
+    {
+        unsigned char buf[512];
+        unsigned char *value;
+        unsigned int vlen, i;
+        for (i = 0; i < 512; i++) buf[i] = 'a';
+
+        zm = zipmapSet(zm,buf,512,(unsigned char*) "long",4,NULL);
+        if (zipmapGet(zm,buf,512,&value,&vlen)) {
+            printf("  <long key> is associated to the %d bytes value: %.*s\n",
+                vlen, vlen, value);
+        }
+    }
+
+    printf("\nPerform a direct lookup:\n");
+    {
+        unsigned char *value;
+        unsigned int vlen;
+
+        if (zipmapGet(zm,(unsigned char*) "foo",3,&value,&vlen)) {
+            printf("  foo is associated to the %d bytes value: %.*s\n",
+                vlen, vlen, value);
+        }
+    }
+    printf("\nIterate trought elements:\n");
+    {
+        unsigned char *i = zipmapRewind(zm);
+        unsigned char *key, *value;
+        unsigned int klen, vlen;
+
+        while((i = zipmapNext(i,&key,&klen,&value,&vlen)) != NULL) {
+            printf("  %d:%.*s => %d:%.*s\n", klen, klen, key, vlen, vlen, value);
+        }
+    }
+    return 0;
+}
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/zipmap.h xen-4.2.1-merge/stubdom/c_httpd_redis/zipmap.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/zipmap.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/zipmap.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,48 @@
+/* String -> String Map data structure optimized for size.
+ *
+ * See zipmap.c for more info.
+ *
+ * --------------------------------------------------------------------------
+ *
+ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _ZIMMAP_H
+#define _ZIPMAP_H
+
+unsigned char *zipmapNew(void);
+unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);
+unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);
+unsigned char *zipmapRewind(unsigned char *zm);
+unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen);
+int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);
+int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);
+unsigned int zipmapLen(unsigned char *zm);
+void zipmapRepr(unsigned char *p);
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/zmalloc.c xen-4.2.1-merge/stubdom/c_httpd_redis/zmalloc.c
--- xen-4.2.1-origin/stubdom/c_httpd_redis/zmalloc.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/zmalloc.c	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,139 @@
+/* zmalloc - total amount of allocated memory aware version of malloc()
+ *
+ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "config.h"
+
+#if defined(__sun)
+#define PREFIX_SIZE sizeof(long long)
+#else
+#define PREFIX_SIZE sizeof(size_t)
+#endif
+
+#define increment_used_memory(__n) do { \
+    size_t _n = (__n); \
+    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
+    used_memory += _n; \
+} while(0)
+
+#define decrement_used_memory(__n) do { \
+    size_t _n = (__n); \
+    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
+    used_memory -= _n; \
+} while(0)
+
+static size_t used_memory = 0;
+static int zmalloc_thread_safe = 0;
+
+static void zmalloc_oom(size_t size) {
+    fprintf(stderr, "zmalloc: Out of memory trying to allocate %zu bytes\n",
+        size);
+    fflush(stderr);
+    abort();
+}
+
+void *zmalloc(size_t size) {
+    void *ptr = malloc(size+PREFIX_SIZE);
+
+    if (!ptr) zmalloc_oom(size);
+#ifdef HAVE_MALLOC_SIZE
+    increment_used_memory(redis_malloc_size(ptr));
+    return ptr;
+#else
+    *((size_t*)ptr) = size;
+    increment_used_memory(size+PREFIX_SIZE);
+    return (char*)ptr+PREFIX_SIZE;
+#endif
+}
+
+void *zrealloc(void *ptr, size_t size) {
+#ifndef HAVE_MALLOC_SIZE
+    void *realptr;
+#endif
+    size_t oldsize;
+    void *newptr;
+
+    if (ptr == NULL) return zmalloc(size);
+#ifdef HAVE_MALLOC_SIZE
+    oldsize = redis_malloc_size(ptr);
+    newptr = realloc(ptr,size);
+    if (!newptr) zmalloc_oom(size);
+
+    decrement_used_memory(oldsize);
+    increment_used_memory(redis_malloc_size(newptr));
+    return newptr;
+#else
+    realptr = (char*)ptr-PREFIX_SIZE;
+    oldsize = *((size_t*)realptr);
+    newptr = realloc(realptr,size+PREFIX_SIZE);
+    if (!newptr) zmalloc_oom(size);
+
+    *((size_t*)newptr) = size;
+    decrement_used_memory(oldsize);
+    increment_used_memory(size);
+    return (char*)newptr+PREFIX_SIZE;
+#endif
+}
+
+void zfree(void *ptr) {
+#ifndef HAVE_MALLOC_SIZE
+    void *realptr;
+    size_t oldsize;
+#endif
+
+    if (ptr == NULL) return;
+#ifdef HAVE_MALLOC_SIZE
+    decrement_used_memory(redis_malloc_size(ptr));
+    free(ptr);
+#else
+    realptr = (char*)ptr-PREFIX_SIZE;
+    oldsize = *((size_t*)realptr);
+    decrement_used_memory(oldsize+PREFIX_SIZE);
+    free(realptr);
+#endif
+}
+
+char *zstrdup(const char *s) {
+    size_t l = strlen(s)+1;
+    char *p = zmalloc(l);
+
+    memcpy(p,s,l);
+    return p;
+}
+
+size_t zmalloc_used_memory(void) {
+    size_t um;
+
+    um = used_memory;
+    return um;
+}
+
diff -ruN xen-4.2.1-origin/stubdom/c_httpd_redis/zmalloc.h xen-4.2.1-merge/stubdom/c_httpd_redis/zmalloc.h
--- xen-4.2.1-origin/stubdom/c_httpd_redis/zmalloc.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_httpd_redis/zmalloc.h	2016-05-09 10:48:09.000000000 +0800
@@ -0,0 +1,41 @@
+/* zmalloc - total amount of allocated memory aware version of malloc()
+ *
+ * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   * Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *   * Neither the name of Redis nor the names of its contributors may be used
+ *     to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _ZMALLOC_H
+#define _ZMALLOC_H
+
+void *zmalloc(size_t size);
+void *zrealloc(void *ptr, size_t size);
+void zfree(void *ptr);
+char *zstrdup(const char *s);
+size_t zmalloc_used_memory(void);
+void zmalloc_enable_thread_safeness(void);
+
+#endif /* _ZMALLOC_H */
diff -ruN xen-4.2.1-origin/stubdom/c_origin/main.c xen-4.2.1-merge/stubdom/c_origin/main.c
--- xen-4.2.1-origin/stubdom/c_origin/main.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_origin/main.c	2016-07-03 21:48:32.000000000 +0800
@@ -0,0 +1,6 @@
+#include <stdio.h>
+int main () {
+    sleep(1);
+    printf("hello world\n");
+    return 0;
+}
diff -ruN xen-4.2.1-origin/stubdom/c_origin/Makefile xen-4.2.1-merge/stubdom/c_origin/Makefile
--- xen-4.2.1-origin/stubdom/c_origin/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_origin/Makefile	2016-07-03 21:48:24.000000000 +0800
@@ -0,0 +1,11 @@
+XEN_ROOT = $(CURDIR)/../..
+
+include $(XEN_ROOT)/Config.mk
+all: main.a
+
+main.a: main.o 
+	$(AR) cr $@ $^
+
+main.o: main.c
+clean:
+	rm -f *.a *.o
diff -ruN xen-4.2.1-origin/stubdom/c_origin/minios.cfg xen-4.2.1-merge/stubdom/c_origin/minios.cfg
--- xen-4.2.1-origin/stubdom/c_origin/minios.cfg	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/c_origin/minios.cfg	2016-07-03 21:54:54.000000000 +0800
@@ -0,0 +1 @@
+CONFIG_TEST=n
diff -ruN xen-4.2.1-origin/stubdom/Makefile xen-4.2.1-merge/stubdom/Makefile
--- xen-4.2.1-origin/stubdom/Makefile	2012-12-17 23:00:06.000000000 +0800
+++ xen-4.2.1-merge/stubdom/Makefile	2016-12-05 18:13:02.000000000 +0800
@@ -72,8 +72,14 @@
 TARGET_CPPFLAGS += -I$(CURDIR)/include
 TARGET_CPPFLAGS += -I$(XEN_ROOT)/xen/include
 
+TARGET_CPPFLAGS += -I$(CURDIR)/so_testx
+TARGET_CPPFLAGS += -I$(CURDIR)/so_testy
+
 TARGET_LDFLAGS += -nostdlib -L$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf/lib
 
+TARGET_LDFLAGS += -L$(CURDIR)/so_testx
+TARGET_LDFLAGS += -L$(CURDIR)/so_testy
+
 TARGETS=ioemu c caml grub xenstore
 
 .PHONY: all
@@ -112,8 +118,7 @@
 	( cd newlib-$(XEN_TARGET_ARCH) && \
 	  CC_FOR_TARGET="$(CC) $(TARGET_CPPFLAGS) $(TARGET_CFLAGS) $(NEWLIB_CFLAGS)" AR_FOR_TARGET=$(AR) LD_FOR_TARGET=$(LD) RANLIB_FOR_TARGET=$(RANLIB) ../newlib-$(NEWLIB_VERSION)/configure --prefix=$(CROSS_PREFIX) --verbose --target=$(GNU_TARGET_ARCH)-xen-elf --enable-newlib-io-long-long --disable-multilib && \
 	  $(MAKE) DESTDIR= && \
-	  $(MAKE) DESTDIR= install )
-
+	  $(MAKE) DESTDIR= install && \
 ############
 # Cross-zlib
 ############
@@ -358,9 +363,45 @@
 caml-stubdom: mini-os-$(XEN_TARGET_ARCH)-caml lwip-$(XEN_TARGET_ARCH) libxc cross-ocaml caml
 	DEF_CPPFLAGS="$(TARGET_CPPFLAGS)" DEF_CFLAGS="$(TARGET_CFLAGS)" DEF_LDFLAGS="$(TARGET_LDFLAGS)" MINIOS_CONFIG="$(CURDIR)/caml/minios.cfg" $(MAKE) DESTDIR= -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$< LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) APP_OBJS="$(CURDIR)/caml/main-caml.o $(CURDIR)/caml/caml.o $(CAMLLIB)/libasmrun.a"
 
+so_testx/libso_test.a: so_testx/so_test.o
+	ar r $@ $<
+so_testy/libso_test.a: so_testy/so_test.o
+	ar r $@ $<
+
+
+so_testx/so_test.o: so_testx/so_test.c
+	$(CC) $(TARGET_CPPFLAGS) $(TARGET_CFLAGS) -c -o $@ $<
+so_testy/so_test.o: so_testy/so_test.c
+	$(CC) $(TARGET_CPPFLAGS) $(TARGET_CFLAGS) -c -o $@ $<
+
+
+so_testx/so_test.so: so_testx/so_test_so.o
+	$(LD) $(TARGET_LDFLAGS) -shared -soname libso_test.so.1 -o $@ $<
+	ln -sf so_test.so $(@D)/libso_test.so.1
+	ln -sf so_test.so $(@D)/libso_test.so
+so_testx/so_test_so.o: so_testx/so_test.c
+	$(CC) $(TARGET_CPPFLAGS) $(TARGET_CFLAGS) -fPIC -c -o $@ $<
+
+so_testy/so_test.so: so_testy/so_test_so.o
+	$(LD) $(TARGET_LDFLAGS) -shared -soname libso_test.so.1 -o $@ $<
+	ln -sf so_test.so $(@D)/libso_test.so.1
+	ln -sf so_test.so $(@D)/libso_test.so
+so_testy/so_test_so.o: so_testy/so_test.c
+	$(CC) $(TARGET_CPPFLAGS) $(TARGET_CFLAGS) -fPIC -c -o $@ $<
+	
+
+#SO_LIBS = so_test/libso_test.a
+SO_LDRPATH_X = -rpath=/root/xen-4.2.1/stubdom/so_testx
+SO_LIBS_X = so_testx/so_test.so
+
+SO_LDRPATH_Y = -rpath=/root/xen-4.2.1/stubdom/so_testy
+SO_LIBS_Y = so_testy/so_test.so
+
 .PHONY: c-stubdom
-c-stubdom: mini-os-$(XEN_TARGET_ARCH)-c lwip-$(XEN_TARGET_ARCH) libxc c
-	DEF_CPPFLAGS="$(TARGET_CPPFLAGS)" DEF_CFLAGS="$(TARGET_CFLAGS)" DEF_LDFLAGS="$(TARGET_LDFLAGS)" MINIOS_CONFIG="$(CURDIR)/c/minios.cfg" $(MAKE) DESTDIR= -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$< LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) APP_OBJS=$(CURDIR)/c/main.a
+c-stubdom: mini-os-$(XEN_TARGET_ARCH)-c lwip-$(XEN_TARGET_ARCH) libxc c $(SO_LIBS_X) $(SO_LIBS_Y)
+	DEF_CPPFLAGS="$(TARGET_CPPFLAGS)" DEF_CFLAGS="$(TARGET_CFLAGS)" DEF_LDFLAGS="$(TARGET_LDFLAGS)" MINIOS_CONFIG="$(CURDIR)/c/minios.cfg" $(MAKE) DESTDIR= -C $(MINI_OS) OBJ_DIR=$(CURDIR)/$< LWIPDIR=$(CURDIR)/lwip-$(XEN_TARGET_ARCH) APP_OBJS=$(CURDIR)/c/main.a EXTRA_OBJS="$(CURDIR)/$(SO_LIBS_X) $(SO_LDRPATH_X)"
+	cp -f $(MINI_OS)/domain_config $(CURDIR)/$< 
+	ln -sf ../../tools/libxl/xl $</xl-test
 
 .PHONY: pv-grub
 pv-grub: mini-os-$(XEN_TARGET_ARCH)-grub libxc grub
@@ -428,6 +469,7 @@
 	rm -f mk-headers-$(XEN_TARGET_ARCH)
 	rm -fr ocaml-$(XEN_TARGET_ARCH)
 	rm -fr include
+	rm -fr xenstore
 
 # clean patched sources
 .PHONY: patchclean
diff -ruN xen-4.2.1-origin/stubdom/so_testx/so_test.c xen-4.2.1-merge/stubdom/so_testx/so_test.c
--- xen-4.2.1-origin/stubdom/so_testx/so_test.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/so_testx/so_test.c	2016-12-05 09:35:35.000000000 +0800
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+int so_test()
+{
+	printf("Hello World!\n");
+	return 0;
+}
diff -ruN xen-4.2.1-origin/stubdom/so_testx/so_test.h xen-4.2.1-merge/stubdom/so_testx/so_test.h
--- xen-4.2.1-origin/stubdom/so_testx/so_test.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/so_testx/so_test.h	2016-12-04 21:42:02.000000000 +0800
@@ -0,0 +1,7 @@
+#ifndef SO_TEST_H
+#define SO_TEST_H
+
+int so_test();
+
+
+#endif
diff -ruN xen-4.2.1-origin/stubdom/so_testy/so_test.c xen-4.2.1-merge/stubdom/so_testy/so_test.c
--- xen-4.2.1-origin/stubdom/so_testy/so_test.c	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/so_testy/so_test.c	2016-12-05 09:35:53.000000000 +0800
@@ -0,0 +1,14 @@
+/*************************************************************************
+    #> File Name: so_testy.c
+    #> Author: Yaozheng
+    #> Mail: wyaozheng1125@126.com 
+    #> Created Time: Thu 24 Sep 2015 03:07:42 PM CST
+ #************************************************************************/
+
+#include <stdio.h>
+
+int so_test()
+{
+	printf("Hello Xen!\n");
+	return 0;
+}
diff -ruN xen-4.2.1-origin/stubdom/so_testy/so_test.h xen-4.2.1-merge/stubdom/so_testy/so_test.h
--- xen-4.2.1-origin/stubdom/so_testy/so_test.h	1970-01-01 08:00:00.000000000 +0800
+++ xen-4.2.1-merge/stubdom/so_testy/so_test.h	2016-12-04 21:42:16.000000000 +0800
@@ -0,0 +1,13 @@
+/************************************************************************
+    #> File Name: so_testy.h
+    #> Author: Yaozheng
+    #> Mail: wyaozheng1125@126.com 
+    #> Created Time: Thu 24 Sep 2015 03:05:51 PM CST
+ #************************************************************************/
+
+#ifndef SO_TEST_H
+#define SO_TEST_H
+
+int so_test();
+
+#endif
